// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"
	io "io"

	garm_provider_commonparams "github.com/cloudbase/garm-provider-common/params"

	mock "github.com/stretchr/testify/mock"

	params "github.com/cloudbase/garm/params"
)

// Store is an autogenerated mock type for the Store type
type Store struct {
	mock.Mock
}

type Store_Expecter struct {
	mock *mock.Mock
}

func (_m *Store) EXPECT() *Store_Expecter {
	return &Store_Expecter{mock: &_m.Mock}
}

// AddEntityEvent provides a mock function with given fields: ctx, entity, event, eventLevel, statusMessage, maxEvents
func (_m *Store) AddEntityEvent(ctx context.Context, entity params.ForgeEntity, event params.EventType, eventLevel params.EventLevel, statusMessage string, maxEvents int) error {
	ret := _m.Called(ctx, entity, event, eventLevel, statusMessage, maxEvents)

	if len(ret) == 0 {
		panic("no return value specified for AddEntityEvent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, params.EventType, params.EventLevel, string, int) error); ok {
		r0 = rf(ctx, entity, event, eventLevel, statusMessage, maxEvents)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_AddEntityEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddEntityEvent'
type Store_AddEntityEvent_Call struct {
	*mock.Call
}

// AddEntityEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - entity params.ForgeEntity
//   - event params.EventType
//   - eventLevel params.EventLevel
//   - statusMessage string
//   - maxEvents int
func (_e *Store_Expecter) AddEntityEvent(ctx interface{}, entity interface{}, event interface{}, eventLevel interface{}, statusMessage interface{}, maxEvents interface{}) *Store_AddEntityEvent_Call {
	return &Store_AddEntityEvent_Call{Call: _e.mock.On("AddEntityEvent", ctx, entity, event, eventLevel, statusMessage, maxEvents)}
}

func (_c *Store_AddEntityEvent_Call) Run(run func(ctx context.Context, entity params.ForgeEntity, event params.EventType, eventLevel params.EventLevel, statusMessage string, maxEvents int)) *Store_AddEntityEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntity), args[2].(params.EventType), args[3].(params.EventLevel), args[4].(string), args[5].(int))
	})
	return _c
}

func (_c *Store_AddEntityEvent_Call) Return(_a0 error) *Store_AddEntityEvent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_AddEntityEvent_Call) RunAndReturn(run func(context.Context, params.ForgeEntity, params.EventType, params.EventLevel, string, int) error) *Store_AddEntityEvent_Call {
	_c.Call.Return(run)
	return _c
}

// AddInstanceEvent provides a mock function with given fields: ctx, instanceNameOrID, event, eventLevel, eventMessage
func (_m *Store) AddInstanceEvent(ctx context.Context, instanceNameOrID string, event params.EventType, eventLevel params.EventLevel, eventMessage string) error {
	ret := _m.Called(ctx, instanceNameOrID, event, eventLevel, eventMessage)

	if len(ret) == 0 {
		panic("no return value specified for AddInstanceEvent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.EventType, params.EventLevel, string) error); ok {
		r0 = rf(ctx, instanceNameOrID, event, eventLevel, eventMessage)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_AddInstanceEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddInstanceEvent'
type Store_AddInstanceEvent_Call struct {
	*mock.Call
}

// AddInstanceEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceNameOrID string
//   - event params.EventType
//   - eventLevel params.EventLevel
//   - eventMessage string
func (_e *Store_Expecter) AddInstanceEvent(ctx interface{}, instanceNameOrID interface{}, event interface{}, eventLevel interface{}, eventMessage interface{}) *Store_AddInstanceEvent_Call {
	return &Store_AddInstanceEvent_Call{Call: _e.mock.On("AddInstanceEvent", ctx, instanceNameOrID, event, eventLevel, eventMessage)}
}

func (_c *Store_AddInstanceEvent_Call) Run(run func(ctx context.Context, instanceNameOrID string, event params.EventType, eventLevel params.EventLevel, eventMessage string)) *Store_AddInstanceEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.EventType), args[3].(params.EventLevel), args[4].(string))
	})
	return _c
}

func (_c *Store_AddInstanceEvent_Call) Return(_a0 error) *Store_AddInstanceEvent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_AddInstanceEvent_Call) RunAndReturn(run func(context.Context, string, params.EventType, params.EventLevel, string) error) *Store_AddInstanceEvent_Call {
	_c.Call.Return(run)
	return _c
}

// BreakLockJobIsQueued provides a mock function with given fields: ctx, jobID
func (_m *Store) BreakLockJobIsQueued(ctx context.Context, jobID int64) error {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for BreakLockJobIsQueued")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, jobID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_BreakLockJobIsQueued_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BreakLockJobIsQueued'
type Store_BreakLockJobIsQueued_Call struct {
	*mock.Call
}

// BreakLockJobIsQueued is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID int64
func (_e *Store_Expecter) BreakLockJobIsQueued(ctx interface{}, jobID interface{}) *Store_BreakLockJobIsQueued_Call {
	return &Store_BreakLockJobIsQueued_Call{Call: _e.mock.On("BreakLockJobIsQueued", ctx, jobID)}
}

func (_c *Store_BreakLockJobIsQueued_Call) Run(run func(ctx context.Context, jobID int64)) *Store_BreakLockJobIsQueued_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *Store_BreakLockJobIsQueued_Call) Return(_a0 error) *Store_BreakLockJobIsQueued_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_BreakLockJobIsQueued_Call) RunAndReturn(run func(context.Context, int64) error) *Store_BreakLockJobIsQueued_Call {
	_c.Call.Return(run)
	return _c
}

// ControllerInfo provides a mock function with no fields
func (_m *Store) ControllerInfo() (params.ControllerInfo, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ControllerInfo")
	}

	var r0 params.ControllerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func() (params.ControllerInfo, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() params.ControllerInfo); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(params.ControllerInfo)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ControllerInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ControllerInfo'
type Store_ControllerInfo_Call struct {
	*mock.Call
}

// ControllerInfo is a helper method to define mock.On call
func (_e *Store_Expecter) ControllerInfo() *Store_ControllerInfo_Call {
	return &Store_ControllerInfo_Call{Call: _e.mock.On("ControllerInfo")}
}

func (_c *Store_ControllerInfo_Call) Run(run func()) *Store_ControllerInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Store_ControllerInfo_Call) Return(_a0 params.ControllerInfo, _a1 error) *Store_ControllerInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ControllerInfo_Call) RunAndReturn(run func() (params.ControllerInfo, error)) *Store_ControllerInfo_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEnterprise provides a mock function with given fields: ctx, name, credentialsName, webhookSecret, poolBalancerType, agentMode
func (_m *Store) CreateEnterprise(ctx context.Context, name string, credentialsName params.ForgeCredentials, webhookSecret string, poolBalancerType params.PoolBalancerType, agentMode bool) (params.Enterprise, error) {
	ret := _m.Called(ctx, name, credentialsName, webhookSecret, poolBalancerType, agentMode)

	if len(ret) == 0 {
		panic("no return value specified for CreateEnterprise")
	}

	var r0 params.Enterprise
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) (params.Enterprise, error)); ok {
		return rf(ctx, name, credentialsName, webhookSecret, poolBalancerType, agentMode)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) params.Enterprise); ok {
		r0 = rf(ctx, name, credentialsName, webhookSecret, poolBalancerType, agentMode)
	} else {
		r0 = ret.Get(0).(params.Enterprise)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) error); ok {
		r1 = rf(ctx, name, credentialsName, webhookSecret, poolBalancerType, agentMode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateEnterprise_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEnterprise'
type Store_CreateEnterprise_Call struct {
	*mock.Call
}

// CreateEnterprise is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - credentialsName params.ForgeCredentials
//   - webhookSecret string
//   - poolBalancerType params.PoolBalancerType
//   - agentMode bool
func (_e *Store_Expecter) CreateEnterprise(ctx interface{}, name interface{}, credentialsName interface{}, webhookSecret interface{}, poolBalancerType interface{}, agentMode interface{}) *Store_CreateEnterprise_Call {
	return &Store_CreateEnterprise_Call{Call: _e.mock.On("CreateEnterprise", ctx, name, credentialsName, webhookSecret, poolBalancerType, agentMode)}
}

func (_c *Store_CreateEnterprise_Call) Run(run func(ctx context.Context, name string, credentialsName params.ForgeCredentials, webhookSecret string, poolBalancerType params.PoolBalancerType, agentMode bool)) *Store_CreateEnterprise_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.ForgeCredentials), args[3].(string), args[4].(params.PoolBalancerType), args[5].(bool))
	})
	return _c
}

func (_c *Store_CreateEnterprise_Call) Return(_a0 params.Enterprise, _a1 error) *Store_CreateEnterprise_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_CreateEnterprise_Call) RunAndReturn(run func(context.Context, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) (params.Enterprise, error)) *Store_CreateEnterprise_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEntityPool provides a mock function with given fields: ctx, entity, param
func (_m *Store) CreateEntityPool(ctx context.Context, entity params.ForgeEntity, param params.CreatePoolParams) (params.Pool, error) {
	ret := _m.Called(ctx, entity, param)

	if len(ret) == 0 {
		panic("no return value specified for CreateEntityPool")
	}

	var r0 params.Pool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, params.CreatePoolParams) (params.Pool, error)); ok {
		return rf(ctx, entity, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, params.CreatePoolParams) params.Pool); ok {
		r0 = rf(ctx, entity, param)
	} else {
		r0 = ret.Get(0).(params.Pool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.ForgeEntity, params.CreatePoolParams) error); ok {
		r1 = rf(ctx, entity, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateEntityPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEntityPool'
type Store_CreateEntityPool_Call struct {
	*mock.Call
}

// CreateEntityPool is a helper method to define mock.On call
//   - ctx context.Context
//   - entity params.ForgeEntity
//   - param params.CreatePoolParams
func (_e *Store_Expecter) CreateEntityPool(ctx interface{}, entity interface{}, param interface{}) *Store_CreateEntityPool_Call {
	return &Store_CreateEntityPool_Call{Call: _e.mock.On("CreateEntityPool", ctx, entity, param)}
}

func (_c *Store_CreateEntityPool_Call) Run(run func(ctx context.Context, entity params.ForgeEntity, param params.CreatePoolParams)) *Store_CreateEntityPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntity), args[2].(params.CreatePoolParams))
	})
	return _c
}

func (_c *Store_CreateEntityPool_Call) Return(_a0 params.Pool, _a1 error) *Store_CreateEntityPool_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_CreateEntityPool_Call) RunAndReturn(run func(context.Context, params.ForgeEntity, params.CreatePoolParams) (params.Pool, error)) *Store_CreateEntityPool_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEntityScaleSet provides a mock function with given fields: _a0, entity, param
func (_m *Store) CreateEntityScaleSet(_a0 context.Context, entity params.ForgeEntity, param params.CreateScaleSetParams) (params.ScaleSet, error) {
	ret := _m.Called(_a0, entity, param)

	if len(ret) == 0 {
		panic("no return value specified for CreateEntityScaleSet")
	}

	var r0 params.ScaleSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, params.CreateScaleSetParams) (params.ScaleSet, error)); ok {
		return rf(_a0, entity, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, params.CreateScaleSetParams) params.ScaleSet); ok {
		r0 = rf(_a0, entity, param)
	} else {
		r0 = ret.Get(0).(params.ScaleSet)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.ForgeEntity, params.CreateScaleSetParams) error); ok {
		r1 = rf(_a0, entity, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateEntityScaleSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEntityScaleSet'
type Store_CreateEntityScaleSet_Call struct {
	*mock.Call
}

// CreateEntityScaleSet is a helper method to define mock.On call
//   - _a0 context.Context
//   - entity params.ForgeEntity
//   - param params.CreateScaleSetParams
func (_e *Store_Expecter) CreateEntityScaleSet(_a0 interface{}, entity interface{}, param interface{}) *Store_CreateEntityScaleSet_Call {
	return &Store_CreateEntityScaleSet_Call{Call: _e.mock.On("CreateEntityScaleSet", _a0, entity, param)}
}

func (_c *Store_CreateEntityScaleSet_Call) Run(run func(_a0 context.Context, entity params.ForgeEntity, param params.CreateScaleSetParams)) *Store_CreateEntityScaleSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntity), args[2].(params.CreateScaleSetParams))
	})
	return _c
}

func (_c *Store_CreateEntityScaleSet_Call) Return(scaleSet params.ScaleSet, err error) *Store_CreateEntityScaleSet_Call {
	_c.Call.Return(scaleSet, err)
	return _c
}

func (_c *Store_CreateEntityScaleSet_Call) RunAndReturn(run func(context.Context, params.ForgeEntity, params.CreateScaleSetParams) (params.ScaleSet, error)) *Store_CreateEntityScaleSet_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFileObject provides a mock function with given fields: ctx, param, reader
func (_m *Store) CreateFileObject(ctx context.Context, param params.CreateFileObjectParams, reader io.Reader) (params.FileObject, error) {
	ret := _m.Called(ctx, param, reader)

	if len(ret) == 0 {
		panic("no return value specified for CreateFileObject")
	}

	var r0 params.FileObject
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateFileObjectParams, io.Reader) (params.FileObject, error)); ok {
		return rf(ctx, param, reader)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateFileObjectParams, io.Reader) params.FileObject); ok {
		r0 = rf(ctx, param, reader)
	} else {
		r0 = ret.Get(0).(params.FileObject)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.CreateFileObjectParams, io.Reader) error); ok {
		r1 = rf(ctx, param, reader)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateFileObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFileObject'
type Store_CreateFileObject_Call struct {
	*mock.Call
}

// CreateFileObject is a helper method to define mock.On call
//   - ctx context.Context
//   - param params.CreateFileObjectParams
//   - reader io.Reader
func (_e *Store_Expecter) CreateFileObject(ctx interface{}, param interface{}, reader interface{}) *Store_CreateFileObject_Call {
	return &Store_CreateFileObject_Call{Call: _e.mock.On("CreateFileObject", ctx, param, reader)}
}

func (_c *Store_CreateFileObject_Call) Run(run func(ctx context.Context, param params.CreateFileObjectParams, reader io.Reader)) *Store_CreateFileObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.CreateFileObjectParams), args[2].(io.Reader))
	})
	return _c
}

func (_c *Store_CreateFileObject_Call) Return(fileObjParam params.FileObject, err error) *Store_CreateFileObject_Call {
	_c.Call.Return(fileObjParam, err)
	return _c
}

func (_c *Store_CreateFileObject_Call) RunAndReturn(run func(context.Context, params.CreateFileObjectParams, io.Reader) (params.FileObject, error)) *Store_CreateFileObject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateGiteaCredentials provides a mock function with given fields: ctx, param
func (_m *Store) CreateGiteaCredentials(ctx context.Context, param params.CreateGiteaCredentialsParams) (params.ForgeCredentials, error) {
	ret := _m.Called(ctx, param)

	if len(ret) == 0 {
		panic("no return value specified for CreateGiteaCredentials")
	}

	var r0 params.ForgeCredentials
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateGiteaCredentialsParams) (params.ForgeCredentials, error)); ok {
		return rf(ctx, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateGiteaCredentialsParams) params.ForgeCredentials); ok {
		r0 = rf(ctx, param)
	} else {
		r0 = ret.Get(0).(params.ForgeCredentials)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.CreateGiteaCredentialsParams) error); ok {
		r1 = rf(ctx, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateGiteaCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateGiteaCredentials'
type Store_CreateGiteaCredentials_Call struct {
	*mock.Call
}

// CreateGiteaCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - param params.CreateGiteaCredentialsParams
func (_e *Store_Expecter) CreateGiteaCredentials(ctx interface{}, param interface{}) *Store_CreateGiteaCredentials_Call {
	return &Store_CreateGiteaCredentials_Call{Call: _e.mock.On("CreateGiteaCredentials", ctx, param)}
}

func (_c *Store_CreateGiteaCredentials_Call) Run(run func(ctx context.Context, param params.CreateGiteaCredentialsParams)) *Store_CreateGiteaCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.CreateGiteaCredentialsParams))
	})
	return _c
}

func (_c *Store_CreateGiteaCredentials_Call) Return(gtCreds params.ForgeCredentials, err error) *Store_CreateGiteaCredentials_Call {
	_c.Call.Return(gtCreds, err)
	return _c
}

func (_c *Store_CreateGiteaCredentials_Call) RunAndReturn(run func(context.Context, params.CreateGiteaCredentialsParams) (params.ForgeCredentials, error)) *Store_CreateGiteaCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// CreateGiteaEndpoint provides a mock function with given fields: _a0, param
func (_m *Store) CreateGiteaEndpoint(_a0 context.Context, param params.CreateGiteaEndpointParams) (params.ForgeEndpoint, error) {
	ret := _m.Called(_a0, param)

	if len(ret) == 0 {
		panic("no return value specified for CreateGiteaEndpoint")
	}

	var r0 params.ForgeEndpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateGiteaEndpointParams) (params.ForgeEndpoint, error)); ok {
		return rf(_a0, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateGiteaEndpointParams) params.ForgeEndpoint); ok {
		r0 = rf(_a0, param)
	} else {
		r0 = ret.Get(0).(params.ForgeEndpoint)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.CreateGiteaEndpointParams) error); ok {
		r1 = rf(_a0, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateGiteaEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateGiteaEndpoint'
type Store_CreateGiteaEndpoint_Call struct {
	*mock.Call
}

// CreateGiteaEndpoint is a helper method to define mock.On call
//   - _a0 context.Context
//   - param params.CreateGiteaEndpointParams
func (_e *Store_Expecter) CreateGiteaEndpoint(_a0 interface{}, param interface{}) *Store_CreateGiteaEndpoint_Call {
	return &Store_CreateGiteaEndpoint_Call{Call: _e.mock.On("CreateGiteaEndpoint", _a0, param)}
}

func (_c *Store_CreateGiteaEndpoint_Call) Run(run func(_a0 context.Context, param params.CreateGiteaEndpointParams)) *Store_CreateGiteaEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.CreateGiteaEndpointParams))
	})
	return _c
}

func (_c *Store_CreateGiteaEndpoint_Call) Return(ghEndpoint params.ForgeEndpoint, err error) *Store_CreateGiteaEndpoint_Call {
	_c.Call.Return(ghEndpoint, err)
	return _c
}

func (_c *Store_CreateGiteaEndpoint_Call) RunAndReturn(run func(context.Context, params.CreateGiteaEndpointParams) (params.ForgeEndpoint, error)) *Store_CreateGiteaEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// CreateGithubCredentials provides a mock function with given fields: ctx, param
func (_m *Store) CreateGithubCredentials(ctx context.Context, param params.CreateGithubCredentialsParams) (params.ForgeCredentials, error) {
	ret := _m.Called(ctx, param)

	if len(ret) == 0 {
		panic("no return value specified for CreateGithubCredentials")
	}

	var r0 params.ForgeCredentials
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateGithubCredentialsParams) (params.ForgeCredentials, error)); ok {
		return rf(ctx, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateGithubCredentialsParams) params.ForgeCredentials); ok {
		r0 = rf(ctx, param)
	} else {
		r0 = ret.Get(0).(params.ForgeCredentials)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.CreateGithubCredentialsParams) error); ok {
		r1 = rf(ctx, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateGithubCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateGithubCredentials'
type Store_CreateGithubCredentials_Call struct {
	*mock.Call
}

// CreateGithubCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - param params.CreateGithubCredentialsParams
func (_e *Store_Expecter) CreateGithubCredentials(ctx interface{}, param interface{}) *Store_CreateGithubCredentials_Call {
	return &Store_CreateGithubCredentials_Call{Call: _e.mock.On("CreateGithubCredentials", ctx, param)}
}

func (_c *Store_CreateGithubCredentials_Call) Run(run func(ctx context.Context, param params.CreateGithubCredentialsParams)) *Store_CreateGithubCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.CreateGithubCredentialsParams))
	})
	return _c
}

func (_c *Store_CreateGithubCredentials_Call) Return(_a0 params.ForgeCredentials, _a1 error) *Store_CreateGithubCredentials_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_CreateGithubCredentials_Call) RunAndReturn(run func(context.Context, params.CreateGithubCredentialsParams) (params.ForgeCredentials, error)) *Store_CreateGithubCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// CreateGithubEndpoint provides a mock function with given fields: ctx, param
func (_m *Store) CreateGithubEndpoint(ctx context.Context, param params.CreateGithubEndpointParams) (params.ForgeEndpoint, error) {
	ret := _m.Called(ctx, param)

	if len(ret) == 0 {
		panic("no return value specified for CreateGithubEndpoint")
	}

	var r0 params.ForgeEndpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateGithubEndpointParams) (params.ForgeEndpoint, error)); ok {
		return rf(ctx, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateGithubEndpointParams) params.ForgeEndpoint); ok {
		r0 = rf(ctx, param)
	} else {
		r0 = ret.Get(0).(params.ForgeEndpoint)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.CreateGithubEndpointParams) error); ok {
		r1 = rf(ctx, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateGithubEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateGithubEndpoint'
type Store_CreateGithubEndpoint_Call struct {
	*mock.Call
}

// CreateGithubEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - param params.CreateGithubEndpointParams
func (_e *Store_Expecter) CreateGithubEndpoint(ctx interface{}, param interface{}) *Store_CreateGithubEndpoint_Call {
	return &Store_CreateGithubEndpoint_Call{Call: _e.mock.On("CreateGithubEndpoint", ctx, param)}
}

func (_c *Store_CreateGithubEndpoint_Call) Run(run func(ctx context.Context, param params.CreateGithubEndpointParams)) *Store_CreateGithubEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.CreateGithubEndpointParams))
	})
	return _c
}

func (_c *Store_CreateGithubEndpoint_Call) Return(_a0 params.ForgeEndpoint, _a1 error) *Store_CreateGithubEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_CreateGithubEndpoint_Call) RunAndReturn(run func(context.Context, params.CreateGithubEndpointParams) (params.ForgeEndpoint, error)) *Store_CreateGithubEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// CreateInstance provides a mock function with given fields: ctx, poolID, param
func (_m *Store) CreateInstance(ctx context.Context, poolID string, param params.CreateInstanceParams) (params.Instance, error) {
	ret := _m.Called(ctx, poolID, param)

	if len(ret) == 0 {
		panic("no return value specified for CreateInstance")
	}

	var r0 params.Instance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.CreateInstanceParams) (params.Instance, error)); ok {
		return rf(ctx, poolID, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, params.CreateInstanceParams) params.Instance); ok {
		r0 = rf(ctx, poolID, param)
	} else {
		r0 = ret.Get(0).(params.Instance)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, params.CreateInstanceParams) error); ok {
		r1 = rf(ctx, poolID, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInstance'
type Store_CreateInstance_Call struct {
	*mock.Call
}

// CreateInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - poolID string
//   - param params.CreateInstanceParams
func (_e *Store_Expecter) CreateInstance(ctx interface{}, poolID interface{}, param interface{}) *Store_CreateInstance_Call {
	return &Store_CreateInstance_Call{Call: _e.mock.On("CreateInstance", ctx, poolID, param)}
}

func (_c *Store_CreateInstance_Call) Run(run func(ctx context.Context, poolID string, param params.CreateInstanceParams)) *Store_CreateInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.CreateInstanceParams))
	})
	return _c
}

func (_c *Store_CreateInstance_Call) Return(_a0 params.Instance, _a1 error) *Store_CreateInstance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_CreateInstance_Call) RunAndReturn(run func(context.Context, string, params.CreateInstanceParams) (params.Instance, error)) *Store_CreateInstance_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateJob provides a mock function with given fields: ctx, job
func (_m *Store) CreateOrUpdateJob(ctx context.Context, job params.Job) (params.Job, error) {
	ret := _m.Called(ctx, job)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateJob")
	}

	var r0 params.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.Job) (params.Job, error)); ok {
		return rf(ctx, job)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.Job) params.Job); ok {
		r0 = rf(ctx, job)
	} else {
		r0 = ret.Get(0).(params.Job)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.Job) error); ok {
		r1 = rf(ctx, job)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateOrUpdateJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateJob'
type Store_CreateOrUpdateJob_Call struct {
	*mock.Call
}

// CreateOrUpdateJob is a helper method to define mock.On call
//   - ctx context.Context
//   - job params.Job
func (_e *Store_Expecter) CreateOrUpdateJob(ctx interface{}, job interface{}) *Store_CreateOrUpdateJob_Call {
	return &Store_CreateOrUpdateJob_Call{Call: _e.mock.On("CreateOrUpdateJob", ctx, job)}
}

func (_c *Store_CreateOrUpdateJob_Call) Run(run func(ctx context.Context, job params.Job)) *Store_CreateOrUpdateJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.Job))
	})
	return _c
}

func (_c *Store_CreateOrUpdateJob_Call) Return(_a0 params.Job, _a1 error) *Store_CreateOrUpdateJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_CreateOrUpdateJob_Call) RunAndReturn(run func(context.Context, params.Job) (params.Job, error)) *Store_CreateOrUpdateJob_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrganization provides a mock function with given fields: ctx, name, credentials, webhookSecret, poolBalancerType, agentMode
func (_m *Store) CreateOrganization(ctx context.Context, name string, credentials params.ForgeCredentials, webhookSecret string, poolBalancerType params.PoolBalancerType, agentMode bool) (params.Organization, error) {
	ret := _m.Called(ctx, name, credentials, webhookSecret, poolBalancerType, agentMode)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrganization")
	}

	var r0 params.Organization
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) (params.Organization, error)); ok {
		return rf(ctx, name, credentials, webhookSecret, poolBalancerType, agentMode)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) params.Organization); ok {
		r0 = rf(ctx, name, credentials, webhookSecret, poolBalancerType, agentMode)
	} else {
		r0 = ret.Get(0).(params.Organization)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) error); ok {
		r1 = rf(ctx, name, credentials, webhookSecret, poolBalancerType, agentMode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateOrganization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrganization'
type Store_CreateOrganization_Call struct {
	*mock.Call
}

// CreateOrganization is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - credentials params.ForgeCredentials
//   - webhookSecret string
//   - poolBalancerType params.PoolBalancerType
//   - agentMode bool
func (_e *Store_Expecter) CreateOrganization(ctx interface{}, name interface{}, credentials interface{}, webhookSecret interface{}, poolBalancerType interface{}, agentMode interface{}) *Store_CreateOrganization_Call {
	return &Store_CreateOrganization_Call{Call: _e.mock.On("CreateOrganization", ctx, name, credentials, webhookSecret, poolBalancerType, agentMode)}
}

func (_c *Store_CreateOrganization_Call) Run(run func(ctx context.Context, name string, credentials params.ForgeCredentials, webhookSecret string, poolBalancerType params.PoolBalancerType, agentMode bool)) *Store_CreateOrganization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.ForgeCredentials), args[3].(string), args[4].(params.PoolBalancerType), args[5].(bool))
	})
	return _c
}

func (_c *Store_CreateOrganization_Call) Return(org params.Organization, err error) *Store_CreateOrganization_Call {
	_c.Call.Return(org, err)
	return _c
}

func (_c *Store_CreateOrganization_Call) RunAndReturn(run func(context.Context, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) (params.Organization, error)) *Store_CreateOrganization_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRepository provides a mock function with given fields: ctx, owner, name, credentials, webhookSecret, poolBalancerType, agentMode
func (_m *Store) CreateRepository(ctx context.Context, owner string, name string, credentials params.ForgeCredentials, webhookSecret string, poolBalancerType params.PoolBalancerType, agentMode bool) (params.Repository, error) {
	ret := _m.Called(ctx, owner, name, credentials, webhookSecret, poolBalancerType, agentMode)

	if len(ret) == 0 {
		panic("no return value specified for CreateRepository")
	}

	var r0 params.Repository
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) (params.Repository, error)); ok {
		return rf(ctx, owner, name, credentials, webhookSecret, poolBalancerType, agentMode)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) params.Repository); ok {
		r0 = rf(ctx, owner, name, credentials, webhookSecret, poolBalancerType, agentMode)
	} else {
		r0 = ret.Get(0).(params.Repository)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) error); ok {
		r1 = rf(ctx, owner, name, credentials, webhookSecret, poolBalancerType, agentMode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRepository'
type Store_CreateRepository_Call struct {
	*mock.Call
}

// CreateRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - name string
//   - credentials params.ForgeCredentials
//   - webhookSecret string
//   - poolBalancerType params.PoolBalancerType
//   - agentMode bool
func (_e *Store_Expecter) CreateRepository(ctx interface{}, owner interface{}, name interface{}, credentials interface{}, webhookSecret interface{}, poolBalancerType interface{}, agentMode interface{}) *Store_CreateRepository_Call {
	return &Store_CreateRepository_Call{Call: _e.mock.On("CreateRepository", ctx, owner, name, credentials, webhookSecret, poolBalancerType, agentMode)}
}

func (_c *Store_CreateRepository_Call) Run(run func(ctx context.Context, owner string, name string, credentials params.ForgeCredentials, webhookSecret string, poolBalancerType params.PoolBalancerType, agentMode bool)) *Store_CreateRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(params.ForgeCredentials), args[4].(string), args[5].(params.PoolBalancerType), args[6].(bool))
	})
	return _c
}

func (_c *Store_CreateRepository_Call) Return(param params.Repository, err error) *Store_CreateRepository_Call {
	_c.Call.Return(param, err)
	return _c
}

func (_c *Store_CreateRepository_Call) RunAndReturn(run func(context.Context, string, string, params.ForgeCredentials, string, params.PoolBalancerType, bool) (params.Repository, error)) *Store_CreateRepository_Call {
	_c.Call.Return(run)
	return _c
}

// CreateScaleSetInstance provides a mock function with given fields: _a0, scaleSetID, param
func (_m *Store) CreateScaleSetInstance(_a0 context.Context, scaleSetID uint, param params.CreateInstanceParams) (params.Instance, error) {
	ret := _m.Called(_a0, scaleSetID, param)

	if len(ret) == 0 {
		panic("no return value specified for CreateScaleSetInstance")
	}

	var r0 params.Instance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, params.CreateInstanceParams) (params.Instance, error)); ok {
		return rf(_a0, scaleSetID, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, params.CreateInstanceParams) params.Instance); ok {
		r0 = rf(_a0, scaleSetID, param)
	} else {
		r0 = ret.Get(0).(params.Instance)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, params.CreateInstanceParams) error); ok {
		r1 = rf(_a0, scaleSetID, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateScaleSetInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateScaleSetInstance'
type Store_CreateScaleSetInstance_Call struct {
	*mock.Call
}

// CreateScaleSetInstance is a helper method to define mock.On call
//   - _a0 context.Context
//   - scaleSetID uint
//   - param params.CreateInstanceParams
func (_e *Store_Expecter) CreateScaleSetInstance(_a0 interface{}, scaleSetID interface{}, param interface{}) *Store_CreateScaleSetInstance_Call {
	return &Store_CreateScaleSetInstance_Call{Call: _e.mock.On("CreateScaleSetInstance", _a0, scaleSetID, param)}
}

func (_c *Store_CreateScaleSetInstance_Call) Run(run func(_a0 context.Context, scaleSetID uint, param params.CreateInstanceParams)) *Store_CreateScaleSetInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(params.CreateInstanceParams))
	})
	return _c
}

func (_c *Store_CreateScaleSetInstance_Call) Return(instance params.Instance, err error) *Store_CreateScaleSetInstance_Call {
	_c.Call.Return(instance, err)
	return _c
}

func (_c *Store_CreateScaleSetInstance_Call) RunAndReturn(run func(context.Context, uint, params.CreateInstanceParams) (params.Instance, error)) *Store_CreateScaleSetInstance_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTemplate provides a mock function with given fields: ctx, param
func (_m *Store) CreateTemplate(ctx context.Context, param params.CreateTemplateParams) (params.Template, error) {
	ret := _m.Called(ctx, param)

	if len(ret) == 0 {
		panic("no return value specified for CreateTemplate")
	}

	var r0 params.Template
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateTemplateParams) (params.Template, error)); ok {
		return rf(ctx, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.CreateTemplateParams) params.Template); ok {
		r0 = rf(ctx, param)
	} else {
		r0 = ret.Get(0).(params.Template)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.CreateTemplateParams) error); ok {
		r1 = rf(ctx, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTemplate'
type Store_CreateTemplate_Call struct {
	*mock.Call
}

// CreateTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - param params.CreateTemplateParams
func (_e *Store_Expecter) CreateTemplate(ctx interface{}, param interface{}) *Store_CreateTemplate_Call {
	return &Store_CreateTemplate_Call{Call: _e.mock.On("CreateTemplate", ctx, param)}
}

func (_c *Store_CreateTemplate_Call) Run(run func(ctx context.Context, param params.CreateTemplateParams)) *Store_CreateTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.CreateTemplateParams))
	})
	return _c
}

func (_c *Store_CreateTemplate_Call) Return(template params.Template, err error) *Store_CreateTemplate_Call {
	_c.Call.Return(template, err)
	return _c
}

func (_c *Store_CreateTemplate_Call) RunAndReturn(run func(context.Context, params.CreateTemplateParams) (params.Template, error)) *Store_CreateTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: ctx, user
func (_m *Store) CreateUser(ctx context.Context, user params.NewUserParams) (params.User, error) {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 params.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.NewUserParams) (params.User, error)); ok {
		return rf(ctx, user)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.NewUserParams) params.User); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Get(0).(params.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.NewUserParams) error); ok {
		r1 = rf(ctx, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type Store_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user params.NewUserParams
func (_e *Store_Expecter) CreateUser(ctx interface{}, user interface{}) *Store_CreateUser_Call {
	return &Store_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, user)}
}

func (_c *Store_CreateUser_Call) Run(run func(ctx context.Context, user params.NewUserParams)) *Store_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.NewUserParams))
	})
	return _c
}

func (_c *Store_CreateUser_Call) Return(_a0 params.User, _a1 error) *Store_CreateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_CreateUser_Call) RunAndReturn(run func(context.Context, params.NewUserParams) (params.User, error)) *Store_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCompletedJobs provides a mock function with given fields: ctx
func (_m *Store) DeleteCompletedJobs(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCompletedJobs")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteCompletedJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCompletedJobs'
type Store_DeleteCompletedJobs_Call struct {
	*mock.Call
}

// DeleteCompletedJobs is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Store_Expecter) DeleteCompletedJobs(ctx interface{}) *Store_DeleteCompletedJobs_Call {
	return &Store_DeleteCompletedJobs_Call{Call: _e.mock.On("DeleteCompletedJobs", ctx)}
}

func (_c *Store_DeleteCompletedJobs_Call) Run(run func(ctx context.Context)) *Store_DeleteCompletedJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_DeleteCompletedJobs_Call) Return(_a0 error) *Store_DeleteCompletedJobs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteCompletedJobs_Call) RunAndReturn(run func(context.Context) error) *Store_DeleteCompletedJobs_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEnterprise provides a mock function with given fields: ctx, enterpriseID
func (_m *Store) DeleteEnterprise(ctx context.Context, enterpriseID string) error {
	ret := _m.Called(ctx, enterpriseID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEnterprise")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, enterpriseID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteEnterprise_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEnterprise'
type Store_DeleteEnterprise_Call struct {
	*mock.Call
}

// DeleteEnterprise is a helper method to define mock.On call
//   - ctx context.Context
//   - enterpriseID string
func (_e *Store_Expecter) DeleteEnterprise(ctx interface{}, enterpriseID interface{}) *Store_DeleteEnterprise_Call {
	return &Store_DeleteEnterprise_Call{Call: _e.mock.On("DeleteEnterprise", ctx, enterpriseID)}
}

func (_c *Store_DeleteEnterprise_Call) Run(run func(ctx context.Context, enterpriseID string)) *Store_DeleteEnterprise_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_DeleteEnterprise_Call) Return(_a0 error) *Store_DeleteEnterprise_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteEnterprise_Call) RunAndReturn(run func(context.Context, string) error) *Store_DeleteEnterprise_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEntityPool provides a mock function with given fields: ctx, entity, poolID
func (_m *Store) DeleteEntityPool(ctx context.Context, entity params.ForgeEntity, poolID string) error {
	ret := _m.Called(ctx, entity, poolID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEntityPool")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, string) error); ok {
		r0 = rf(ctx, entity, poolID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteEntityPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEntityPool'
type Store_DeleteEntityPool_Call struct {
	*mock.Call
}

// DeleteEntityPool is a helper method to define mock.On call
//   - ctx context.Context
//   - entity params.ForgeEntity
//   - poolID string
func (_e *Store_Expecter) DeleteEntityPool(ctx interface{}, entity interface{}, poolID interface{}) *Store_DeleteEntityPool_Call {
	return &Store_DeleteEntityPool_Call{Call: _e.mock.On("DeleteEntityPool", ctx, entity, poolID)}
}

func (_c *Store_DeleteEntityPool_Call) Run(run func(ctx context.Context, entity params.ForgeEntity, poolID string)) *Store_DeleteEntityPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntity), args[2].(string))
	})
	return _c
}

func (_c *Store_DeleteEntityPool_Call) Return(_a0 error) *Store_DeleteEntityPool_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteEntityPool_Call) RunAndReturn(run func(context.Context, params.ForgeEntity, string) error) *Store_DeleteEntityPool_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFileObject provides a mock function with given fields: ctx, objID
func (_m *Store) DeleteFileObject(ctx context.Context, objID uint) error {
	ret := _m.Called(ctx, objID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFileObject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) error); ok {
		r0 = rf(ctx, objID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteFileObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFileObject'
type Store_DeleteFileObject_Call struct {
	*mock.Call
}

// DeleteFileObject is a helper method to define mock.On call
//   - ctx context.Context
//   - objID uint
func (_e *Store_Expecter) DeleteFileObject(ctx interface{}, objID interface{}) *Store_DeleteFileObject_Call {
	return &Store_DeleteFileObject_Call{Call: _e.mock.On("DeleteFileObject", ctx, objID)}
}

func (_c *Store_DeleteFileObject_Call) Run(run func(ctx context.Context, objID uint)) *Store_DeleteFileObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *Store_DeleteFileObject_Call) Return(_a0 error) *Store_DeleteFileObject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteFileObject_Call) RunAndReturn(run func(context.Context, uint) error) *Store_DeleteFileObject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGiteaCredentials provides a mock function with given fields: ctx, id
func (_m *Store) DeleteGiteaCredentials(ctx context.Context, id uint) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGiteaCredentials")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteGiteaCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGiteaCredentials'
type Store_DeleteGiteaCredentials_Call struct {
	*mock.Call
}

// DeleteGiteaCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint
func (_e *Store_Expecter) DeleteGiteaCredentials(ctx interface{}, id interface{}) *Store_DeleteGiteaCredentials_Call {
	return &Store_DeleteGiteaCredentials_Call{Call: _e.mock.On("DeleteGiteaCredentials", ctx, id)}
}

func (_c *Store_DeleteGiteaCredentials_Call) Run(run func(ctx context.Context, id uint)) *Store_DeleteGiteaCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *Store_DeleteGiteaCredentials_Call) Return(err error) *Store_DeleteGiteaCredentials_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Store_DeleteGiteaCredentials_Call) RunAndReturn(run func(context.Context, uint) error) *Store_DeleteGiteaCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGiteaEndpoint provides a mock function with given fields: _a0, name
func (_m *Store) DeleteGiteaEndpoint(_a0 context.Context, name string) error {
	ret := _m.Called(_a0, name)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGiteaEndpoint")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(_a0, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteGiteaEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGiteaEndpoint'
type Store_DeleteGiteaEndpoint_Call struct {
	*mock.Call
}

// DeleteGiteaEndpoint is a helper method to define mock.On call
//   - _a0 context.Context
//   - name string
func (_e *Store_Expecter) DeleteGiteaEndpoint(_a0 interface{}, name interface{}) *Store_DeleteGiteaEndpoint_Call {
	return &Store_DeleteGiteaEndpoint_Call{Call: _e.mock.On("DeleteGiteaEndpoint", _a0, name)}
}

func (_c *Store_DeleteGiteaEndpoint_Call) Run(run func(_a0 context.Context, name string)) *Store_DeleteGiteaEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_DeleteGiteaEndpoint_Call) Return(err error) *Store_DeleteGiteaEndpoint_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Store_DeleteGiteaEndpoint_Call) RunAndReturn(run func(context.Context, string) error) *Store_DeleteGiteaEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGithubCredentials provides a mock function with given fields: ctx, id
func (_m *Store) DeleteGithubCredentials(ctx context.Context, id uint) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGithubCredentials")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteGithubCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGithubCredentials'
type Store_DeleteGithubCredentials_Call struct {
	*mock.Call
}

// DeleteGithubCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint
func (_e *Store_Expecter) DeleteGithubCredentials(ctx interface{}, id interface{}) *Store_DeleteGithubCredentials_Call {
	return &Store_DeleteGithubCredentials_Call{Call: _e.mock.On("DeleteGithubCredentials", ctx, id)}
}

func (_c *Store_DeleteGithubCredentials_Call) Run(run func(ctx context.Context, id uint)) *Store_DeleteGithubCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *Store_DeleteGithubCredentials_Call) Return(_a0 error) *Store_DeleteGithubCredentials_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteGithubCredentials_Call) RunAndReturn(run func(context.Context, uint) error) *Store_DeleteGithubCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGithubEndpoint provides a mock function with given fields: ctx, name
func (_m *Store) DeleteGithubEndpoint(ctx context.Context, name string) error {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGithubEndpoint")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteGithubEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGithubEndpoint'
type Store_DeleteGithubEndpoint_Call struct {
	*mock.Call
}

// DeleteGithubEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Store_Expecter) DeleteGithubEndpoint(ctx interface{}, name interface{}) *Store_DeleteGithubEndpoint_Call {
	return &Store_DeleteGithubEndpoint_Call{Call: _e.mock.On("DeleteGithubEndpoint", ctx, name)}
}

func (_c *Store_DeleteGithubEndpoint_Call) Run(run func(ctx context.Context, name string)) *Store_DeleteGithubEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_DeleteGithubEndpoint_Call) Return(_a0 error) *Store_DeleteGithubEndpoint_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteGithubEndpoint_Call) RunAndReturn(run func(context.Context, string) error) *Store_DeleteGithubEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteInstance provides a mock function with given fields: ctx, poolID, instanceNameOrID
func (_m *Store) DeleteInstance(ctx context.Context, poolID string, instanceNameOrID string) error {
	ret := _m.Called(ctx, poolID, instanceNameOrID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInstance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, poolID, instanceNameOrID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteInstance'
type Store_DeleteInstance_Call struct {
	*mock.Call
}

// DeleteInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - poolID string
//   - instanceNameOrID string
func (_e *Store_Expecter) DeleteInstance(ctx interface{}, poolID interface{}, instanceNameOrID interface{}) *Store_DeleteInstance_Call {
	return &Store_DeleteInstance_Call{Call: _e.mock.On("DeleteInstance", ctx, poolID, instanceNameOrID)}
}

func (_c *Store_DeleteInstance_Call) Run(run func(ctx context.Context, poolID string, instanceNameOrID string)) *Store_DeleteInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Store_DeleteInstance_Call) Return(_a0 error) *Store_DeleteInstance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteInstance_Call) RunAndReturn(run func(context.Context, string, string) error) *Store_DeleteInstance_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteInstanceByName provides a mock function with given fields: ctx, instanceName
func (_m *Store) DeleteInstanceByName(ctx context.Context, instanceName string) error {
	ret := _m.Called(ctx, instanceName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInstanceByName")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, instanceName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteInstanceByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteInstanceByName'
type Store_DeleteInstanceByName_Call struct {
	*mock.Call
}

// DeleteInstanceByName is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceName string
func (_e *Store_Expecter) DeleteInstanceByName(ctx interface{}, instanceName interface{}) *Store_DeleteInstanceByName_Call {
	return &Store_DeleteInstanceByName_Call{Call: _e.mock.On("DeleteInstanceByName", ctx, instanceName)}
}

func (_c *Store_DeleteInstanceByName_Call) Run(run func(ctx context.Context, instanceName string)) *Store_DeleteInstanceByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_DeleteInstanceByName_Call) Return(_a0 error) *Store_DeleteInstanceByName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteInstanceByName_Call) RunAndReturn(run func(context.Context, string) error) *Store_DeleteInstanceByName_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteJob provides a mock function with given fields: ctx, jobID
func (_m *Store) DeleteJob(ctx context.Context, jobID int64) error {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, jobID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteJob'
type Store_DeleteJob_Call struct {
	*mock.Call
}

// DeleteJob is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID int64
func (_e *Store_Expecter) DeleteJob(ctx interface{}, jobID interface{}) *Store_DeleteJob_Call {
	return &Store_DeleteJob_Call{Call: _e.mock.On("DeleteJob", ctx, jobID)}
}

func (_c *Store_DeleteJob_Call) Run(run func(ctx context.Context, jobID int64)) *Store_DeleteJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *Store_DeleteJob_Call) Return(_a0 error) *Store_DeleteJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteJob_Call) RunAndReturn(run func(context.Context, int64) error) *Store_DeleteJob_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteOrganization provides a mock function with given fields: ctx, orgID
func (_m *Store) DeleteOrganization(ctx context.Context, orgID string) error {
	ret := _m.Called(ctx, orgID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOrganization")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, orgID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteOrganization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteOrganization'
type Store_DeleteOrganization_Call struct {
	*mock.Call
}

// DeleteOrganization is a helper method to define mock.On call
//   - ctx context.Context
//   - orgID string
func (_e *Store_Expecter) DeleteOrganization(ctx interface{}, orgID interface{}) *Store_DeleteOrganization_Call {
	return &Store_DeleteOrganization_Call{Call: _e.mock.On("DeleteOrganization", ctx, orgID)}
}

func (_c *Store_DeleteOrganization_Call) Run(run func(ctx context.Context, orgID string)) *Store_DeleteOrganization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_DeleteOrganization_Call) Return(_a0 error) *Store_DeleteOrganization_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteOrganization_Call) RunAndReturn(run func(context.Context, string) error) *Store_DeleteOrganization_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePoolByID provides a mock function with given fields: ctx, poolID
func (_m *Store) DeletePoolByID(ctx context.Context, poolID string) error {
	ret := _m.Called(ctx, poolID)

	if len(ret) == 0 {
		panic("no return value specified for DeletePoolByID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, poolID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeletePoolByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePoolByID'
type Store_DeletePoolByID_Call struct {
	*mock.Call
}

// DeletePoolByID is a helper method to define mock.On call
//   - ctx context.Context
//   - poolID string
func (_e *Store_Expecter) DeletePoolByID(ctx interface{}, poolID interface{}) *Store_DeletePoolByID_Call {
	return &Store_DeletePoolByID_Call{Call: _e.mock.On("DeletePoolByID", ctx, poolID)}
}

func (_c *Store_DeletePoolByID_Call) Run(run func(ctx context.Context, poolID string)) *Store_DeletePoolByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_DeletePoolByID_Call) Return(_a0 error) *Store_DeletePoolByID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeletePoolByID_Call) RunAndReturn(run func(context.Context, string) error) *Store_DeletePoolByID_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRepository provides a mock function with given fields: ctx, repoID
func (_m *Store) DeleteRepository(ctx context.Context, repoID string) error {
	ret := _m.Called(ctx, repoID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepository")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, repoID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRepository'
type Store_DeleteRepository_Call struct {
	*mock.Call
}

// DeleteRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - repoID string
func (_e *Store_Expecter) DeleteRepository(ctx interface{}, repoID interface{}) *Store_DeleteRepository_Call {
	return &Store_DeleteRepository_Call{Call: _e.mock.On("DeleteRepository", ctx, repoID)}
}

func (_c *Store_DeleteRepository_Call) Run(run func(ctx context.Context, repoID string)) *Store_DeleteRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_DeleteRepository_Call) Return(_a0 error) *Store_DeleteRepository_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteRepository_Call) RunAndReturn(run func(context.Context, string) error) *Store_DeleteRepository_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteScaleSetByID provides a mock function with given fields: ctx, scaleSetID
func (_m *Store) DeleteScaleSetByID(ctx context.Context, scaleSetID uint) error {
	ret := _m.Called(ctx, scaleSetID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteScaleSetByID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) error); ok {
		r0 = rf(ctx, scaleSetID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteScaleSetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteScaleSetByID'
type Store_DeleteScaleSetByID_Call struct {
	*mock.Call
}

// DeleteScaleSetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - scaleSetID uint
func (_e *Store_Expecter) DeleteScaleSetByID(ctx interface{}, scaleSetID interface{}) *Store_DeleteScaleSetByID_Call {
	return &Store_DeleteScaleSetByID_Call{Call: _e.mock.On("DeleteScaleSetByID", ctx, scaleSetID)}
}

func (_c *Store_DeleteScaleSetByID_Call) Run(run func(ctx context.Context, scaleSetID uint)) *Store_DeleteScaleSetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *Store_DeleteScaleSetByID_Call) Return(err error) *Store_DeleteScaleSetByID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Store_DeleteScaleSetByID_Call) RunAndReturn(run func(context.Context, uint) error) *Store_DeleteScaleSetByID_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTemplate provides a mock function with given fields: ctx, id
func (_m *Store) DeleteTemplate(ctx context.Context, id uint) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTemplate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTemplate'
type Store_DeleteTemplate_Call struct {
	*mock.Call
}

// DeleteTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint
func (_e *Store_Expecter) DeleteTemplate(ctx interface{}, id interface{}) *Store_DeleteTemplate_Call {
	return &Store_DeleteTemplate_Call{Call: _e.mock.On("DeleteTemplate", ctx, id)}
}

func (_c *Store_DeleteTemplate_Call) Run(run func(ctx context.Context, id uint)) *Store_DeleteTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *Store_DeleteTemplate_Call) Return(err error) *Store_DeleteTemplate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Store_DeleteTemplate_Call) RunAndReturn(run func(context.Context, uint) error) *Store_DeleteTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// FindPoolsMatchingAllTags provides a mock function with given fields: ctx, entityType, entityID, tags
func (_m *Store) FindPoolsMatchingAllTags(ctx context.Context, entityType params.ForgeEntityType, entityID string, tags []string) ([]params.Pool, error) {
	ret := _m.Called(ctx, entityType, entityID, tags)

	if len(ret) == 0 {
		panic("no return value specified for FindPoolsMatchingAllTags")
	}

	var r0 []params.Pool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntityType, string, []string) ([]params.Pool, error)); ok {
		return rf(ctx, entityType, entityID, tags)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntityType, string, []string) []params.Pool); ok {
		r0 = rf(ctx, entityType, entityID, tags)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Pool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.ForgeEntityType, string, []string) error); ok {
		r1 = rf(ctx, entityType, entityID, tags)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_FindPoolsMatchingAllTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindPoolsMatchingAllTags'
type Store_FindPoolsMatchingAllTags_Call struct {
	*mock.Call
}

// FindPoolsMatchingAllTags is a helper method to define mock.On call
//   - ctx context.Context
//   - entityType params.ForgeEntityType
//   - entityID string
//   - tags []string
func (_e *Store_Expecter) FindPoolsMatchingAllTags(ctx interface{}, entityType interface{}, entityID interface{}, tags interface{}) *Store_FindPoolsMatchingAllTags_Call {
	return &Store_FindPoolsMatchingAllTags_Call{Call: _e.mock.On("FindPoolsMatchingAllTags", ctx, entityType, entityID, tags)}
}

func (_c *Store_FindPoolsMatchingAllTags_Call) Run(run func(ctx context.Context, entityType params.ForgeEntityType, entityID string, tags []string)) *Store_FindPoolsMatchingAllTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntityType), args[2].(string), args[3].([]string))
	})
	return _c
}

func (_c *Store_FindPoolsMatchingAllTags_Call) Return(_a0 []params.Pool, _a1 error) *Store_FindPoolsMatchingAllTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_FindPoolsMatchingAllTags_Call) RunAndReturn(run func(context.Context, params.ForgeEntityType, string, []string) ([]params.Pool, error)) *Store_FindPoolsMatchingAllTags_Call {
	_c.Call.Return(run)
	return _c
}

// GetAdminUser provides a mock function with given fields: ctx
func (_m *Store) GetAdminUser(ctx context.Context) (params.User, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAdminUser")
	}

	var r0 params.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (params.User, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) params.User); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(params.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetAdminUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAdminUser'
type Store_GetAdminUser_Call struct {
	*mock.Call
}

// GetAdminUser is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Store_Expecter) GetAdminUser(ctx interface{}) *Store_GetAdminUser_Call {
	return &Store_GetAdminUser_Call{Call: _e.mock.On("GetAdminUser", ctx)}
}

func (_c *Store_GetAdminUser_Call) Run(run func(ctx context.Context)) *Store_GetAdminUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_GetAdminUser_Call) Return(_a0 params.User, _a1 error) *Store_GetAdminUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetAdminUser_Call) RunAndReturn(run func(context.Context) (params.User, error)) *Store_GetAdminUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetEnterprise provides a mock function with given fields: ctx, name, endpointName
func (_m *Store) GetEnterprise(ctx context.Context, name string, endpointName string) (params.Enterprise, error) {
	ret := _m.Called(ctx, name, endpointName)

	if len(ret) == 0 {
		panic("no return value specified for GetEnterprise")
	}

	var r0 params.Enterprise
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (params.Enterprise, error)); ok {
		return rf(ctx, name, endpointName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) params.Enterprise); ok {
		r0 = rf(ctx, name, endpointName)
	} else {
		r0 = ret.Get(0).(params.Enterprise)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, name, endpointName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetEnterprise_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEnterprise'
type Store_GetEnterprise_Call struct {
	*mock.Call
}

// GetEnterprise is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - endpointName string
func (_e *Store_Expecter) GetEnterprise(ctx interface{}, name interface{}, endpointName interface{}) *Store_GetEnterprise_Call {
	return &Store_GetEnterprise_Call{Call: _e.mock.On("GetEnterprise", ctx, name, endpointName)}
}

func (_c *Store_GetEnterprise_Call) Run(run func(ctx context.Context, name string, endpointName string)) *Store_GetEnterprise_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Store_GetEnterprise_Call) Return(_a0 params.Enterprise, _a1 error) *Store_GetEnterprise_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetEnterprise_Call) RunAndReturn(run func(context.Context, string, string) (params.Enterprise, error)) *Store_GetEnterprise_Call {
	_c.Call.Return(run)
	return _c
}

// GetEnterpriseByID provides a mock function with given fields: ctx, enterpriseID
func (_m *Store) GetEnterpriseByID(ctx context.Context, enterpriseID string) (params.Enterprise, error) {
	ret := _m.Called(ctx, enterpriseID)

	if len(ret) == 0 {
		panic("no return value specified for GetEnterpriseByID")
	}

	var r0 params.Enterprise
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (params.Enterprise, error)); ok {
		return rf(ctx, enterpriseID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) params.Enterprise); ok {
		r0 = rf(ctx, enterpriseID)
	} else {
		r0 = ret.Get(0).(params.Enterprise)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, enterpriseID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetEnterpriseByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEnterpriseByID'
type Store_GetEnterpriseByID_Call struct {
	*mock.Call
}

// GetEnterpriseByID is a helper method to define mock.On call
//   - ctx context.Context
//   - enterpriseID string
func (_e *Store_Expecter) GetEnterpriseByID(ctx interface{}, enterpriseID interface{}) *Store_GetEnterpriseByID_Call {
	return &Store_GetEnterpriseByID_Call{Call: _e.mock.On("GetEnterpriseByID", ctx, enterpriseID)}
}

func (_c *Store_GetEnterpriseByID_Call) Run(run func(ctx context.Context, enterpriseID string)) *Store_GetEnterpriseByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_GetEnterpriseByID_Call) Return(_a0 params.Enterprise, _a1 error) *Store_GetEnterpriseByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetEnterpriseByID_Call) RunAndReturn(run func(context.Context, string) (params.Enterprise, error)) *Store_GetEnterpriseByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetEntityPool provides a mock function with given fields: ctx, entity, poolID
func (_m *Store) GetEntityPool(ctx context.Context, entity params.ForgeEntity, poolID string) (params.Pool, error) {
	ret := _m.Called(ctx, entity, poolID)

	if len(ret) == 0 {
		panic("no return value specified for GetEntityPool")
	}

	var r0 params.Pool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, string) (params.Pool, error)); ok {
		return rf(ctx, entity, poolID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, string) params.Pool); ok {
		r0 = rf(ctx, entity, poolID)
	} else {
		r0 = ret.Get(0).(params.Pool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.ForgeEntity, string) error); ok {
		r1 = rf(ctx, entity, poolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetEntityPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEntityPool'
type Store_GetEntityPool_Call struct {
	*mock.Call
}

// GetEntityPool is a helper method to define mock.On call
//   - ctx context.Context
//   - entity params.ForgeEntity
//   - poolID string
func (_e *Store_Expecter) GetEntityPool(ctx interface{}, entity interface{}, poolID interface{}) *Store_GetEntityPool_Call {
	return &Store_GetEntityPool_Call{Call: _e.mock.On("GetEntityPool", ctx, entity, poolID)}
}

func (_c *Store_GetEntityPool_Call) Run(run func(ctx context.Context, entity params.ForgeEntity, poolID string)) *Store_GetEntityPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntity), args[2].(string))
	})
	return _c
}

func (_c *Store_GetEntityPool_Call) Return(_a0 params.Pool, _a1 error) *Store_GetEntityPool_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetEntityPool_Call) RunAndReturn(run func(context.Context, params.ForgeEntity, string) (params.Pool, error)) *Store_GetEntityPool_Call {
	_c.Call.Return(run)
	return _c
}

// GetFileObject provides a mock function with given fields: ctx, objID
func (_m *Store) GetFileObject(ctx context.Context, objID uint) (params.FileObject, error) {
	ret := _m.Called(ctx, objID)

	if len(ret) == 0 {
		panic("no return value specified for GetFileObject")
	}

	var r0 params.FileObject
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) (params.FileObject, error)); ok {
		return rf(ctx, objID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint) params.FileObject); ok {
		r0 = rf(ctx, objID)
	} else {
		r0 = ret.Get(0).(params.FileObject)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = rf(ctx, objID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetFileObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFileObject'
type Store_GetFileObject_Call struct {
	*mock.Call
}

// GetFileObject is a helper method to define mock.On call
//   - ctx context.Context
//   - objID uint
func (_e *Store_Expecter) GetFileObject(ctx interface{}, objID interface{}) *Store_GetFileObject_Call {
	return &Store_GetFileObject_Call{Call: _e.mock.On("GetFileObject", ctx, objID)}
}

func (_c *Store_GetFileObject_Call) Run(run func(ctx context.Context, objID uint)) *Store_GetFileObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *Store_GetFileObject_Call) Return(_a0 params.FileObject, _a1 error) *Store_GetFileObject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetFileObject_Call) RunAndReturn(run func(context.Context, uint) (params.FileObject, error)) *Store_GetFileObject_Call {
	_c.Call.Return(run)
	return _c
}

// GetForgeEntity provides a mock function with given fields: _a0, entityType, entityID
func (_m *Store) GetForgeEntity(_a0 context.Context, entityType params.ForgeEntityType, entityID string) (params.ForgeEntity, error) {
	ret := _m.Called(_a0, entityType, entityID)

	if len(ret) == 0 {
		panic("no return value specified for GetForgeEntity")
	}

	var r0 params.ForgeEntity
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntityType, string) (params.ForgeEntity, error)); ok {
		return rf(_a0, entityType, entityID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntityType, string) params.ForgeEntity); ok {
		r0 = rf(_a0, entityType, entityID)
	} else {
		r0 = ret.Get(0).(params.ForgeEntity)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.ForgeEntityType, string) error); ok {
		r1 = rf(_a0, entityType, entityID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetForgeEntity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetForgeEntity'
type Store_GetForgeEntity_Call struct {
	*mock.Call
}

// GetForgeEntity is a helper method to define mock.On call
//   - _a0 context.Context
//   - entityType params.ForgeEntityType
//   - entityID string
func (_e *Store_Expecter) GetForgeEntity(_a0 interface{}, entityType interface{}, entityID interface{}) *Store_GetForgeEntity_Call {
	return &Store_GetForgeEntity_Call{Call: _e.mock.On("GetForgeEntity", _a0, entityType, entityID)}
}

func (_c *Store_GetForgeEntity_Call) Run(run func(_a0 context.Context, entityType params.ForgeEntityType, entityID string)) *Store_GetForgeEntity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntityType), args[2].(string))
	})
	return _c
}

func (_c *Store_GetForgeEntity_Call) Return(_a0 params.ForgeEntity, _a1 error) *Store_GetForgeEntity_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetForgeEntity_Call) RunAndReturn(run func(context.Context, params.ForgeEntityType, string) (params.ForgeEntity, error)) *Store_GetForgeEntity_Call {
	_c.Call.Return(run)
	return _c
}

// GetGiteaCredentials provides a mock function with given fields: ctx, id, detailed
func (_m *Store) GetGiteaCredentials(ctx context.Context, id uint, detailed bool) (params.ForgeCredentials, error) {
	ret := _m.Called(ctx, id, detailed)

	if len(ret) == 0 {
		panic("no return value specified for GetGiteaCredentials")
	}

	var r0 params.ForgeCredentials
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, bool) (params.ForgeCredentials, error)); ok {
		return rf(ctx, id, detailed)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, bool) params.ForgeCredentials); ok {
		r0 = rf(ctx, id, detailed)
	} else {
		r0 = ret.Get(0).(params.ForgeCredentials)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, bool) error); ok {
		r1 = rf(ctx, id, detailed)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetGiteaCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGiteaCredentials'
type Store_GetGiteaCredentials_Call struct {
	*mock.Call
}

// GetGiteaCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint
//   - detailed bool
func (_e *Store_Expecter) GetGiteaCredentials(ctx interface{}, id interface{}, detailed interface{}) *Store_GetGiteaCredentials_Call {
	return &Store_GetGiteaCredentials_Call{Call: _e.mock.On("GetGiteaCredentials", ctx, id, detailed)}
}

func (_c *Store_GetGiteaCredentials_Call) Run(run func(ctx context.Context, id uint, detailed bool)) *Store_GetGiteaCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(bool))
	})
	return _c
}

func (_c *Store_GetGiteaCredentials_Call) Return(_a0 params.ForgeCredentials, _a1 error) *Store_GetGiteaCredentials_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetGiteaCredentials_Call) RunAndReturn(run func(context.Context, uint, bool) (params.ForgeCredentials, error)) *Store_GetGiteaCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// GetGiteaCredentialsByName provides a mock function with given fields: ctx, name, detailed
func (_m *Store) GetGiteaCredentialsByName(ctx context.Context, name string, detailed bool) (params.ForgeCredentials, error) {
	ret := _m.Called(ctx, name, detailed)

	if len(ret) == 0 {
		panic("no return value specified for GetGiteaCredentialsByName")
	}

	var r0 params.ForgeCredentials
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) (params.ForgeCredentials, error)); ok {
		return rf(ctx, name, detailed)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) params.ForgeCredentials); ok {
		r0 = rf(ctx, name, detailed)
	} else {
		r0 = ret.Get(0).(params.ForgeCredentials)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(ctx, name, detailed)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetGiteaCredentialsByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGiteaCredentialsByName'
type Store_GetGiteaCredentialsByName_Call struct {
	*mock.Call
}

// GetGiteaCredentialsByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - detailed bool
func (_e *Store_Expecter) GetGiteaCredentialsByName(ctx interface{}, name interface{}, detailed interface{}) *Store_GetGiteaCredentialsByName_Call {
	return &Store_GetGiteaCredentialsByName_Call{Call: _e.mock.On("GetGiteaCredentialsByName", ctx, name, detailed)}
}

func (_c *Store_GetGiteaCredentialsByName_Call) Run(run func(ctx context.Context, name string, detailed bool)) *Store_GetGiteaCredentialsByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *Store_GetGiteaCredentialsByName_Call) Return(_a0 params.ForgeCredentials, _a1 error) *Store_GetGiteaCredentialsByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetGiteaCredentialsByName_Call) RunAndReturn(run func(context.Context, string, bool) (params.ForgeCredentials, error)) *Store_GetGiteaCredentialsByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetGiteaEndpoint provides a mock function with given fields: _a0, name
func (_m *Store) GetGiteaEndpoint(_a0 context.Context, name string) (params.ForgeEndpoint, error) {
	ret := _m.Called(_a0, name)

	if len(ret) == 0 {
		panic("no return value specified for GetGiteaEndpoint")
	}

	var r0 params.ForgeEndpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (params.ForgeEndpoint, error)); ok {
		return rf(_a0, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) params.ForgeEndpoint); ok {
		r0 = rf(_a0, name)
	} else {
		r0 = ret.Get(0).(params.ForgeEndpoint)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(_a0, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetGiteaEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGiteaEndpoint'
type Store_GetGiteaEndpoint_Call struct {
	*mock.Call
}

// GetGiteaEndpoint is a helper method to define mock.On call
//   - _a0 context.Context
//   - name string
func (_e *Store_Expecter) GetGiteaEndpoint(_a0 interface{}, name interface{}) *Store_GetGiteaEndpoint_Call {
	return &Store_GetGiteaEndpoint_Call{Call: _e.mock.On("GetGiteaEndpoint", _a0, name)}
}

func (_c *Store_GetGiteaEndpoint_Call) Run(run func(_a0 context.Context, name string)) *Store_GetGiteaEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_GetGiteaEndpoint_Call) Return(_a0 params.ForgeEndpoint, _a1 error) *Store_GetGiteaEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetGiteaEndpoint_Call) RunAndReturn(run func(context.Context, string) (params.ForgeEndpoint, error)) *Store_GetGiteaEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// GetGithubCredentials provides a mock function with given fields: ctx, id, detailed
func (_m *Store) GetGithubCredentials(ctx context.Context, id uint, detailed bool) (params.ForgeCredentials, error) {
	ret := _m.Called(ctx, id, detailed)

	if len(ret) == 0 {
		panic("no return value specified for GetGithubCredentials")
	}

	var r0 params.ForgeCredentials
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, bool) (params.ForgeCredentials, error)); ok {
		return rf(ctx, id, detailed)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, bool) params.ForgeCredentials); ok {
		r0 = rf(ctx, id, detailed)
	} else {
		r0 = ret.Get(0).(params.ForgeCredentials)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, bool) error); ok {
		r1 = rf(ctx, id, detailed)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetGithubCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGithubCredentials'
type Store_GetGithubCredentials_Call struct {
	*mock.Call
}

// GetGithubCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint
//   - detailed bool
func (_e *Store_Expecter) GetGithubCredentials(ctx interface{}, id interface{}, detailed interface{}) *Store_GetGithubCredentials_Call {
	return &Store_GetGithubCredentials_Call{Call: _e.mock.On("GetGithubCredentials", ctx, id, detailed)}
}

func (_c *Store_GetGithubCredentials_Call) Run(run func(ctx context.Context, id uint, detailed bool)) *Store_GetGithubCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(bool))
	})
	return _c
}

func (_c *Store_GetGithubCredentials_Call) Return(_a0 params.ForgeCredentials, _a1 error) *Store_GetGithubCredentials_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetGithubCredentials_Call) RunAndReturn(run func(context.Context, uint, bool) (params.ForgeCredentials, error)) *Store_GetGithubCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// GetGithubCredentialsByName provides a mock function with given fields: ctx, name, detailed
func (_m *Store) GetGithubCredentialsByName(ctx context.Context, name string, detailed bool) (params.ForgeCredentials, error) {
	ret := _m.Called(ctx, name, detailed)

	if len(ret) == 0 {
		panic("no return value specified for GetGithubCredentialsByName")
	}

	var r0 params.ForgeCredentials
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) (params.ForgeCredentials, error)); ok {
		return rf(ctx, name, detailed)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) params.ForgeCredentials); ok {
		r0 = rf(ctx, name, detailed)
	} else {
		r0 = ret.Get(0).(params.ForgeCredentials)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(ctx, name, detailed)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetGithubCredentialsByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGithubCredentialsByName'
type Store_GetGithubCredentialsByName_Call struct {
	*mock.Call
}

// GetGithubCredentialsByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - detailed bool
func (_e *Store_Expecter) GetGithubCredentialsByName(ctx interface{}, name interface{}, detailed interface{}) *Store_GetGithubCredentialsByName_Call {
	return &Store_GetGithubCredentialsByName_Call{Call: _e.mock.On("GetGithubCredentialsByName", ctx, name, detailed)}
}

func (_c *Store_GetGithubCredentialsByName_Call) Run(run func(ctx context.Context, name string, detailed bool)) *Store_GetGithubCredentialsByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *Store_GetGithubCredentialsByName_Call) Return(_a0 params.ForgeCredentials, _a1 error) *Store_GetGithubCredentialsByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetGithubCredentialsByName_Call) RunAndReturn(run func(context.Context, string, bool) (params.ForgeCredentials, error)) *Store_GetGithubCredentialsByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetGithubEndpoint provides a mock function with given fields: ctx, name
func (_m *Store) GetGithubEndpoint(ctx context.Context, name string) (params.ForgeEndpoint, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetGithubEndpoint")
	}

	var r0 params.ForgeEndpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (params.ForgeEndpoint, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) params.ForgeEndpoint); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(params.ForgeEndpoint)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetGithubEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGithubEndpoint'
type Store_GetGithubEndpoint_Call struct {
	*mock.Call
}

// GetGithubEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Store_Expecter) GetGithubEndpoint(ctx interface{}, name interface{}) *Store_GetGithubEndpoint_Call {
	return &Store_GetGithubEndpoint_Call{Call: _e.mock.On("GetGithubEndpoint", ctx, name)}
}

func (_c *Store_GetGithubEndpoint_Call) Run(run func(ctx context.Context, name string)) *Store_GetGithubEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_GetGithubEndpoint_Call) Return(_a0 params.ForgeEndpoint, _a1 error) *Store_GetGithubEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetGithubEndpoint_Call) RunAndReturn(run func(context.Context, string) (params.ForgeEndpoint, error)) *Store_GetGithubEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstance provides a mock function with given fields: ctx, instanceNameOrID
func (_m *Store) GetInstance(ctx context.Context, instanceNameOrID string) (params.Instance, error) {
	ret := _m.Called(ctx, instanceNameOrID)

	if len(ret) == 0 {
		panic("no return value specified for GetInstance")
	}

	var r0 params.Instance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (params.Instance, error)); ok {
		return rf(ctx, instanceNameOrID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) params.Instance); ok {
		r0 = rf(ctx, instanceNameOrID)
	} else {
		r0 = ret.Get(0).(params.Instance)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, instanceNameOrID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstance'
type Store_GetInstance_Call struct {
	*mock.Call
}

// GetInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceNameOrID string
func (_e *Store_Expecter) GetInstance(ctx interface{}, instanceNameOrID interface{}) *Store_GetInstance_Call {
	return &Store_GetInstance_Call{Call: _e.mock.On("GetInstance", ctx, instanceNameOrID)}
}

func (_c *Store_GetInstance_Call) Run(run func(ctx context.Context, instanceNameOrID string)) *Store_GetInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_GetInstance_Call) Return(_a0 params.Instance, _a1 error) *Store_GetInstance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetInstance_Call) RunAndReturn(run func(context.Context, string) (params.Instance, error)) *Store_GetInstance_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobByID provides a mock function with given fields: ctx, jobID
func (_m *Store) GetJobByID(ctx context.Context, jobID int64) (params.Job, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobByID")
	}

	var r0 params.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (params.Job, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) params.Job); ok {
		r0 = rf(ctx, jobID)
	} else {
		r0 = ret.Get(0).(params.Job)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetJobByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobByID'
type Store_GetJobByID_Call struct {
	*mock.Call
}

// GetJobByID is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID int64
func (_e *Store_Expecter) GetJobByID(ctx interface{}, jobID interface{}) *Store_GetJobByID_Call {
	return &Store_GetJobByID_Call{Call: _e.mock.On("GetJobByID", ctx, jobID)}
}

func (_c *Store_GetJobByID_Call) Run(run func(ctx context.Context, jobID int64)) *Store_GetJobByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *Store_GetJobByID_Call) Return(_a0 params.Job, _a1 error) *Store_GetJobByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetJobByID_Call) RunAndReturn(run func(context.Context, int64) (params.Job, error)) *Store_GetJobByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrganization provides a mock function with given fields: ctx, name, endpointName
func (_m *Store) GetOrganization(ctx context.Context, name string, endpointName string) (params.Organization, error) {
	ret := _m.Called(ctx, name, endpointName)

	if len(ret) == 0 {
		panic("no return value specified for GetOrganization")
	}

	var r0 params.Organization
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (params.Organization, error)); ok {
		return rf(ctx, name, endpointName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) params.Organization); ok {
		r0 = rf(ctx, name, endpointName)
	} else {
		r0 = ret.Get(0).(params.Organization)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, name, endpointName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetOrganization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrganization'
type Store_GetOrganization_Call struct {
	*mock.Call
}

// GetOrganization is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - endpointName string
func (_e *Store_Expecter) GetOrganization(ctx interface{}, name interface{}, endpointName interface{}) *Store_GetOrganization_Call {
	return &Store_GetOrganization_Call{Call: _e.mock.On("GetOrganization", ctx, name, endpointName)}
}

func (_c *Store_GetOrganization_Call) Run(run func(ctx context.Context, name string, endpointName string)) *Store_GetOrganization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Store_GetOrganization_Call) Return(_a0 params.Organization, _a1 error) *Store_GetOrganization_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetOrganization_Call) RunAndReturn(run func(context.Context, string, string) (params.Organization, error)) *Store_GetOrganization_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrganizationByID provides a mock function with given fields: ctx, orgID
func (_m *Store) GetOrganizationByID(ctx context.Context, orgID string) (params.Organization, error) {
	ret := _m.Called(ctx, orgID)

	if len(ret) == 0 {
		panic("no return value specified for GetOrganizationByID")
	}

	var r0 params.Organization
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (params.Organization, error)); ok {
		return rf(ctx, orgID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) params.Organization); ok {
		r0 = rf(ctx, orgID)
	} else {
		r0 = ret.Get(0).(params.Organization)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, orgID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetOrganizationByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrganizationByID'
type Store_GetOrganizationByID_Call struct {
	*mock.Call
}

// GetOrganizationByID is a helper method to define mock.On call
//   - ctx context.Context
//   - orgID string
func (_e *Store_Expecter) GetOrganizationByID(ctx interface{}, orgID interface{}) *Store_GetOrganizationByID_Call {
	return &Store_GetOrganizationByID_Call{Call: _e.mock.On("GetOrganizationByID", ctx, orgID)}
}

func (_c *Store_GetOrganizationByID_Call) Run(run func(ctx context.Context, orgID string)) *Store_GetOrganizationByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_GetOrganizationByID_Call) Return(_a0 params.Organization, _a1 error) *Store_GetOrganizationByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetOrganizationByID_Call) RunAndReturn(run func(context.Context, string) (params.Organization, error)) *Store_GetOrganizationByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetPoolByID provides a mock function with given fields: ctx, poolID
func (_m *Store) GetPoolByID(ctx context.Context, poolID string) (params.Pool, error) {
	ret := _m.Called(ctx, poolID)

	if len(ret) == 0 {
		panic("no return value specified for GetPoolByID")
	}

	var r0 params.Pool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (params.Pool, error)); ok {
		return rf(ctx, poolID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) params.Pool); ok {
		r0 = rf(ctx, poolID)
	} else {
		r0 = ret.Get(0).(params.Pool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, poolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetPoolByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPoolByID'
type Store_GetPoolByID_Call struct {
	*mock.Call
}

// GetPoolByID is a helper method to define mock.On call
//   - ctx context.Context
//   - poolID string
func (_e *Store_Expecter) GetPoolByID(ctx interface{}, poolID interface{}) *Store_GetPoolByID_Call {
	return &Store_GetPoolByID_Call{Call: _e.mock.On("GetPoolByID", ctx, poolID)}
}

func (_c *Store_GetPoolByID_Call) Run(run func(ctx context.Context, poolID string)) *Store_GetPoolByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_GetPoolByID_Call) Return(_a0 params.Pool, _a1 error) *Store_GetPoolByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetPoolByID_Call) RunAndReturn(run func(context.Context, string) (params.Pool, error)) *Store_GetPoolByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepository provides a mock function with given fields: ctx, owner, name, endpointName
func (_m *Store) GetRepository(ctx context.Context, owner string, name string, endpointName string) (params.Repository, error) {
	ret := _m.Called(ctx, owner, name, endpointName)

	if len(ret) == 0 {
		panic("no return value specified for GetRepository")
	}

	var r0 params.Repository
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (params.Repository, error)); ok {
		return rf(ctx, owner, name, endpointName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) params.Repository); ok {
		r0 = rf(ctx, owner, name, endpointName)
	} else {
		r0 = ret.Get(0).(params.Repository)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, owner, name, endpointName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepository'
type Store_GetRepository_Call struct {
	*mock.Call
}

// GetRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - name string
//   - endpointName string
func (_e *Store_Expecter) GetRepository(ctx interface{}, owner interface{}, name interface{}, endpointName interface{}) *Store_GetRepository_Call {
	return &Store_GetRepository_Call{Call: _e.mock.On("GetRepository", ctx, owner, name, endpointName)}
}

func (_c *Store_GetRepository_Call) Run(run func(ctx context.Context, owner string, name string, endpointName string)) *Store_GetRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *Store_GetRepository_Call) Return(_a0 params.Repository, _a1 error) *Store_GetRepository_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetRepository_Call) RunAndReturn(run func(context.Context, string, string, string) (params.Repository, error)) *Store_GetRepository_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepositoryByID provides a mock function with given fields: ctx, repoID
func (_m *Store) GetRepositoryByID(ctx context.Context, repoID string) (params.Repository, error) {
	ret := _m.Called(ctx, repoID)

	if len(ret) == 0 {
		panic("no return value specified for GetRepositoryByID")
	}

	var r0 params.Repository
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (params.Repository, error)); ok {
		return rf(ctx, repoID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) params.Repository); ok {
		r0 = rf(ctx, repoID)
	} else {
		r0 = ret.Get(0).(params.Repository)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, repoID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetRepositoryByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepositoryByID'
type Store_GetRepositoryByID_Call struct {
	*mock.Call
}

// GetRepositoryByID is a helper method to define mock.On call
//   - ctx context.Context
//   - repoID string
func (_e *Store_Expecter) GetRepositoryByID(ctx interface{}, repoID interface{}) *Store_GetRepositoryByID_Call {
	return &Store_GetRepositoryByID_Call{Call: _e.mock.On("GetRepositoryByID", ctx, repoID)}
}

func (_c *Store_GetRepositoryByID_Call) Run(run func(ctx context.Context, repoID string)) *Store_GetRepositoryByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_GetRepositoryByID_Call) Return(_a0 params.Repository, _a1 error) *Store_GetRepositoryByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetRepositoryByID_Call) RunAndReturn(run func(context.Context, string) (params.Repository, error)) *Store_GetRepositoryByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetScaleSetByID provides a mock function with given fields: ctx, scaleSet
func (_m *Store) GetScaleSetByID(ctx context.Context, scaleSet uint) (params.ScaleSet, error) {
	ret := _m.Called(ctx, scaleSet)

	if len(ret) == 0 {
		panic("no return value specified for GetScaleSetByID")
	}

	var r0 params.ScaleSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) (params.ScaleSet, error)); ok {
		return rf(ctx, scaleSet)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint) params.ScaleSet); ok {
		r0 = rf(ctx, scaleSet)
	} else {
		r0 = ret.Get(0).(params.ScaleSet)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = rf(ctx, scaleSet)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetScaleSetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetScaleSetByID'
type Store_GetScaleSetByID_Call struct {
	*mock.Call
}

// GetScaleSetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - scaleSet uint
func (_e *Store_Expecter) GetScaleSetByID(ctx interface{}, scaleSet interface{}) *Store_GetScaleSetByID_Call {
	return &Store_GetScaleSetByID_Call{Call: _e.mock.On("GetScaleSetByID", ctx, scaleSet)}
}

func (_c *Store_GetScaleSetByID_Call) Run(run func(ctx context.Context, scaleSet uint)) *Store_GetScaleSetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *Store_GetScaleSetByID_Call) Return(_a0 params.ScaleSet, _a1 error) *Store_GetScaleSetByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetScaleSetByID_Call) RunAndReturn(run func(context.Context, uint) (params.ScaleSet, error)) *Store_GetScaleSetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetTemplate provides a mock function with given fields: ctx, id
func (_m *Store) GetTemplate(ctx context.Context, id uint) (params.Template, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTemplate")
	}

	var r0 params.Template
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) (params.Template, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint) params.Template); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(params.Template)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTemplate'
type Store_GetTemplate_Call struct {
	*mock.Call
}

// GetTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint
func (_e *Store_Expecter) GetTemplate(ctx interface{}, id interface{}) *Store_GetTemplate_Call {
	return &Store_GetTemplate_Call{Call: _e.mock.On("GetTemplate", ctx, id)}
}

func (_c *Store_GetTemplate_Call) Run(run func(ctx context.Context, id uint)) *Store_GetTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *Store_GetTemplate_Call) Return(_a0 params.Template, _a1 error) *Store_GetTemplate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetTemplate_Call) RunAndReturn(run func(context.Context, uint) (params.Template, error)) *Store_GetTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// GetTemplateByName provides a mock function with given fields: ctx, name
func (_m *Store) GetTemplateByName(ctx context.Context, name string) (params.Template, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetTemplateByName")
	}

	var r0 params.Template
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (params.Template, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) params.Template); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(params.Template)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetTemplateByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTemplateByName'
type Store_GetTemplateByName_Call struct {
	*mock.Call
}

// GetTemplateByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Store_Expecter) GetTemplateByName(ctx interface{}, name interface{}) *Store_GetTemplateByName_Call {
	return &Store_GetTemplateByName_Call{Call: _e.mock.On("GetTemplateByName", ctx, name)}
}

func (_c *Store_GetTemplateByName_Call) Run(run func(ctx context.Context, name string)) *Store_GetTemplateByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_GetTemplateByName_Call) Return(_a0 params.Template, _a1 error) *Store_GetTemplateByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetTemplateByName_Call) RunAndReturn(run func(context.Context, string) (params.Template, error)) *Store_GetTemplateByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function with given fields: ctx, user
func (_m *Store) GetUser(ctx context.Context, user string) (params.User, error) {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 params.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (params.User, error)); ok {
		return rf(ctx, user)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) params.User); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Get(0).(params.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type Store_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user string
func (_e *Store_Expecter) GetUser(ctx interface{}, user interface{}) *Store_GetUser_Call {
	return &Store_GetUser_Call{Call: _e.mock.On("GetUser", ctx, user)}
}

func (_c *Store_GetUser_Call) Run(run func(ctx context.Context, user string)) *Store_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_GetUser_Call) Return(_a0 params.User, _a1 error) *Store_GetUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetUser_Call) RunAndReturn(run func(context.Context, string) (params.User, error)) *Store_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByID provides a mock function with given fields: ctx, userID
func (_m *Store) GetUserByID(ctx context.Context, userID string) (params.User, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByID")
	}

	var r0 params.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (params.User, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) params.User); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Get(0).(params.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetUserByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByID'
type Store_GetUserByID_Call struct {
	*mock.Call
}

// GetUserByID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *Store_Expecter) GetUserByID(ctx interface{}, userID interface{}) *Store_GetUserByID_Call {
	return &Store_GetUserByID_Call{Call: _e.mock.On("GetUserByID", ctx, userID)}
}

func (_c *Store_GetUserByID_Call) Run(run func(ctx context.Context, userID string)) *Store_GetUserByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_GetUserByID_Call) Return(_a0 params.User, _a1 error) *Store_GetUserByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetUserByID_Call) RunAndReturn(run func(context.Context, string) (params.User, error)) *Store_GetUserByID_Call {
	_c.Call.Return(run)
	return _c
}

// HasAdminUser provides a mock function with given fields: ctx
func (_m *Store) HasAdminUser(ctx context.Context) bool {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for HasAdminUser")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Store_HasAdminUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasAdminUser'
type Store_HasAdminUser_Call struct {
	*mock.Call
}

// HasAdminUser is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Store_Expecter) HasAdminUser(ctx interface{}) *Store_HasAdminUser_Call {
	return &Store_HasAdminUser_Call{Call: _e.mock.On("HasAdminUser", ctx)}
}

func (_c *Store_HasAdminUser_Call) Run(run func(ctx context.Context)) *Store_HasAdminUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_HasAdminUser_Call) Return(_a0 bool) *Store_HasAdminUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_HasAdminUser_Call) RunAndReturn(run func(context.Context) bool) *Store_HasAdminUser_Call {
	_c.Call.Return(run)
	return _c
}

// InitController provides a mock function with no fields
func (_m *Store) InitController() (params.ControllerInfo, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for InitController")
	}

	var r0 params.ControllerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func() (params.ControllerInfo, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() params.ControllerInfo); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(params.ControllerInfo)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_InitController_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitController'
type Store_InitController_Call struct {
	*mock.Call
}

// InitController is a helper method to define mock.On call
func (_e *Store_Expecter) InitController() *Store_InitController_Call {
	return &Store_InitController_Call{Call: _e.mock.On("InitController")}
}

func (_c *Store_InitController_Call) Run(run func()) *Store_InitController_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Store_InitController_Call) Return(_a0 params.ControllerInfo, _a1 error) *Store_InitController_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_InitController_Call) RunAndReturn(run func() (params.ControllerInfo, error)) *Store_InitController_Call {
	_c.Call.Return(run)
	return _c
}

// ListAllInstances provides a mock function with given fields: ctx
func (_m *Store) ListAllInstances(ctx context.Context) ([]params.Instance, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListAllInstances")
	}

	var r0 []params.Instance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]params.Instance, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []params.Instance); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Instance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListAllInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAllInstances'
type Store_ListAllInstances_Call struct {
	*mock.Call
}

// ListAllInstances is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Store_Expecter) ListAllInstances(ctx interface{}) *Store_ListAllInstances_Call {
	return &Store_ListAllInstances_Call{Call: _e.mock.On("ListAllInstances", ctx)}
}

func (_c *Store_ListAllInstances_Call) Run(run func(ctx context.Context)) *Store_ListAllInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_ListAllInstances_Call) Return(_a0 []params.Instance, _a1 error) *Store_ListAllInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListAllInstances_Call) RunAndReturn(run func(context.Context) ([]params.Instance, error)) *Store_ListAllInstances_Call {
	_c.Call.Return(run)
	return _c
}

// ListAllJobs provides a mock function with given fields: ctx
func (_m *Store) ListAllJobs(ctx context.Context) ([]params.Job, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListAllJobs")
	}

	var r0 []params.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]params.Job, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []params.Job); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListAllJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAllJobs'
type Store_ListAllJobs_Call struct {
	*mock.Call
}

// ListAllJobs is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Store_Expecter) ListAllJobs(ctx interface{}) *Store_ListAllJobs_Call {
	return &Store_ListAllJobs_Call{Call: _e.mock.On("ListAllJobs", ctx)}
}

func (_c *Store_ListAllJobs_Call) Run(run func(ctx context.Context)) *Store_ListAllJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_ListAllJobs_Call) Return(_a0 []params.Job, _a1 error) *Store_ListAllJobs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListAllJobs_Call) RunAndReturn(run func(context.Context) ([]params.Job, error)) *Store_ListAllJobs_Call {
	_c.Call.Return(run)
	return _c
}

// ListAllPools provides a mock function with given fields: ctx
func (_m *Store) ListAllPools(ctx context.Context) ([]params.Pool, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListAllPools")
	}

	var r0 []params.Pool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]params.Pool, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []params.Pool); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Pool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListAllPools_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAllPools'
type Store_ListAllPools_Call struct {
	*mock.Call
}

// ListAllPools is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Store_Expecter) ListAllPools(ctx interface{}) *Store_ListAllPools_Call {
	return &Store_ListAllPools_Call{Call: _e.mock.On("ListAllPools", ctx)}
}

func (_c *Store_ListAllPools_Call) Run(run func(ctx context.Context)) *Store_ListAllPools_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_ListAllPools_Call) Return(_a0 []params.Pool, _a1 error) *Store_ListAllPools_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListAllPools_Call) RunAndReturn(run func(context.Context) ([]params.Pool, error)) *Store_ListAllPools_Call {
	_c.Call.Return(run)
	return _c
}

// ListAllScaleSets provides a mock function with given fields: ctx
func (_m *Store) ListAllScaleSets(ctx context.Context) ([]params.ScaleSet, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListAllScaleSets")
	}

	var r0 []params.ScaleSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]params.ScaleSet, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []params.ScaleSet); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.ScaleSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListAllScaleSets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAllScaleSets'
type Store_ListAllScaleSets_Call struct {
	*mock.Call
}

// ListAllScaleSets is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Store_Expecter) ListAllScaleSets(ctx interface{}) *Store_ListAllScaleSets_Call {
	return &Store_ListAllScaleSets_Call{Call: _e.mock.On("ListAllScaleSets", ctx)}
}

func (_c *Store_ListAllScaleSets_Call) Run(run func(ctx context.Context)) *Store_ListAllScaleSets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_ListAllScaleSets_Call) Return(_a0 []params.ScaleSet, _a1 error) *Store_ListAllScaleSets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListAllScaleSets_Call) RunAndReturn(run func(context.Context) ([]params.ScaleSet, error)) *Store_ListAllScaleSets_Call {
	_c.Call.Return(run)
	return _c
}

// ListEnterprises provides a mock function with given fields: ctx, filter
func (_m *Store) ListEnterprises(ctx context.Context, filter params.EnterpriseFilter) ([]params.Enterprise, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for ListEnterprises")
	}

	var r0 []params.Enterprise
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.EnterpriseFilter) ([]params.Enterprise, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.EnterpriseFilter) []params.Enterprise); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Enterprise)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.EnterpriseFilter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListEnterprises_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEnterprises'
type Store_ListEnterprises_Call struct {
	*mock.Call
}

// ListEnterprises is a helper method to define mock.On call
//   - ctx context.Context
//   - filter params.EnterpriseFilter
func (_e *Store_Expecter) ListEnterprises(ctx interface{}, filter interface{}) *Store_ListEnterprises_Call {
	return &Store_ListEnterprises_Call{Call: _e.mock.On("ListEnterprises", ctx, filter)}
}

func (_c *Store_ListEnterprises_Call) Run(run func(ctx context.Context, filter params.EnterpriseFilter)) *Store_ListEnterprises_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.EnterpriseFilter))
	})
	return _c
}

func (_c *Store_ListEnterprises_Call) Return(_a0 []params.Enterprise, _a1 error) *Store_ListEnterprises_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListEnterprises_Call) RunAndReturn(run func(context.Context, params.EnterpriseFilter) ([]params.Enterprise, error)) *Store_ListEnterprises_Call {
	_c.Call.Return(run)
	return _c
}

// ListEntityInstances provides a mock function with given fields: ctx, entity
func (_m *Store) ListEntityInstances(ctx context.Context, entity params.ForgeEntity) ([]params.Instance, error) {
	ret := _m.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for ListEntityInstances")
	}

	var r0 []params.Instance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity) ([]params.Instance, error)); ok {
		return rf(ctx, entity)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity) []params.Instance); ok {
		r0 = rf(ctx, entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Instance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.ForgeEntity) error); ok {
		r1 = rf(ctx, entity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListEntityInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEntityInstances'
type Store_ListEntityInstances_Call struct {
	*mock.Call
}

// ListEntityInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - entity params.ForgeEntity
func (_e *Store_Expecter) ListEntityInstances(ctx interface{}, entity interface{}) *Store_ListEntityInstances_Call {
	return &Store_ListEntityInstances_Call{Call: _e.mock.On("ListEntityInstances", ctx, entity)}
}

func (_c *Store_ListEntityInstances_Call) Run(run func(ctx context.Context, entity params.ForgeEntity)) *Store_ListEntityInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntity))
	})
	return _c
}

func (_c *Store_ListEntityInstances_Call) Return(_a0 []params.Instance, _a1 error) *Store_ListEntityInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListEntityInstances_Call) RunAndReturn(run func(context.Context, params.ForgeEntity) ([]params.Instance, error)) *Store_ListEntityInstances_Call {
	_c.Call.Return(run)
	return _c
}

// ListEntityJobsByStatus provides a mock function with given fields: ctx, entityType, entityID, status
func (_m *Store) ListEntityJobsByStatus(ctx context.Context, entityType params.ForgeEntityType, entityID string, status params.JobStatus) ([]params.Job, error) {
	ret := _m.Called(ctx, entityType, entityID, status)

	if len(ret) == 0 {
		panic("no return value specified for ListEntityJobsByStatus")
	}

	var r0 []params.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntityType, string, params.JobStatus) ([]params.Job, error)); ok {
		return rf(ctx, entityType, entityID, status)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntityType, string, params.JobStatus) []params.Job); ok {
		r0 = rf(ctx, entityType, entityID, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.ForgeEntityType, string, params.JobStatus) error); ok {
		r1 = rf(ctx, entityType, entityID, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListEntityJobsByStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEntityJobsByStatus'
type Store_ListEntityJobsByStatus_Call struct {
	*mock.Call
}

// ListEntityJobsByStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - entityType params.ForgeEntityType
//   - entityID string
//   - status params.JobStatus
func (_e *Store_Expecter) ListEntityJobsByStatus(ctx interface{}, entityType interface{}, entityID interface{}, status interface{}) *Store_ListEntityJobsByStatus_Call {
	return &Store_ListEntityJobsByStatus_Call{Call: _e.mock.On("ListEntityJobsByStatus", ctx, entityType, entityID, status)}
}

func (_c *Store_ListEntityJobsByStatus_Call) Run(run func(ctx context.Context, entityType params.ForgeEntityType, entityID string, status params.JobStatus)) *Store_ListEntityJobsByStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntityType), args[2].(string), args[3].(params.JobStatus))
	})
	return _c
}

func (_c *Store_ListEntityJobsByStatus_Call) Return(_a0 []params.Job, _a1 error) *Store_ListEntityJobsByStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListEntityJobsByStatus_Call) RunAndReturn(run func(context.Context, params.ForgeEntityType, string, params.JobStatus) ([]params.Job, error)) *Store_ListEntityJobsByStatus_Call {
	_c.Call.Return(run)
	return _c
}

// ListEntityPools provides a mock function with given fields: ctx, entity
func (_m *Store) ListEntityPools(ctx context.Context, entity params.ForgeEntity) ([]params.Pool, error) {
	ret := _m.Called(ctx, entity)

	if len(ret) == 0 {
		panic("no return value specified for ListEntityPools")
	}

	var r0 []params.Pool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity) ([]params.Pool, error)); ok {
		return rf(ctx, entity)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity) []params.Pool); ok {
		r0 = rf(ctx, entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Pool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.ForgeEntity) error); ok {
		r1 = rf(ctx, entity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListEntityPools_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEntityPools'
type Store_ListEntityPools_Call struct {
	*mock.Call
}

// ListEntityPools is a helper method to define mock.On call
//   - ctx context.Context
//   - entity params.ForgeEntity
func (_e *Store_Expecter) ListEntityPools(ctx interface{}, entity interface{}) *Store_ListEntityPools_Call {
	return &Store_ListEntityPools_Call{Call: _e.mock.On("ListEntityPools", ctx, entity)}
}

func (_c *Store_ListEntityPools_Call) Run(run func(ctx context.Context, entity params.ForgeEntity)) *Store_ListEntityPools_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntity))
	})
	return _c
}

func (_c *Store_ListEntityPools_Call) Return(_a0 []params.Pool, _a1 error) *Store_ListEntityPools_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListEntityPools_Call) RunAndReturn(run func(context.Context, params.ForgeEntity) ([]params.Pool, error)) *Store_ListEntityPools_Call {
	_c.Call.Return(run)
	return _c
}

// ListEntityScaleSets provides a mock function with given fields: _a0, entity
func (_m *Store) ListEntityScaleSets(_a0 context.Context, entity params.ForgeEntity) ([]params.ScaleSet, error) {
	ret := _m.Called(_a0, entity)

	if len(ret) == 0 {
		panic("no return value specified for ListEntityScaleSets")
	}

	var r0 []params.ScaleSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity) ([]params.ScaleSet, error)); ok {
		return rf(_a0, entity)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity) []params.ScaleSet); ok {
		r0 = rf(_a0, entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.ScaleSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.ForgeEntity) error); ok {
		r1 = rf(_a0, entity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListEntityScaleSets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEntityScaleSets'
type Store_ListEntityScaleSets_Call struct {
	*mock.Call
}

// ListEntityScaleSets is a helper method to define mock.On call
//   - _a0 context.Context
//   - entity params.ForgeEntity
func (_e *Store_Expecter) ListEntityScaleSets(_a0 interface{}, entity interface{}) *Store_ListEntityScaleSets_Call {
	return &Store_ListEntityScaleSets_Call{Call: _e.mock.On("ListEntityScaleSets", _a0, entity)}
}

func (_c *Store_ListEntityScaleSets_Call) Run(run func(_a0 context.Context, entity params.ForgeEntity)) *Store_ListEntityScaleSets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntity))
	})
	return _c
}

func (_c *Store_ListEntityScaleSets_Call) Return(_a0 []params.ScaleSet, _a1 error) *Store_ListEntityScaleSets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListEntityScaleSets_Call) RunAndReturn(run func(context.Context, params.ForgeEntity) ([]params.ScaleSet, error)) *Store_ListEntityScaleSets_Call {
	_c.Call.Return(run)
	return _c
}

// ListFileObjects provides a mock function with given fields: ctx, page, pageSize
func (_m *Store) ListFileObjects(ctx context.Context, page uint64, pageSize uint64) (params.FileObjectPaginatedResponse, error) {
	ret := _m.Called(ctx, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for ListFileObjects")
	}

	var r0 params.FileObjectPaginatedResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64) (params.FileObjectPaginatedResponse, error)); ok {
		return rf(ctx, page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64) params.FileObjectPaginatedResponse); ok {
		r0 = rf(ctx, page, pageSize)
	} else {
		r0 = ret.Get(0).(params.FileObjectPaginatedResponse)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64) error); ok {
		r1 = rf(ctx, page, pageSize)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListFileObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListFileObjects'
type Store_ListFileObjects_Call struct {
	*mock.Call
}

// ListFileObjects is a helper method to define mock.On call
//   - ctx context.Context
//   - page uint64
//   - pageSize uint64
func (_e *Store_Expecter) ListFileObjects(ctx interface{}, page interface{}, pageSize interface{}) *Store_ListFileObjects_Call {
	return &Store_ListFileObjects_Call{Call: _e.mock.On("ListFileObjects", ctx, page, pageSize)}
}

func (_c *Store_ListFileObjects_Call) Run(run func(ctx context.Context, page uint64, pageSize uint64)) *Store_ListFileObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64))
	})
	return _c
}

func (_c *Store_ListFileObjects_Call) Return(_a0 params.FileObjectPaginatedResponse, _a1 error) *Store_ListFileObjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListFileObjects_Call) RunAndReturn(run func(context.Context, uint64, uint64) (params.FileObjectPaginatedResponse, error)) *Store_ListFileObjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListGiteaCredentials provides a mock function with given fields: ctx
func (_m *Store) ListGiteaCredentials(ctx context.Context) ([]params.ForgeCredentials, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListGiteaCredentials")
	}

	var r0 []params.ForgeCredentials
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]params.ForgeCredentials, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []params.ForgeCredentials); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.ForgeCredentials)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListGiteaCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGiteaCredentials'
type Store_ListGiteaCredentials_Call struct {
	*mock.Call
}

// ListGiteaCredentials is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Store_Expecter) ListGiteaCredentials(ctx interface{}) *Store_ListGiteaCredentials_Call {
	return &Store_ListGiteaCredentials_Call{Call: _e.mock.On("ListGiteaCredentials", ctx)}
}

func (_c *Store_ListGiteaCredentials_Call) Run(run func(ctx context.Context)) *Store_ListGiteaCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_ListGiteaCredentials_Call) Return(_a0 []params.ForgeCredentials, _a1 error) *Store_ListGiteaCredentials_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListGiteaCredentials_Call) RunAndReturn(run func(context.Context) ([]params.ForgeCredentials, error)) *Store_ListGiteaCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// ListGiteaEndpoints provides a mock function with given fields: _a0
func (_m *Store) ListGiteaEndpoints(_a0 context.Context) ([]params.ForgeEndpoint, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ListGiteaEndpoints")
	}

	var r0 []params.ForgeEndpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]params.ForgeEndpoint, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []params.ForgeEndpoint); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.ForgeEndpoint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListGiteaEndpoints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGiteaEndpoints'
type Store_ListGiteaEndpoints_Call struct {
	*mock.Call
}

// ListGiteaEndpoints is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *Store_Expecter) ListGiteaEndpoints(_a0 interface{}) *Store_ListGiteaEndpoints_Call {
	return &Store_ListGiteaEndpoints_Call{Call: _e.mock.On("ListGiteaEndpoints", _a0)}
}

func (_c *Store_ListGiteaEndpoints_Call) Run(run func(_a0 context.Context)) *Store_ListGiteaEndpoints_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_ListGiteaEndpoints_Call) Return(_a0 []params.ForgeEndpoint, _a1 error) *Store_ListGiteaEndpoints_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListGiteaEndpoints_Call) RunAndReturn(run func(context.Context) ([]params.ForgeEndpoint, error)) *Store_ListGiteaEndpoints_Call {
	_c.Call.Return(run)
	return _c
}

// ListGithubCredentials provides a mock function with given fields: ctx
func (_m *Store) ListGithubCredentials(ctx context.Context) ([]params.ForgeCredentials, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListGithubCredentials")
	}

	var r0 []params.ForgeCredentials
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]params.ForgeCredentials, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []params.ForgeCredentials); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.ForgeCredentials)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListGithubCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGithubCredentials'
type Store_ListGithubCredentials_Call struct {
	*mock.Call
}

// ListGithubCredentials is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Store_Expecter) ListGithubCredentials(ctx interface{}) *Store_ListGithubCredentials_Call {
	return &Store_ListGithubCredentials_Call{Call: _e.mock.On("ListGithubCredentials", ctx)}
}

func (_c *Store_ListGithubCredentials_Call) Run(run func(ctx context.Context)) *Store_ListGithubCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_ListGithubCredentials_Call) Return(_a0 []params.ForgeCredentials, _a1 error) *Store_ListGithubCredentials_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListGithubCredentials_Call) RunAndReturn(run func(context.Context) ([]params.ForgeCredentials, error)) *Store_ListGithubCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// ListGithubEndpoints provides a mock function with given fields: ctx
func (_m *Store) ListGithubEndpoints(ctx context.Context) ([]params.ForgeEndpoint, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListGithubEndpoints")
	}

	var r0 []params.ForgeEndpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]params.ForgeEndpoint, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []params.ForgeEndpoint); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.ForgeEndpoint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListGithubEndpoints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGithubEndpoints'
type Store_ListGithubEndpoints_Call struct {
	*mock.Call
}

// ListGithubEndpoints is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Store_Expecter) ListGithubEndpoints(ctx interface{}) *Store_ListGithubEndpoints_Call {
	return &Store_ListGithubEndpoints_Call{Call: _e.mock.On("ListGithubEndpoints", ctx)}
}

func (_c *Store_ListGithubEndpoints_Call) Run(run func(ctx context.Context)) *Store_ListGithubEndpoints_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_ListGithubEndpoints_Call) Return(_a0 []params.ForgeEndpoint, _a1 error) *Store_ListGithubEndpoints_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListGithubEndpoints_Call) RunAndReturn(run func(context.Context) ([]params.ForgeEndpoint, error)) *Store_ListGithubEndpoints_Call {
	_c.Call.Return(run)
	return _c
}

// ListJobsByStatus provides a mock function with given fields: ctx, status
func (_m *Store) ListJobsByStatus(ctx context.Context, status params.JobStatus) ([]params.Job, error) {
	ret := _m.Called(ctx, status)

	if len(ret) == 0 {
		panic("no return value specified for ListJobsByStatus")
	}

	var r0 []params.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.JobStatus) ([]params.Job, error)); ok {
		return rf(ctx, status)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.JobStatus) []params.Job); ok {
		r0 = rf(ctx, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.JobStatus) error); ok {
		r1 = rf(ctx, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListJobsByStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListJobsByStatus'
type Store_ListJobsByStatus_Call struct {
	*mock.Call
}

// ListJobsByStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - status params.JobStatus
func (_e *Store_Expecter) ListJobsByStatus(ctx interface{}, status interface{}) *Store_ListJobsByStatus_Call {
	return &Store_ListJobsByStatus_Call{Call: _e.mock.On("ListJobsByStatus", ctx, status)}
}

func (_c *Store_ListJobsByStatus_Call) Run(run func(ctx context.Context, status params.JobStatus)) *Store_ListJobsByStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.JobStatus))
	})
	return _c
}

func (_c *Store_ListJobsByStatus_Call) Return(_a0 []params.Job, _a1 error) *Store_ListJobsByStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListJobsByStatus_Call) RunAndReturn(run func(context.Context, params.JobStatus) ([]params.Job, error)) *Store_ListJobsByStatus_Call {
	_c.Call.Return(run)
	return _c
}

// ListOrganizations provides a mock function with given fields: ctx, filter
func (_m *Store) ListOrganizations(ctx context.Context, filter params.OrganizationFilter) ([]params.Organization, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for ListOrganizations")
	}

	var r0 []params.Organization
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.OrganizationFilter) ([]params.Organization, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.OrganizationFilter) []params.Organization); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Organization)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.OrganizationFilter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListOrganizations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListOrganizations'
type Store_ListOrganizations_Call struct {
	*mock.Call
}

// ListOrganizations is a helper method to define mock.On call
//   - ctx context.Context
//   - filter params.OrganizationFilter
func (_e *Store_Expecter) ListOrganizations(ctx interface{}, filter interface{}) *Store_ListOrganizations_Call {
	return &Store_ListOrganizations_Call{Call: _e.mock.On("ListOrganizations", ctx, filter)}
}

func (_c *Store_ListOrganizations_Call) Run(run func(ctx context.Context, filter params.OrganizationFilter)) *Store_ListOrganizations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.OrganizationFilter))
	})
	return _c
}

func (_c *Store_ListOrganizations_Call) Return(_a0 []params.Organization, _a1 error) *Store_ListOrganizations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListOrganizations_Call) RunAndReturn(run func(context.Context, params.OrganizationFilter) ([]params.Organization, error)) *Store_ListOrganizations_Call {
	_c.Call.Return(run)
	return _c
}

// ListPoolInstances provides a mock function with given fields: ctx, poolID
func (_m *Store) ListPoolInstances(ctx context.Context, poolID string) ([]params.Instance, error) {
	ret := _m.Called(ctx, poolID)

	if len(ret) == 0 {
		panic("no return value specified for ListPoolInstances")
	}

	var r0 []params.Instance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]params.Instance, error)); ok {
		return rf(ctx, poolID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []params.Instance); ok {
		r0 = rf(ctx, poolID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Instance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, poolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListPoolInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPoolInstances'
type Store_ListPoolInstances_Call struct {
	*mock.Call
}

// ListPoolInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - poolID string
func (_e *Store_Expecter) ListPoolInstances(ctx interface{}, poolID interface{}) *Store_ListPoolInstances_Call {
	return &Store_ListPoolInstances_Call{Call: _e.mock.On("ListPoolInstances", ctx, poolID)}
}

func (_c *Store_ListPoolInstances_Call) Run(run func(ctx context.Context, poolID string)) *Store_ListPoolInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_ListPoolInstances_Call) Return(_a0 []params.Instance, _a1 error) *Store_ListPoolInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListPoolInstances_Call) RunAndReturn(run func(context.Context, string) ([]params.Instance, error)) *Store_ListPoolInstances_Call {
	_c.Call.Return(run)
	return _c
}

// ListRepositories provides a mock function with given fields: ctx, filter
func (_m *Store) ListRepositories(ctx context.Context, filter params.RepositoryFilter) ([]params.Repository, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for ListRepositories")
	}

	var r0 []params.Repository
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.RepositoryFilter) ([]params.Repository, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.RepositoryFilter) []params.Repository); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Repository)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.RepositoryFilter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListRepositories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRepositories'
type Store_ListRepositories_Call struct {
	*mock.Call
}

// ListRepositories is a helper method to define mock.On call
//   - ctx context.Context
//   - filter params.RepositoryFilter
func (_e *Store_Expecter) ListRepositories(ctx interface{}, filter interface{}) *Store_ListRepositories_Call {
	return &Store_ListRepositories_Call{Call: _e.mock.On("ListRepositories", ctx, filter)}
}

func (_c *Store_ListRepositories_Call) Run(run func(ctx context.Context, filter params.RepositoryFilter)) *Store_ListRepositories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.RepositoryFilter))
	})
	return _c
}

func (_c *Store_ListRepositories_Call) Return(_a0 []params.Repository, _a1 error) *Store_ListRepositories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListRepositories_Call) RunAndReturn(run func(context.Context, params.RepositoryFilter) ([]params.Repository, error)) *Store_ListRepositories_Call {
	_c.Call.Return(run)
	return _c
}

// ListScaleSetInstances provides a mock function with given fields: _a0, scalesetID
func (_m *Store) ListScaleSetInstances(_a0 context.Context, scalesetID uint) ([]params.Instance, error) {
	ret := _m.Called(_a0, scalesetID)

	if len(ret) == 0 {
		panic("no return value specified for ListScaleSetInstances")
	}

	var r0 []params.Instance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) ([]params.Instance, error)); ok {
		return rf(_a0, scalesetID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint) []params.Instance); ok {
		r0 = rf(_a0, scalesetID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Instance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = rf(_a0, scalesetID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListScaleSetInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListScaleSetInstances'
type Store_ListScaleSetInstances_Call struct {
	*mock.Call
}

// ListScaleSetInstances is a helper method to define mock.On call
//   - _a0 context.Context
//   - scalesetID uint
func (_e *Store_Expecter) ListScaleSetInstances(_a0 interface{}, scalesetID interface{}) *Store_ListScaleSetInstances_Call {
	return &Store_ListScaleSetInstances_Call{Call: _e.mock.On("ListScaleSetInstances", _a0, scalesetID)}
}

func (_c *Store_ListScaleSetInstances_Call) Run(run func(_a0 context.Context, scalesetID uint)) *Store_ListScaleSetInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *Store_ListScaleSetInstances_Call) Return(_a0 []params.Instance, _a1 error) *Store_ListScaleSetInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListScaleSetInstances_Call) RunAndReturn(run func(context.Context, uint) ([]params.Instance, error)) *Store_ListScaleSetInstances_Call {
	_c.Call.Return(run)
	return _c
}

// ListTemplates provides a mock function with given fields: ctx, osType, forgeType, partialName
func (_m *Store) ListTemplates(ctx context.Context, osType *garm_provider_commonparams.OSType, forgeType *params.EndpointType, partialName *string) ([]params.Template, error) {
	ret := _m.Called(ctx, osType, forgeType, partialName)

	if len(ret) == 0 {
		panic("no return value specified for ListTemplates")
	}

	var r0 []params.Template
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *garm_provider_commonparams.OSType, *params.EndpointType, *string) ([]params.Template, error)); ok {
		return rf(ctx, osType, forgeType, partialName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *garm_provider_commonparams.OSType, *params.EndpointType, *string) []params.Template); ok {
		r0 = rf(ctx, osType, forgeType, partialName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]params.Template)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *garm_provider_commonparams.OSType, *params.EndpointType, *string) error); ok {
		r1 = rf(ctx, osType, forgeType, partialName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListTemplates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTemplates'
type Store_ListTemplates_Call struct {
	*mock.Call
}

// ListTemplates is a helper method to define mock.On call
//   - ctx context.Context
//   - osType *garm_provider_commonparams.OSType
//   - forgeType *params.EndpointType
//   - partialName *string
func (_e *Store_Expecter) ListTemplates(ctx interface{}, osType interface{}, forgeType interface{}, partialName interface{}) *Store_ListTemplates_Call {
	return &Store_ListTemplates_Call{Call: _e.mock.On("ListTemplates", ctx, osType, forgeType, partialName)}
}

func (_c *Store_ListTemplates_Call) Run(run func(ctx context.Context, osType *garm_provider_commonparams.OSType, forgeType *params.EndpointType, partialName *string)) *Store_ListTemplates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*garm_provider_commonparams.OSType), args[2].(*params.EndpointType), args[3].(*string))
	})
	return _c
}

func (_c *Store_ListTemplates_Call) Return(_a0 []params.Template, _a1 error) *Store_ListTemplates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListTemplates_Call) RunAndReturn(run func(context.Context, *garm_provider_commonparams.OSType, *params.EndpointType, *string) ([]params.Template, error)) *Store_ListTemplates_Call {
	_c.Call.Return(run)
	return _c
}

// LockJob provides a mock function with given fields: ctx, jobID, entityID
func (_m *Store) LockJob(ctx context.Context, jobID int64, entityID string) error {
	ret := _m.Called(ctx, jobID, entityID)

	if len(ret) == 0 {
		panic("no return value specified for LockJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) error); ok {
		r0 = rf(ctx, jobID, entityID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_LockJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockJob'
type Store_LockJob_Call struct {
	*mock.Call
}

// LockJob is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID int64
//   - entityID string
func (_e *Store_Expecter) LockJob(ctx interface{}, jobID interface{}, entityID interface{}) *Store_LockJob_Call {
	return &Store_LockJob_Call{Call: _e.mock.On("LockJob", ctx, jobID, entityID)}
}

func (_c *Store_LockJob_Call) Run(run func(ctx context.Context, jobID int64, entityID string)) *Store_LockJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string))
	})
	return _c
}

func (_c *Store_LockJob_Call) Return(_a0 error) *Store_LockJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_LockJob_Call) RunAndReturn(run func(context.Context, int64, string) error) *Store_LockJob_Call {
	_c.Call.Return(run)
	return _c
}

// OpenFileObjectContent provides a mock function with given fields: ctx, objID
func (_m *Store) OpenFileObjectContent(ctx context.Context, objID uint) (io.ReadCloser, error) {
	ret := _m.Called(ctx, objID)

	if len(ret) == 0 {
		panic("no return value specified for OpenFileObjectContent")
	}

	var r0 io.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) (io.ReadCloser, error)); ok {
		return rf(ctx, objID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint) io.ReadCloser); ok {
		r0 = rf(ctx, objID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = rf(ctx, objID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_OpenFileObjectContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenFileObjectContent'
type Store_OpenFileObjectContent_Call struct {
	*mock.Call
}

// OpenFileObjectContent is a helper method to define mock.On call
//   - ctx context.Context
//   - objID uint
func (_e *Store_Expecter) OpenFileObjectContent(ctx interface{}, objID interface{}) *Store_OpenFileObjectContent_Call {
	return &Store_OpenFileObjectContent_Call{Call: _e.mock.On("OpenFileObjectContent", ctx, objID)}
}

func (_c *Store_OpenFileObjectContent_Call) Run(run func(ctx context.Context, objID uint)) *Store_OpenFileObjectContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *Store_OpenFileObjectContent_Call) Return(_a0 io.ReadCloser, _a1 error) *Store_OpenFileObjectContent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_OpenFileObjectContent_Call) RunAndReturn(run func(context.Context, uint) (io.ReadCloser, error)) *Store_OpenFileObjectContent_Call {
	_c.Call.Return(run)
	return _c
}

// PoolInstanceCount provides a mock function with given fields: ctx, poolID
func (_m *Store) PoolInstanceCount(ctx context.Context, poolID string) (int64, error) {
	ret := _m.Called(ctx, poolID)

	if len(ret) == 0 {
		panic("no return value specified for PoolInstanceCount")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return rf(ctx, poolID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, poolID)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, poolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_PoolInstanceCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PoolInstanceCount'
type Store_PoolInstanceCount_Call struct {
	*mock.Call
}

// PoolInstanceCount is a helper method to define mock.On call
//   - ctx context.Context
//   - poolID string
func (_e *Store_Expecter) PoolInstanceCount(ctx interface{}, poolID interface{}) *Store_PoolInstanceCount_Call {
	return &Store_PoolInstanceCount_Call{Call: _e.mock.On("PoolInstanceCount", ctx, poolID)}
}

func (_c *Store_PoolInstanceCount_Call) Run(run func(ctx context.Context, poolID string)) *Store_PoolInstanceCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_PoolInstanceCount_Call) Return(_a0 int64, _a1 error) *Store_PoolInstanceCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_PoolInstanceCount_Call) RunAndReturn(run func(context.Context, string) (int64, error)) *Store_PoolInstanceCount_Call {
	_c.Call.Return(run)
	return _c
}

// SearchFileObjectByTags provides a mock function with given fields: ctx, tags, page, pageSize
func (_m *Store) SearchFileObjectByTags(ctx context.Context, tags []string, page uint64, pageSize uint64) (params.FileObjectPaginatedResponse, error) {
	ret := _m.Called(ctx, tags, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for SearchFileObjectByTags")
	}

	var r0 params.FileObjectPaginatedResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, uint64, uint64) (params.FileObjectPaginatedResponse, error)); ok {
		return rf(ctx, tags, page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, uint64, uint64) params.FileObjectPaginatedResponse); ok {
		r0 = rf(ctx, tags, page, pageSize)
	} else {
		r0 = ret.Get(0).(params.FileObjectPaginatedResponse)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, uint64, uint64) error); ok {
		r1 = rf(ctx, tags, page, pageSize)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_SearchFileObjectByTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchFileObjectByTags'
type Store_SearchFileObjectByTags_Call struct {
	*mock.Call
}

// SearchFileObjectByTags is a helper method to define mock.On call
//   - ctx context.Context
//   - tags []string
//   - page uint64
//   - pageSize uint64
func (_e *Store_Expecter) SearchFileObjectByTags(ctx interface{}, tags interface{}, page interface{}, pageSize interface{}) *Store_SearchFileObjectByTags_Call {
	return &Store_SearchFileObjectByTags_Call{Call: _e.mock.On("SearchFileObjectByTags", ctx, tags, page, pageSize)}
}

func (_c *Store_SearchFileObjectByTags_Call) Run(run func(ctx context.Context, tags []string, page uint64, pageSize uint64)) *Store_SearchFileObjectByTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(uint64), args[3].(uint64))
	})
	return _c
}

func (_c *Store_SearchFileObjectByTags_Call) Return(_a0 params.FileObjectPaginatedResponse, _a1 error) *Store_SearchFileObjectByTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_SearchFileObjectByTags_Call) RunAndReturn(run func(context.Context, []string, uint64, uint64) (params.FileObjectPaginatedResponse, error)) *Store_SearchFileObjectByTags_Call {
	_c.Call.Return(run)
	return _c
}

// SetScaleSetDesiredRunnerCount provides a mock function with given fields: ctx, scaleSetID, desiredRunnerCount
func (_m *Store) SetScaleSetDesiredRunnerCount(ctx context.Context, scaleSetID uint, desiredRunnerCount int) error {
	ret := _m.Called(ctx, scaleSetID, desiredRunnerCount)

	if len(ret) == 0 {
		panic("no return value specified for SetScaleSetDesiredRunnerCount")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, int) error); ok {
		r0 = rf(ctx, scaleSetID, desiredRunnerCount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_SetScaleSetDesiredRunnerCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetScaleSetDesiredRunnerCount'
type Store_SetScaleSetDesiredRunnerCount_Call struct {
	*mock.Call
}

// SetScaleSetDesiredRunnerCount is a helper method to define mock.On call
//   - ctx context.Context
//   - scaleSetID uint
//   - desiredRunnerCount int
func (_e *Store_Expecter) SetScaleSetDesiredRunnerCount(ctx interface{}, scaleSetID interface{}, desiredRunnerCount interface{}) *Store_SetScaleSetDesiredRunnerCount_Call {
	return &Store_SetScaleSetDesiredRunnerCount_Call{Call: _e.mock.On("SetScaleSetDesiredRunnerCount", ctx, scaleSetID, desiredRunnerCount)}
}

func (_c *Store_SetScaleSetDesiredRunnerCount_Call) Run(run func(ctx context.Context, scaleSetID uint, desiredRunnerCount int)) *Store_SetScaleSetDesiredRunnerCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(int))
	})
	return _c
}

func (_c *Store_SetScaleSetDesiredRunnerCount_Call) Return(_a0 error) *Store_SetScaleSetDesiredRunnerCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_SetScaleSetDesiredRunnerCount_Call) RunAndReturn(run func(context.Context, uint, int) error) *Store_SetScaleSetDesiredRunnerCount_Call {
	_c.Call.Return(run)
	return _c
}

// SetScaleSetLastMessageID provides a mock function with given fields: ctx, scaleSetID, lastMessageID
func (_m *Store) SetScaleSetLastMessageID(ctx context.Context, scaleSetID uint, lastMessageID int64) error {
	ret := _m.Called(ctx, scaleSetID, lastMessageID)

	if len(ret) == 0 {
		panic("no return value specified for SetScaleSetLastMessageID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, int64) error); ok {
		r0 = rf(ctx, scaleSetID, lastMessageID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_SetScaleSetLastMessageID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetScaleSetLastMessageID'
type Store_SetScaleSetLastMessageID_Call struct {
	*mock.Call
}

// SetScaleSetLastMessageID is a helper method to define mock.On call
//   - ctx context.Context
//   - scaleSetID uint
//   - lastMessageID int64
func (_e *Store_Expecter) SetScaleSetLastMessageID(ctx interface{}, scaleSetID interface{}, lastMessageID interface{}) *Store_SetScaleSetLastMessageID_Call {
	return &Store_SetScaleSetLastMessageID_Call{Call: _e.mock.On("SetScaleSetLastMessageID", ctx, scaleSetID, lastMessageID)}
}

func (_c *Store_SetScaleSetLastMessageID_Call) Run(run func(ctx context.Context, scaleSetID uint, lastMessageID int64)) *Store_SetScaleSetLastMessageID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(int64))
	})
	return _c
}

func (_c *Store_SetScaleSetLastMessageID_Call) Return(_a0 error) *Store_SetScaleSetLastMessageID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_SetScaleSetLastMessageID_Call) RunAndReturn(run func(context.Context, uint, int64) error) *Store_SetScaleSetLastMessageID_Call {
	_c.Call.Return(run)
	return _c
}

// UnlockJob provides a mock function with given fields: ctx, jobID, entityID
func (_m *Store) UnlockJob(ctx context.Context, jobID int64, entityID string) error {
	ret := _m.Called(ctx, jobID, entityID)

	if len(ret) == 0 {
		panic("no return value specified for UnlockJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) error); ok {
		r0 = rf(ctx, jobID, entityID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_UnlockJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlockJob'
type Store_UnlockJob_Call struct {
	*mock.Call
}

// UnlockJob is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID int64
//   - entityID string
func (_e *Store_Expecter) UnlockJob(ctx interface{}, jobID interface{}, entityID interface{}) *Store_UnlockJob_Call {
	return &Store_UnlockJob_Call{Call: _e.mock.On("UnlockJob", ctx, jobID, entityID)}
}

func (_c *Store_UnlockJob_Call) Run(run func(ctx context.Context, jobID int64, entityID string)) *Store_UnlockJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string))
	})
	return _c
}

func (_c *Store_UnlockJob_Call) Return(_a0 error) *Store_UnlockJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_UnlockJob_Call) RunAndReturn(run func(context.Context, int64, string) error) *Store_UnlockJob_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateController provides a mock function with given fields: info
func (_m *Store) UpdateController(info params.UpdateControllerParams) (params.ControllerInfo, error) {
	ret := _m.Called(info)

	if len(ret) == 0 {
		panic("no return value specified for UpdateController")
	}

	var r0 params.ControllerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(params.UpdateControllerParams) (params.ControllerInfo, error)); ok {
		return rf(info)
	}
	if rf, ok := ret.Get(0).(func(params.UpdateControllerParams) params.ControllerInfo); ok {
		r0 = rf(info)
	} else {
		r0 = ret.Get(0).(params.ControllerInfo)
	}

	if rf, ok := ret.Get(1).(func(params.UpdateControllerParams) error); ok {
		r1 = rf(info)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateController_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateController'
type Store_UpdateController_Call struct {
	*mock.Call
}

// UpdateController is a helper method to define mock.On call
//   - info params.UpdateControllerParams
func (_e *Store_Expecter) UpdateController(info interface{}) *Store_UpdateController_Call {
	return &Store_UpdateController_Call{Call: _e.mock.On("UpdateController", info)}
}

func (_c *Store_UpdateController_Call) Run(run func(info params.UpdateControllerParams)) *Store_UpdateController_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(params.UpdateControllerParams))
	})
	return _c
}

func (_c *Store_UpdateController_Call) Return(_a0 params.ControllerInfo, _a1 error) *Store_UpdateController_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_UpdateController_Call) RunAndReturn(run func(params.UpdateControllerParams) (params.ControllerInfo, error)) *Store_UpdateController_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEnterprise provides a mock function with given fields: ctx, enterpriseID, param
func (_m *Store) UpdateEnterprise(ctx context.Context, enterpriseID string, param params.UpdateEntityParams) (params.Enterprise, error) {
	ret := _m.Called(ctx, enterpriseID, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEnterprise")
	}

	var r0 params.Enterprise
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateEntityParams) (params.Enterprise, error)); ok {
		return rf(ctx, enterpriseID, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateEntityParams) params.Enterprise); ok {
		r0 = rf(ctx, enterpriseID, param)
	} else {
		r0 = ret.Get(0).(params.Enterprise)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, params.UpdateEntityParams) error); ok {
		r1 = rf(ctx, enterpriseID, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateEnterprise_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEnterprise'
type Store_UpdateEnterprise_Call struct {
	*mock.Call
}

// UpdateEnterprise is a helper method to define mock.On call
//   - ctx context.Context
//   - enterpriseID string
//   - param params.UpdateEntityParams
func (_e *Store_Expecter) UpdateEnterprise(ctx interface{}, enterpriseID interface{}, param interface{}) *Store_UpdateEnterprise_Call {
	return &Store_UpdateEnterprise_Call{Call: _e.mock.On("UpdateEnterprise", ctx, enterpriseID, param)}
}

func (_c *Store_UpdateEnterprise_Call) Run(run func(ctx context.Context, enterpriseID string, param params.UpdateEntityParams)) *Store_UpdateEnterprise_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.UpdateEntityParams))
	})
	return _c
}

func (_c *Store_UpdateEnterprise_Call) Return(_a0 params.Enterprise, _a1 error) *Store_UpdateEnterprise_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_UpdateEnterprise_Call) RunAndReturn(run func(context.Context, string, params.UpdateEntityParams) (params.Enterprise, error)) *Store_UpdateEnterprise_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEntityPool provides a mock function with given fields: ctx, entity, poolID, param
func (_m *Store) UpdateEntityPool(ctx context.Context, entity params.ForgeEntity, poolID string, param params.UpdatePoolParams) (params.Pool, error) {
	ret := _m.Called(ctx, entity, poolID, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEntityPool")
	}

	var r0 params.Pool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, string, params.UpdatePoolParams) (params.Pool, error)); ok {
		return rf(ctx, entity, poolID, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, string, params.UpdatePoolParams) params.Pool); ok {
		r0 = rf(ctx, entity, poolID, param)
	} else {
		r0 = ret.Get(0).(params.Pool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.ForgeEntity, string, params.UpdatePoolParams) error); ok {
		r1 = rf(ctx, entity, poolID, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateEntityPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEntityPool'
type Store_UpdateEntityPool_Call struct {
	*mock.Call
}

// UpdateEntityPool is a helper method to define mock.On call
//   - ctx context.Context
//   - entity params.ForgeEntity
//   - poolID string
//   - param params.UpdatePoolParams
func (_e *Store_Expecter) UpdateEntityPool(ctx interface{}, entity interface{}, poolID interface{}, param interface{}) *Store_UpdateEntityPool_Call {
	return &Store_UpdateEntityPool_Call{Call: _e.mock.On("UpdateEntityPool", ctx, entity, poolID, param)}
}

func (_c *Store_UpdateEntityPool_Call) Run(run func(ctx context.Context, entity params.ForgeEntity, poolID string, param params.UpdatePoolParams)) *Store_UpdateEntityPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntity), args[2].(string), args[3].(params.UpdatePoolParams))
	})
	return _c
}

func (_c *Store_UpdateEntityPool_Call) Return(_a0 params.Pool, _a1 error) *Store_UpdateEntityPool_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_UpdateEntityPool_Call) RunAndReturn(run func(context.Context, params.ForgeEntity, string, params.UpdatePoolParams) (params.Pool, error)) *Store_UpdateEntityPool_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEntityScaleSet provides a mock function with given fields: _a0, entity, scaleSetID, param, callback
func (_m *Store) UpdateEntityScaleSet(_a0 context.Context, entity params.ForgeEntity, scaleSetID uint, param params.UpdateScaleSetParams, callback func(params.ScaleSet, params.ScaleSet) error) (params.ScaleSet, error) {
	ret := _m.Called(_a0, entity, scaleSetID, param, callback)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEntityScaleSet")
	}

	var r0 params.ScaleSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, uint, params.UpdateScaleSetParams, func(params.ScaleSet, params.ScaleSet) error) (params.ScaleSet, error)); ok {
		return rf(_a0, entity, scaleSetID, param, callback)
	}
	if rf, ok := ret.Get(0).(func(context.Context, params.ForgeEntity, uint, params.UpdateScaleSetParams, func(params.ScaleSet, params.ScaleSet) error) params.ScaleSet); ok {
		r0 = rf(_a0, entity, scaleSetID, param, callback)
	} else {
		r0 = ret.Get(0).(params.ScaleSet)
	}

	if rf, ok := ret.Get(1).(func(context.Context, params.ForgeEntity, uint, params.UpdateScaleSetParams, func(params.ScaleSet, params.ScaleSet) error) error); ok {
		r1 = rf(_a0, entity, scaleSetID, param, callback)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateEntityScaleSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEntityScaleSet'
type Store_UpdateEntityScaleSet_Call struct {
	*mock.Call
}

// UpdateEntityScaleSet is a helper method to define mock.On call
//   - _a0 context.Context
//   - entity params.ForgeEntity
//   - scaleSetID uint
//   - param params.UpdateScaleSetParams
//   - callback func(params.ScaleSet , params.ScaleSet) error
func (_e *Store_Expecter) UpdateEntityScaleSet(_a0 interface{}, entity interface{}, scaleSetID interface{}, param interface{}, callback interface{}) *Store_UpdateEntityScaleSet_Call {
	return &Store_UpdateEntityScaleSet_Call{Call: _e.mock.On("UpdateEntityScaleSet", _a0, entity, scaleSetID, param, callback)}
}

func (_c *Store_UpdateEntityScaleSet_Call) Run(run func(_a0 context.Context, entity params.ForgeEntity, scaleSetID uint, param params.UpdateScaleSetParams, callback func(params.ScaleSet, params.ScaleSet) error)) *Store_UpdateEntityScaleSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(params.ForgeEntity), args[2].(uint), args[3].(params.UpdateScaleSetParams), args[4].(func(params.ScaleSet, params.ScaleSet) error))
	})
	return _c
}

func (_c *Store_UpdateEntityScaleSet_Call) Return(updatedScaleSet params.ScaleSet, err error) *Store_UpdateEntityScaleSet_Call {
	_c.Call.Return(updatedScaleSet, err)
	return _c
}

func (_c *Store_UpdateEntityScaleSet_Call) RunAndReturn(run func(context.Context, params.ForgeEntity, uint, params.UpdateScaleSetParams, func(params.ScaleSet, params.ScaleSet) error) (params.ScaleSet, error)) *Store_UpdateEntityScaleSet_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateFileObject provides a mock function with given fields: ctx, objID, param
func (_m *Store) UpdateFileObject(ctx context.Context, objID uint, param params.UpdateFileObjectParams) (params.FileObject, error) {
	ret := _m.Called(ctx, objID, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFileObject")
	}

	var r0 params.FileObject
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, params.UpdateFileObjectParams) (params.FileObject, error)); ok {
		return rf(ctx, objID, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, params.UpdateFileObjectParams) params.FileObject); ok {
		r0 = rf(ctx, objID, param)
	} else {
		r0 = ret.Get(0).(params.FileObject)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, params.UpdateFileObjectParams) error); ok {
		r1 = rf(ctx, objID, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateFileObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateFileObject'
type Store_UpdateFileObject_Call struct {
	*mock.Call
}

// UpdateFileObject is a helper method to define mock.On call
//   - ctx context.Context
//   - objID uint
//   - param params.UpdateFileObjectParams
func (_e *Store_Expecter) UpdateFileObject(ctx interface{}, objID interface{}, param interface{}) *Store_UpdateFileObject_Call {
	return &Store_UpdateFileObject_Call{Call: _e.mock.On("UpdateFileObject", ctx, objID, param)}
}

func (_c *Store_UpdateFileObject_Call) Run(run func(ctx context.Context, objID uint, param params.UpdateFileObjectParams)) *Store_UpdateFileObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(params.UpdateFileObjectParams))
	})
	return _c
}

func (_c *Store_UpdateFileObject_Call) Return(_a0 params.FileObject, _a1 error) *Store_UpdateFileObject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_UpdateFileObject_Call) RunAndReturn(run func(context.Context, uint, params.UpdateFileObjectParams) (params.FileObject, error)) *Store_UpdateFileObject_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGiteaCredentials provides a mock function with given fields: ctx, id, param
func (_m *Store) UpdateGiteaCredentials(ctx context.Context, id uint, param params.UpdateGiteaCredentialsParams) (params.ForgeCredentials, error) {
	ret := _m.Called(ctx, id, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGiteaCredentials")
	}

	var r0 params.ForgeCredentials
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, params.UpdateGiteaCredentialsParams) (params.ForgeCredentials, error)); ok {
		return rf(ctx, id, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, params.UpdateGiteaCredentialsParams) params.ForgeCredentials); ok {
		r0 = rf(ctx, id, param)
	} else {
		r0 = ret.Get(0).(params.ForgeCredentials)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, params.UpdateGiteaCredentialsParams) error); ok {
		r1 = rf(ctx, id, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateGiteaCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGiteaCredentials'
type Store_UpdateGiteaCredentials_Call struct {
	*mock.Call
}

// UpdateGiteaCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint
//   - param params.UpdateGiteaCredentialsParams
func (_e *Store_Expecter) UpdateGiteaCredentials(ctx interface{}, id interface{}, param interface{}) *Store_UpdateGiteaCredentials_Call {
	return &Store_UpdateGiteaCredentials_Call{Call: _e.mock.On("UpdateGiteaCredentials", ctx, id, param)}
}

func (_c *Store_UpdateGiteaCredentials_Call) Run(run func(ctx context.Context, id uint, param params.UpdateGiteaCredentialsParams)) *Store_UpdateGiteaCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(params.UpdateGiteaCredentialsParams))
	})
	return _c
}

func (_c *Store_UpdateGiteaCredentials_Call) Return(gtCreds params.ForgeCredentials, err error) *Store_UpdateGiteaCredentials_Call {
	_c.Call.Return(gtCreds, err)
	return _c
}

func (_c *Store_UpdateGiteaCredentials_Call) RunAndReturn(run func(context.Context, uint, params.UpdateGiteaCredentialsParams) (params.ForgeCredentials, error)) *Store_UpdateGiteaCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGiteaEndpoint provides a mock function with given fields: _a0, name, param
func (_m *Store) UpdateGiteaEndpoint(_a0 context.Context, name string, param params.UpdateGiteaEndpointParams) (params.ForgeEndpoint, error) {
	ret := _m.Called(_a0, name, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGiteaEndpoint")
	}

	var r0 params.ForgeEndpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateGiteaEndpointParams) (params.ForgeEndpoint, error)); ok {
		return rf(_a0, name, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateGiteaEndpointParams) params.ForgeEndpoint); ok {
		r0 = rf(_a0, name, param)
	} else {
		r0 = ret.Get(0).(params.ForgeEndpoint)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, params.UpdateGiteaEndpointParams) error); ok {
		r1 = rf(_a0, name, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateGiteaEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGiteaEndpoint'
type Store_UpdateGiteaEndpoint_Call struct {
	*mock.Call
}

// UpdateGiteaEndpoint is a helper method to define mock.On call
//   - _a0 context.Context
//   - name string
//   - param params.UpdateGiteaEndpointParams
func (_e *Store_Expecter) UpdateGiteaEndpoint(_a0 interface{}, name interface{}, param interface{}) *Store_UpdateGiteaEndpoint_Call {
	return &Store_UpdateGiteaEndpoint_Call{Call: _e.mock.On("UpdateGiteaEndpoint", _a0, name, param)}
}

func (_c *Store_UpdateGiteaEndpoint_Call) Run(run func(_a0 context.Context, name string, param params.UpdateGiteaEndpointParams)) *Store_UpdateGiteaEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.UpdateGiteaEndpointParams))
	})
	return _c
}

func (_c *Store_UpdateGiteaEndpoint_Call) Return(ghEndpoint params.ForgeEndpoint, err error) *Store_UpdateGiteaEndpoint_Call {
	_c.Call.Return(ghEndpoint, err)
	return _c
}

func (_c *Store_UpdateGiteaEndpoint_Call) RunAndReturn(run func(context.Context, string, params.UpdateGiteaEndpointParams) (params.ForgeEndpoint, error)) *Store_UpdateGiteaEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGithubCredentials provides a mock function with given fields: ctx, id, param
func (_m *Store) UpdateGithubCredentials(ctx context.Context, id uint, param params.UpdateGithubCredentialsParams) (params.ForgeCredentials, error) {
	ret := _m.Called(ctx, id, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGithubCredentials")
	}

	var r0 params.ForgeCredentials
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, params.UpdateGithubCredentialsParams) (params.ForgeCredentials, error)); ok {
		return rf(ctx, id, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, params.UpdateGithubCredentialsParams) params.ForgeCredentials); ok {
		r0 = rf(ctx, id, param)
	} else {
		r0 = ret.Get(0).(params.ForgeCredentials)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, params.UpdateGithubCredentialsParams) error); ok {
		r1 = rf(ctx, id, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateGithubCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGithubCredentials'
type Store_UpdateGithubCredentials_Call struct {
	*mock.Call
}

// UpdateGithubCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint
//   - param params.UpdateGithubCredentialsParams
func (_e *Store_Expecter) UpdateGithubCredentials(ctx interface{}, id interface{}, param interface{}) *Store_UpdateGithubCredentials_Call {
	return &Store_UpdateGithubCredentials_Call{Call: _e.mock.On("UpdateGithubCredentials", ctx, id, param)}
}

func (_c *Store_UpdateGithubCredentials_Call) Run(run func(ctx context.Context, id uint, param params.UpdateGithubCredentialsParams)) *Store_UpdateGithubCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(params.UpdateGithubCredentialsParams))
	})
	return _c
}

func (_c *Store_UpdateGithubCredentials_Call) Return(_a0 params.ForgeCredentials, _a1 error) *Store_UpdateGithubCredentials_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_UpdateGithubCredentials_Call) RunAndReturn(run func(context.Context, uint, params.UpdateGithubCredentialsParams) (params.ForgeCredentials, error)) *Store_UpdateGithubCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGithubEndpoint provides a mock function with given fields: ctx, name, param
func (_m *Store) UpdateGithubEndpoint(ctx context.Context, name string, param params.UpdateGithubEndpointParams) (params.ForgeEndpoint, error) {
	ret := _m.Called(ctx, name, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGithubEndpoint")
	}

	var r0 params.ForgeEndpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateGithubEndpointParams) (params.ForgeEndpoint, error)); ok {
		return rf(ctx, name, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateGithubEndpointParams) params.ForgeEndpoint); ok {
		r0 = rf(ctx, name, param)
	} else {
		r0 = ret.Get(0).(params.ForgeEndpoint)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, params.UpdateGithubEndpointParams) error); ok {
		r1 = rf(ctx, name, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateGithubEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGithubEndpoint'
type Store_UpdateGithubEndpoint_Call struct {
	*mock.Call
}

// UpdateGithubEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - param params.UpdateGithubEndpointParams
func (_e *Store_Expecter) UpdateGithubEndpoint(ctx interface{}, name interface{}, param interface{}) *Store_UpdateGithubEndpoint_Call {
	return &Store_UpdateGithubEndpoint_Call{Call: _e.mock.On("UpdateGithubEndpoint", ctx, name, param)}
}

func (_c *Store_UpdateGithubEndpoint_Call) Run(run func(ctx context.Context, name string, param params.UpdateGithubEndpointParams)) *Store_UpdateGithubEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.UpdateGithubEndpointParams))
	})
	return _c
}

func (_c *Store_UpdateGithubEndpoint_Call) Return(_a0 params.ForgeEndpoint, _a1 error) *Store_UpdateGithubEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_UpdateGithubEndpoint_Call) RunAndReturn(run func(context.Context, string, params.UpdateGithubEndpointParams) (params.ForgeEndpoint, error)) *Store_UpdateGithubEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateInstance provides a mock function with given fields: ctx, instanceNameOrID, param
func (_m *Store) UpdateInstance(ctx context.Context, instanceNameOrID string, param params.UpdateInstanceParams) (params.Instance, error) {
	ret := _m.Called(ctx, instanceNameOrID, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateInstance")
	}

	var r0 params.Instance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateInstanceParams) (params.Instance, error)); ok {
		return rf(ctx, instanceNameOrID, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateInstanceParams) params.Instance); ok {
		r0 = rf(ctx, instanceNameOrID, param)
	} else {
		r0 = ret.Get(0).(params.Instance)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, params.UpdateInstanceParams) error); ok {
		r1 = rf(ctx, instanceNameOrID, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateInstance'
type Store_UpdateInstance_Call struct {
	*mock.Call
}

// UpdateInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - instanceNameOrID string
//   - param params.UpdateInstanceParams
func (_e *Store_Expecter) UpdateInstance(ctx interface{}, instanceNameOrID interface{}, param interface{}) *Store_UpdateInstance_Call {
	return &Store_UpdateInstance_Call{Call: _e.mock.On("UpdateInstance", ctx, instanceNameOrID, param)}
}

func (_c *Store_UpdateInstance_Call) Run(run func(ctx context.Context, instanceNameOrID string, param params.UpdateInstanceParams)) *Store_UpdateInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.UpdateInstanceParams))
	})
	return _c
}

func (_c *Store_UpdateInstance_Call) Return(_a0 params.Instance, _a1 error) *Store_UpdateInstance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_UpdateInstance_Call) RunAndReturn(run func(context.Context, string, params.UpdateInstanceParams) (params.Instance, error)) *Store_UpdateInstance_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateOrganization provides a mock function with given fields: ctx, orgID, param
func (_m *Store) UpdateOrganization(ctx context.Context, orgID string, param params.UpdateEntityParams) (params.Organization, error) {
	ret := _m.Called(ctx, orgID, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOrganization")
	}

	var r0 params.Organization
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateEntityParams) (params.Organization, error)); ok {
		return rf(ctx, orgID, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateEntityParams) params.Organization); ok {
		r0 = rf(ctx, orgID, param)
	} else {
		r0 = ret.Get(0).(params.Organization)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, params.UpdateEntityParams) error); ok {
		r1 = rf(ctx, orgID, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateOrganization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateOrganization'
type Store_UpdateOrganization_Call struct {
	*mock.Call
}

// UpdateOrganization is a helper method to define mock.On call
//   - ctx context.Context
//   - orgID string
//   - param params.UpdateEntityParams
func (_e *Store_Expecter) UpdateOrganization(ctx interface{}, orgID interface{}, param interface{}) *Store_UpdateOrganization_Call {
	return &Store_UpdateOrganization_Call{Call: _e.mock.On("UpdateOrganization", ctx, orgID, param)}
}

func (_c *Store_UpdateOrganization_Call) Run(run func(ctx context.Context, orgID string, param params.UpdateEntityParams)) *Store_UpdateOrganization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.UpdateEntityParams))
	})
	return _c
}

func (_c *Store_UpdateOrganization_Call) Return(_a0 params.Organization, _a1 error) *Store_UpdateOrganization_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_UpdateOrganization_Call) RunAndReturn(run func(context.Context, string, params.UpdateEntityParams) (params.Organization, error)) *Store_UpdateOrganization_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRepository provides a mock function with given fields: ctx, repoID, param
func (_m *Store) UpdateRepository(ctx context.Context, repoID string, param params.UpdateEntityParams) (params.Repository, error) {
	ret := _m.Called(ctx, repoID, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRepository")
	}

	var r0 params.Repository
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateEntityParams) (params.Repository, error)); ok {
		return rf(ctx, repoID, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateEntityParams) params.Repository); ok {
		r0 = rf(ctx, repoID, param)
	} else {
		r0 = ret.Get(0).(params.Repository)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, params.UpdateEntityParams) error); ok {
		r1 = rf(ctx, repoID, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRepository'
type Store_UpdateRepository_Call struct {
	*mock.Call
}

// UpdateRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - repoID string
//   - param params.UpdateEntityParams
func (_e *Store_Expecter) UpdateRepository(ctx interface{}, repoID interface{}, param interface{}) *Store_UpdateRepository_Call {
	return &Store_UpdateRepository_Call{Call: _e.mock.On("UpdateRepository", ctx, repoID, param)}
}

func (_c *Store_UpdateRepository_Call) Run(run func(ctx context.Context, repoID string, param params.UpdateEntityParams)) *Store_UpdateRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.UpdateEntityParams))
	})
	return _c
}

func (_c *Store_UpdateRepository_Call) Return(_a0 params.Repository, _a1 error) *Store_UpdateRepository_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_UpdateRepository_Call) RunAndReturn(run func(context.Context, string, params.UpdateEntityParams) (params.Repository, error)) *Store_UpdateRepository_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTemplate provides a mock function with given fields: ctx, id, param
func (_m *Store) UpdateTemplate(ctx context.Context, id uint, param params.UpdateTemplateParams) (params.Template, error) {
	ret := _m.Called(ctx, id, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTemplate")
	}

	var r0 params.Template
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, params.UpdateTemplateParams) (params.Template, error)); ok {
		return rf(ctx, id, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, params.UpdateTemplateParams) params.Template); ok {
		r0 = rf(ctx, id, param)
	} else {
		r0 = ret.Get(0).(params.Template)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, params.UpdateTemplateParams) error); ok {
		r1 = rf(ctx, id, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTemplate'
type Store_UpdateTemplate_Call struct {
	*mock.Call
}

// UpdateTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint
//   - param params.UpdateTemplateParams
func (_e *Store_Expecter) UpdateTemplate(ctx interface{}, id interface{}, param interface{}) *Store_UpdateTemplate_Call {
	return &Store_UpdateTemplate_Call{Call: _e.mock.On("UpdateTemplate", ctx, id, param)}
}

func (_c *Store_UpdateTemplate_Call) Run(run func(ctx context.Context, id uint, param params.UpdateTemplateParams)) *Store_UpdateTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(params.UpdateTemplateParams))
	})
	return _c
}

func (_c *Store_UpdateTemplate_Call) Return(template params.Template, err error) *Store_UpdateTemplate_Call {
	_c.Call.Return(template, err)
	return _c
}

func (_c *Store_UpdateTemplate_Call) RunAndReturn(run func(context.Context, uint, params.UpdateTemplateParams) (params.Template, error)) *Store_UpdateTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function with given fields: ctx, user, param
func (_m *Store) UpdateUser(ctx context.Context, user string, param params.UpdateUserParams) (params.User, error) {
	ret := _m.Called(ctx, user, param)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 params.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateUserParams) (params.User, error)); ok {
		return rf(ctx, user, param)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, params.UpdateUserParams) params.User); ok {
		r0 = rf(ctx, user, param)
	} else {
		r0 = ret.Get(0).(params.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, params.UpdateUserParams) error); ok {
		r1 = rf(ctx, user, param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type Store_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user string
//   - param params.UpdateUserParams
func (_e *Store_Expecter) UpdateUser(ctx interface{}, user interface{}, param interface{}) *Store_UpdateUser_Call {
	return &Store_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, user, param)}
}

func (_c *Store_UpdateUser_Call) Run(run func(ctx context.Context, user string, param params.UpdateUserParams)) *Store_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.UpdateUserParams))
	})
	return _c
}

func (_c *Store_UpdateUser_Call) Return(_a0 params.User, _a1 error) *Store_UpdateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_UpdateUser_Call) RunAndReturn(run func(context.Context, string, params.UpdateUserParams) (params.User, error)) *Store_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewStore creates a new instance of Store. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *Store {
	mock := &Store{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
