// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	github "github.com/google/go-github/v72/github"
	mock "github.com/stretchr/testify/mock"

	params "github.com/cloudbase/garm/params"

	url "net/url"
)

// GithubEntityOperations is an autogenerated mock type for the GithubEntityOperations type
type GithubEntityOperations struct {
	mock.Mock
}

type GithubEntityOperations_Expecter struct {
	mock *mock.Mock
}

func (_m *GithubEntityOperations) EXPECT() *GithubEntityOperations_Expecter {
	return &GithubEntityOperations_Expecter{mock: &_m.Mock}
}

// CreateEntityHook provides a mock function with given fields: ctx, hook
func (_m *GithubEntityOperations) CreateEntityHook(ctx context.Context, hook *github.Hook) (*github.Hook, error) {
	ret := _m.Called(ctx, hook)

	if len(ret) == 0 {
		panic("no return value specified for CreateEntityHook")
	}

	var r0 *github.Hook
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *github.Hook) (*github.Hook, error)); ok {
		return rf(ctx, hook)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *github.Hook) *github.Hook); ok {
		r0 = rf(ctx, hook)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Hook)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *github.Hook) error); ok {
		r1 = rf(ctx, hook)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubEntityOperations_CreateEntityHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEntityHook'
type GithubEntityOperations_CreateEntityHook_Call struct {
	*mock.Call
}

// CreateEntityHook is a helper method to define mock.On call
//   - ctx context.Context
//   - hook *github.Hook
func (_e *GithubEntityOperations_Expecter) CreateEntityHook(ctx interface{}, hook interface{}) *GithubEntityOperations_CreateEntityHook_Call {
	return &GithubEntityOperations_CreateEntityHook_Call{Call: _e.mock.On("CreateEntityHook", ctx, hook)}
}

func (_c *GithubEntityOperations_CreateEntityHook_Call) Run(run func(ctx context.Context, hook *github.Hook)) *GithubEntityOperations_CreateEntityHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*github.Hook))
	})
	return _c
}

func (_c *GithubEntityOperations_CreateEntityHook_Call) Return(ret *github.Hook, err error) *GithubEntityOperations_CreateEntityHook_Call {
	_c.Call.Return(ret, err)
	return _c
}

func (_c *GithubEntityOperations_CreateEntityHook_Call) RunAndReturn(run func(context.Context, *github.Hook) (*github.Hook, error)) *GithubEntityOperations_CreateEntityHook_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEntityRegistrationToken provides a mock function with given fields: ctx
func (_m *GithubEntityOperations) CreateEntityRegistrationToken(ctx context.Context) (*github.RegistrationToken, *github.Response, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CreateEntityRegistrationToken")
	}

	var r0 *github.RegistrationToken
	var r1 *github.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context) (*github.RegistrationToken, *github.Response, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *github.RegistrationToken); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.RegistrationToken)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) *github.Response); ok {
		r1 = rf(ctx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GithubEntityOperations_CreateEntityRegistrationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEntityRegistrationToken'
type GithubEntityOperations_CreateEntityRegistrationToken_Call struct {
	*mock.Call
}

// CreateEntityRegistrationToken is a helper method to define mock.On call
//   - ctx context.Context
func (_e *GithubEntityOperations_Expecter) CreateEntityRegistrationToken(ctx interface{}) *GithubEntityOperations_CreateEntityRegistrationToken_Call {
	return &GithubEntityOperations_CreateEntityRegistrationToken_Call{Call: _e.mock.On("CreateEntityRegistrationToken", ctx)}
}

func (_c *GithubEntityOperations_CreateEntityRegistrationToken_Call) Run(run func(ctx context.Context)) *GithubEntityOperations_CreateEntityRegistrationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *GithubEntityOperations_CreateEntityRegistrationToken_Call) Return(_a0 *github.RegistrationToken, _a1 *github.Response, _a2 error) *GithubEntityOperations_CreateEntityRegistrationToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GithubEntityOperations_CreateEntityRegistrationToken_Call) RunAndReturn(run func(context.Context) (*github.RegistrationToken, *github.Response, error)) *GithubEntityOperations_CreateEntityRegistrationToken_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEntityHook provides a mock function with given fields: ctx, id
func (_m *GithubEntityOperations) DeleteEntityHook(ctx context.Context, id int64) (*github.Response, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEntityHook")
	}

	var r0 *github.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*github.Response, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *github.Response); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubEntityOperations_DeleteEntityHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEntityHook'
type GithubEntityOperations_DeleteEntityHook_Call struct {
	*mock.Call
}

// DeleteEntityHook is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *GithubEntityOperations_Expecter) DeleteEntityHook(ctx interface{}, id interface{}) *GithubEntityOperations_DeleteEntityHook_Call {
	return &GithubEntityOperations_DeleteEntityHook_Call{Call: _e.mock.On("DeleteEntityHook", ctx, id)}
}

func (_c *GithubEntityOperations_DeleteEntityHook_Call) Run(run func(ctx context.Context, id int64)) *GithubEntityOperations_DeleteEntityHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *GithubEntityOperations_DeleteEntityHook_Call) Return(ret *github.Response, err error) *GithubEntityOperations_DeleteEntityHook_Call {
	_c.Call.Return(ret, err)
	return _c
}

func (_c *GithubEntityOperations_DeleteEntityHook_Call) RunAndReturn(run func(context.Context, int64) (*github.Response, error)) *GithubEntityOperations_DeleteEntityHook_Call {
	_c.Call.Return(run)
	return _c
}

// GetEntity provides a mock function with no fields
func (_m *GithubEntityOperations) GetEntity() params.ForgeEntity {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetEntity")
	}

	var r0 params.ForgeEntity
	if rf, ok := ret.Get(0).(func() params.ForgeEntity); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(params.ForgeEntity)
	}

	return r0
}

// GithubEntityOperations_GetEntity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEntity'
type GithubEntityOperations_GetEntity_Call struct {
	*mock.Call
}

// GetEntity is a helper method to define mock.On call
func (_e *GithubEntityOperations_Expecter) GetEntity() *GithubEntityOperations_GetEntity_Call {
	return &GithubEntityOperations_GetEntity_Call{Call: _e.mock.On("GetEntity")}
}

func (_c *GithubEntityOperations_GetEntity_Call) Run(run func()) *GithubEntityOperations_GetEntity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GithubEntityOperations_GetEntity_Call) Return(_a0 params.ForgeEntity) *GithubEntityOperations_GetEntity_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GithubEntityOperations_GetEntity_Call) RunAndReturn(run func() params.ForgeEntity) *GithubEntityOperations_GetEntity_Call {
	_c.Call.Return(run)
	return _c
}

// GetEntityHook provides a mock function with given fields: ctx, id
func (_m *GithubEntityOperations) GetEntityHook(ctx context.Context, id int64) (*github.Hook, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetEntityHook")
	}

	var r0 *github.Hook
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*github.Hook, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *github.Hook); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Hook)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubEntityOperations_GetEntityHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEntityHook'
type GithubEntityOperations_GetEntityHook_Call struct {
	*mock.Call
}

// GetEntityHook is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *GithubEntityOperations_Expecter) GetEntityHook(ctx interface{}, id interface{}) *GithubEntityOperations_GetEntityHook_Call {
	return &GithubEntityOperations_GetEntityHook_Call{Call: _e.mock.On("GetEntityHook", ctx, id)}
}

func (_c *GithubEntityOperations_GetEntityHook_Call) Run(run func(ctx context.Context, id int64)) *GithubEntityOperations_GetEntityHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *GithubEntityOperations_GetEntityHook_Call) Return(ret *github.Hook, err error) *GithubEntityOperations_GetEntityHook_Call {
	_c.Call.Return(ret, err)
	return _c
}

func (_c *GithubEntityOperations_GetEntityHook_Call) RunAndReturn(run func(context.Context, int64) (*github.Hook, error)) *GithubEntityOperations_GetEntityHook_Call {
	_c.Call.Return(run)
	return _c
}

// GetEntityJITConfig provides a mock function with given fields: ctx, instance, pool, labels
func (_m *GithubEntityOperations) GetEntityJITConfig(ctx context.Context, instance string, pool params.Pool, labels []string) (map[string]string, *github.Runner, error) {
	ret := _m.Called(ctx, instance, pool, labels)

	if len(ret) == 0 {
		panic("no return value specified for GetEntityJITConfig")
	}

	var r0 map[string]string
	var r1 *github.Runner
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, params.Pool, []string) (map[string]string, *github.Runner, error)); ok {
		return rf(ctx, instance, pool, labels)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, params.Pool, []string) map[string]string); ok {
		r0 = rf(ctx, instance, pool, labels)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, params.Pool, []string) *github.Runner); ok {
		r1 = rf(ctx, instance, pool, labels)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Runner)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, params.Pool, []string) error); ok {
		r2 = rf(ctx, instance, pool, labels)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GithubEntityOperations_GetEntityJITConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEntityJITConfig'
type GithubEntityOperations_GetEntityJITConfig_Call struct {
	*mock.Call
}

// GetEntityJITConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - instance string
//   - pool params.Pool
//   - labels []string
func (_e *GithubEntityOperations_Expecter) GetEntityJITConfig(ctx interface{}, instance interface{}, pool interface{}, labels interface{}) *GithubEntityOperations_GetEntityJITConfig_Call {
	return &GithubEntityOperations_GetEntityJITConfig_Call{Call: _e.mock.On("GetEntityJITConfig", ctx, instance, pool, labels)}
}

func (_c *GithubEntityOperations_GetEntityJITConfig_Call) Run(run func(ctx context.Context, instance string, pool params.Pool, labels []string)) *GithubEntityOperations_GetEntityJITConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(params.Pool), args[3].([]string))
	})
	return _c
}

func (_c *GithubEntityOperations_GetEntityJITConfig_Call) Return(jitConfigMap map[string]string, runner *github.Runner, err error) *GithubEntityOperations_GetEntityJITConfig_Call {
	_c.Call.Return(jitConfigMap, runner, err)
	return _c
}

func (_c *GithubEntityOperations_GetEntityJITConfig_Call) RunAndReturn(run func(context.Context, string, params.Pool, []string) (map[string]string, *github.Runner, error)) *GithubEntityOperations_GetEntityJITConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetEntityRunnerGroupIDByName provides a mock function with given fields: ctx, runnerGroupName
func (_m *GithubEntityOperations) GetEntityRunnerGroupIDByName(ctx context.Context, runnerGroupName string) (int64, error) {
	ret := _m.Called(ctx, runnerGroupName)

	if len(ret) == 0 {
		panic("no return value specified for GetEntityRunnerGroupIDByName")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return rf(ctx, runnerGroupName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, runnerGroupName)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, runnerGroupName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubEntityOperations_GetEntityRunnerGroupIDByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEntityRunnerGroupIDByName'
type GithubEntityOperations_GetEntityRunnerGroupIDByName_Call struct {
	*mock.Call
}

// GetEntityRunnerGroupIDByName is a helper method to define mock.On call
//   - ctx context.Context
//   - runnerGroupName string
func (_e *GithubEntityOperations_Expecter) GetEntityRunnerGroupIDByName(ctx interface{}, runnerGroupName interface{}) *GithubEntityOperations_GetEntityRunnerGroupIDByName_Call {
	return &GithubEntityOperations_GetEntityRunnerGroupIDByName_Call{Call: _e.mock.On("GetEntityRunnerGroupIDByName", ctx, runnerGroupName)}
}

func (_c *GithubEntityOperations_GetEntityRunnerGroupIDByName_Call) Run(run func(ctx context.Context, runnerGroupName string)) *GithubEntityOperations_GetEntityRunnerGroupIDByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *GithubEntityOperations_GetEntityRunnerGroupIDByName_Call) Return(_a0 int64, _a1 error) *GithubEntityOperations_GetEntityRunnerGroupIDByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GithubEntityOperations_GetEntityRunnerGroupIDByName_Call) RunAndReturn(run func(context.Context, string) (int64, error)) *GithubEntityOperations_GetEntityRunnerGroupIDByName_Call {
	_c.Call.Return(run)
	return _c
}

// GithubBaseURL provides a mock function with no fields
func (_m *GithubEntityOperations) GithubBaseURL() *url.URL {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GithubBaseURL")
	}

	var r0 *url.URL
	if rf, ok := ret.Get(0).(func() *url.URL); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*url.URL)
		}
	}

	return r0
}

// GithubEntityOperations_GithubBaseURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GithubBaseURL'
type GithubEntityOperations_GithubBaseURL_Call struct {
	*mock.Call
}

// GithubBaseURL is a helper method to define mock.On call
func (_e *GithubEntityOperations_Expecter) GithubBaseURL() *GithubEntityOperations_GithubBaseURL_Call {
	return &GithubEntityOperations_GithubBaseURL_Call{Call: _e.mock.On("GithubBaseURL")}
}

func (_c *GithubEntityOperations_GithubBaseURL_Call) Run(run func()) *GithubEntityOperations_GithubBaseURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *GithubEntityOperations_GithubBaseURL_Call) Return(_a0 *url.URL) *GithubEntityOperations_GithubBaseURL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GithubEntityOperations_GithubBaseURL_Call) RunAndReturn(run func() *url.URL) *GithubEntityOperations_GithubBaseURL_Call {
	_c.Call.Return(run)
	return _c
}

// ListEntityHooks provides a mock function with given fields: ctx, opts
func (_m *GithubEntityOperations) ListEntityHooks(ctx context.Context, opts *github.ListOptions) ([]*github.Hook, *github.Response, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ListEntityHooks")
	}

	var r0 []*github.Hook
	var r1 *github.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *github.ListOptions) ([]*github.Hook, *github.Response, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *github.ListOptions) []*github.Hook); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*github.Hook)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *github.ListOptions) *github.Response); ok {
		r1 = rf(ctx, opts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *github.ListOptions) error); ok {
		r2 = rf(ctx, opts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GithubEntityOperations_ListEntityHooks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEntityHooks'
type GithubEntityOperations_ListEntityHooks_Call struct {
	*mock.Call
}

// ListEntityHooks is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *github.ListOptions
func (_e *GithubEntityOperations_Expecter) ListEntityHooks(ctx interface{}, opts interface{}) *GithubEntityOperations_ListEntityHooks_Call {
	return &GithubEntityOperations_ListEntityHooks_Call{Call: _e.mock.On("ListEntityHooks", ctx, opts)}
}

func (_c *GithubEntityOperations_ListEntityHooks_Call) Run(run func(ctx context.Context, opts *github.ListOptions)) *GithubEntityOperations_ListEntityHooks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*github.ListOptions))
	})
	return _c
}

func (_c *GithubEntityOperations_ListEntityHooks_Call) Return(ret []*github.Hook, response *github.Response, err error) *GithubEntityOperations_ListEntityHooks_Call {
	_c.Call.Return(ret, response, err)
	return _c
}

func (_c *GithubEntityOperations_ListEntityHooks_Call) RunAndReturn(run func(context.Context, *github.ListOptions) ([]*github.Hook, *github.Response, error)) *GithubEntityOperations_ListEntityHooks_Call {
	_c.Call.Return(run)
	return _c
}

// ListEntityRunnerApplicationDownloads provides a mock function with given fields: ctx
func (_m *GithubEntityOperations) ListEntityRunnerApplicationDownloads(ctx context.Context) ([]*github.RunnerApplicationDownload, *github.Response, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListEntityRunnerApplicationDownloads")
	}

	var r0 []*github.RunnerApplicationDownload
	var r1 *github.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*github.RunnerApplicationDownload, *github.Response, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*github.RunnerApplicationDownload); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*github.RunnerApplicationDownload)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) *github.Response); ok {
		r1 = rf(ctx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GithubEntityOperations_ListEntityRunnerApplicationDownloads_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEntityRunnerApplicationDownloads'
type GithubEntityOperations_ListEntityRunnerApplicationDownloads_Call struct {
	*mock.Call
}

// ListEntityRunnerApplicationDownloads is a helper method to define mock.On call
//   - ctx context.Context
func (_e *GithubEntityOperations_Expecter) ListEntityRunnerApplicationDownloads(ctx interface{}) *GithubEntityOperations_ListEntityRunnerApplicationDownloads_Call {
	return &GithubEntityOperations_ListEntityRunnerApplicationDownloads_Call{Call: _e.mock.On("ListEntityRunnerApplicationDownloads", ctx)}
}

func (_c *GithubEntityOperations_ListEntityRunnerApplicationDownloads_Call) Run(run func(ctx context.Context)) *GithubEntityOperations_ListEntityRunnerApplicationDownloads_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *GithubEntityOperations_ListEntityRunnerApplicationDownloads_Call) Return(_a0 []*github.RunnerApplicationDownload, _a1 *github.Response, _a2 error) *GithubEntityOperations_ListEntityRunnerApplicationDownloads_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GithubEntityOperations_ListEntityRunnerApplicationDownloads_Call) RunAndReturn(run func(context.Context) ([]*github.RunnerApplicationDownload, *github.Response, error)) *GithubEntityOperations_ListEntityRunnerApplicationDownloads_Call {
	_c.Call.Return(run)
	return _c
}

// ListEntityRunners provides a mock function with given fields: ctx, opts
func (_m *GithubEntityOperations) ListEntityRunners(ctx context.Context, opts *github.ListRunnersOptions) (*github.Runners, *github.Response, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ListEntityRunners")
	}

	var r0 *github.Runners
	var r1 *github.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *github.ListRunnersOptions) (*github.Runners, *github.Response, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *github.ListRunnersOptions) *github.Runners); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Runners)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *github.ListRunnersOptions) *github.Response); ok {
		r1 = rf(ctx, opts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *github.ListRunnersOptions) error); ok {
		r2 = rf(ctx, opts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GithubEntityOperations_ListEntityRunners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEntityRunners'
type GithubEntityOperations_ListEntityRunners_Call struct {
	*mock.Call
}

// ListEntityRunners is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *github.ListRunnersOptions
func (_e *GithubEntityOperations_Expecter) ListEntityRunners(ctx interface{}, opts interface{}) *GithubEntityOperations_ListEntityRunners_Call {
	return &GithubEntityOperations_ListEntityRunners_Call{Call: _e.mock.On("ListEntityRunners", ctx, opts)}
}

func (_c *GithubEntityOperations_ListEntityRunners_Call) Run(run func(ctx context.Context, opts *github.ListRunnersOptions)) *GithubEntityOperations_ListEntityRunners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*github.ListRunnersOptions))
	})
	return _c
}

func (_c *GithubEntityOperations_ListEntityRunners_Call) Return(_a0 *github.Runners, _a1 *github.Response, _a2 error) *GithubEntityOperations_ListEntityRunners_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GithubEntityOperations_ListEntityRunners_Call) RunAndReturn(run func(context.Context, *github.ListRunnersOptions) (*github.Runners, *github.Response, error)) *GithubEntityOperations_ListEntityRunners_Call {
	_c.Call.Return(run)
	return _c
}

// PingEntityHook provides a mock function with given fields: ctx, id
func (_m *GithubEntityOperations) PingEntityHook(ctx context.Context, id int64) (*github.Response, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for PingEntityHook")
	}

	var r0 *github.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*github.Response, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *github.Response); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubEntityOperations_PingEntityHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PingEntityHook'
type GithubEntityOperations_PingEntityHook_Call struct {
	*mock.Call
}

// PingEntityHook is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *GithubEntityOperations_Expecter) PingEntityHook(ctx interface{}, id interface{}) *GithubEntityOperations_PingEntityHook_Call {
	return &GithubEntityOperations_PingEntityHook_Call{Call: _e.mock.On("PingEntityHook", ctx, id)}
}

func (_c *GithubEntityOperations_PingEntityHook_Call) Run(run func(ctx context.Context, id int64)) *GithubEntityOperations_PingEntityHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *GithubEntityOperations_PingEntityHook_Call) Return(ret *github.Response, err error) *GithubEntityOperations_PingEntityHook_Call {
	_c.Call.Return(ret, err)
	return _c
}

func (_c *GithubEntityOperations_PingEntityHook_Call) RunAndReturn(run func(context.Context, int64) (*github.Response, error)) *GithubEntityOperations_PingEntityHook_Call {
	_c.Call.Return(run)
	return _c
}

// RateLimit provides a mock function with given fields: ctx
func (_m *GithubEntityOperations) RateLimit(ctx context.Context) (*github.RateLimits, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for RateLimit")
	}

	var r0 *github.RateLimits
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*github.RateLimits, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *github.RateLimits); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.RateLimits)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubEntityOperations_RateLimit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RateLimit'
type GithubEntityOperations_RateLimit_Call struct {
	*mock.Call
}

// RateLimit is a helper method to define mock.On call
//   - ctx context.Context
func (_e *GithubEntityOperations_Expecter) RateLimit(ctx interface{}) *GithubEntityOperations_RateLimit_Call {
	return &GithubEntityOperations_RateLimit_Call{Call: _e.mock.On("RateLimit", ctx)}
}

func (_c *GithubEntityOperations_RateLimit_Call) Run(run func(ctx context.Context)) *GithubEntityOperations_RateLimit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *GithubEntityOperations_RateLimit_Call) Return(_a0 *github.RateLimits, _a1 error) *GithubEntityOperations_RateLimit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GithubEntityOperations_RateLimit_Call) RunAndReturn(run func(context.Context) (*github.RateLimits, error)) *GithubEntityOperations_RateLimit_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveEntityRunner provides a mock function with given fields: ctx, runnerID
func (_m *GithubEntityOperations) RemoveEntityRunner(ctx context.Context, runnerID int64) error {
	ret := _m.Called(ctx, runnerID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveEntityRunner")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, runnerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GithubEntityOperations_RemoveEntityRunner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveEntityRunner'
type GithubEntityOperations_RemoveEntityRunner_Call struct {
	*mock.Call
}

// RemoveEntityRunner is a helper method to define mock.On call
//   - ctx context.Context
//   - runnerID int64
func (_e *GithubEntityOperations_Expecter) RemoveEntityRunner(ctx interface{}, runnerID interface{}) *GithubEntityOperations_RemoveEntityRunner_Call {
	return &GithubEntityOperations_RemoveEntityRunner_Call{Call: _e.mock.On("RemoveEntityRunner", ctx, runnerID)}
}

func (_c *GithubEntityOperations_RemoveEntityRunner_Call) Run(run func(ctx context.Context, runnerID int64)) *GithubEntityOperations_RemoveEntityRunner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *GithubEntityOperations_RemoveEntityRunner_Call) Return(_a0 error) *GithubEntityOperations_RemoveEntityRunner_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *GithubEntityOperations_RemoveEntityRunner_Call) RunAndReturn(run func(context.Context, int64) error) *GithubEntityOperations_RemoveEntityRunner_Call {
	_c.Call.Return(run)
	return _c
}

// NewGithubEntityOperations creates a new instance of GithubEntityOperations. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGithubEntityOperations(t interface {
	mock.TestingT
	Cleanup(func())
}) *GithubEntityOperations {
	mock := &GithubEntityOperations{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
