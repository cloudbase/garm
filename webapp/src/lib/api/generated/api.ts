/* tslint:disable */
/* eslint-disable */
/**
 * Garm API.
 * The Garm API generated using go-swagger.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface APIErrorResponse
 */
export interface APIErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof APIErrorResponse
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof APIErrorResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface AgentCapabilities
 */
export interface AgentCapabilities {
    /**
     * 
     * @type {boolean}
     * @memberof AgentCapabilities
     */
    'has_shell'?: boolean;
}
/**
 * 
 * @export
 * @interface ControllerInfo
 */
export interface ControllerInfo {
    /**
     * AgentURL is the URL where the GARM agent will connect. If set behind a reverse proxy, this URL must be configured to allow websocket connections.
     * @type {string}
     * @memberof ControllerInfo
     */
    'agent_url'?: string;
    /**
     * CallbackURL is the URL where instances can send updates back to the controller. This URL is used by instances to send status updates back to the controller. The URL itself may be made available to instances via a reverse proxy or a load balancer. That means that the user is responsible for telling GARM what the public URL is, by setting this field.
     * @type {string}
     * @memberof ControllerInfo
     */
    'callback_url'?: string;
    /**
     * ControllerID is the unique ID of this controller. This ID gets generated automatically on controller init.
     * @type {string}
     * @memberof ControllerInfo
     */
    'controller_id'?: string;
    /**
     * ControllerWebhookURL is the controller specific URL where webhooks will be received. This field holds the WebhookURL defined above to which we append the ControllerID. Functionally it is the same as WebhookURL, but it allows us to safely manage webhooks from GARM without accidentally removing webhooks from other services or GARM controllers.
     * @type {string}
     * @memberof ControllerInfo
     */
    'controller_webhook_url'?: string;
    /**
     * SyncGARMAgentTools enables or disables automatic sync of garm-agent tools.
     * @type {boolean}
     * @memberof ControllerInfo
     */
    'enable_agent_tools_sync'?: boolean;
    /**
     * GARMAgentReleasesURL is the URL from where GARM can fetch garm-agent binaries. This URL must have an API response compatible with the github releases API. The default value for this field is: https://api.github.com/repos/cloudbase/garm-agent/releases
     * @type {string}
     * @memberof ControllerInfo
     */
    'garm_agent_releases_url'?: string;
    /**
     * Hostname is the hostname of the machine that runs this controller. In the future, this field will be migrated to a separate table that will keep track of each the controller nodes that are part of a cluster. This will happen when we implement controller scale-out capability.
     * @type {string}
     * @memberof ControllerInfo
     */
    'hostname'?: string;
    /**
     * MetadataURL is the public metadata URL of the GARM instance. This URL is used by instances to fetch information they need to set themselves up. The URL itself may be made available to runners via a reverse proxy or a load balancer. That means that the user is responsible for telling GARM what the public URL is, by setting this field.
     * @type {string}
     * @memberof ControllerInfo
     */
    'metadata_url'?: string;
    /**
     * MinimumJobAgeBackoff is the minimum time in seconds that a job must be in queued state before GARM will attempt to allocate a runner for it. When set to a non zero value, GARM will ignore the job until the job\'s age is greater than this value. When using the min_idle_runners feature of a pool, this gives enough time for potential idle runners to pick up the job before GARM attempts to allocate a new runner, thus avoiding the need to potentially scale down runners later.
     * @type {number}
     * @memberof ControllerInfo
     */
    'minimum_job_age_backoff'?: number;
    /**
     * Version is the version of the GARM controller.
     * @type {string}
     * @memberof ControllerInfo
     */
    'version'?: string;
    /**
     * WebhookURL is the base URL where the controller will receive webhooks from github. When webhook management is used, this URL is used as a base to which the controller UUID is appended and which will receive the webhooks. The URL itself may be made available to instances via a reverse proxy or a load balancer. That means that the user is responsible for telling GARM what the public URL is, by setting this field.
     * @type {string}
     * @memberof ControllerInfo
     */
    'webhook_url'?: string;
}
/**
 * 
 * @export
 * @interface CreateEnterpriseParams
 */
export interface CreateEnterpriseParams {
    /**
     * 
     * @type {boolean}
     * @memberof CreateEnterpriseParams
     */
    'agent_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateEnterpriseParams
     */
    'credentials_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEnterpriseParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEnterpriseParams
     */
    'pool_balancer_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEnterpriseParams
     */
    'webhook_secret'?: string;
}
/**
 * 
 * @export
 * @interface CreateFileObjectParams
 */
export interface CreateFileObjectParams {
    /**
     * 
     * @type {string}
     * @memberof CreateFileObjectParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateFileObjectParams
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateFileObjectParams
     */
    'size'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateFileObjectParams
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateGiteaCredentialsParams
 */
export interface CreateGiteaCredentialsParams {
    /**
     * 
     * @type {GithubApp}
     * @memberof CreateGiteaCredentialsParams
     */
    'app'?: GithubApp;
    /**
     * 
     * @type {string}
     * @memberof CreateGiteaCredentialsParams
     */
    'auth_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGiteaCredentialsParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGiteaCredentialsParams
     */
    'endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGiteaCredentialsParams
     */
    'name'?: string;
    /**
     * 
     * @type {GithubPAT}
     * @memberof CreateGiteaCredentialsParams
     */
    'pat'?: GithubPAT;
}
/**
 * 
 * @export
 * @interface CreateGiteaEndpointParams
 */
export interface CreateGiteaEndpointParams {
    /**
     * 
     * @type {string}
     * @memberof CreateGiteaEndpointParams
     */
    'api_base_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGiteaEndpointParams
     */
    'base_url'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateGiteaEndpointParams
     */
    'ca_cert_bundle'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof CreateGiteaEndpointParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGiteaEndpointParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGiteaEndpointParams
     */
    'tools_metadata_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGiteaEndpointParams
     */
    'use_internal_tools_metadata'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateGithubCredentialsParams
 */
export interface CreateGithubCredentialsParams {
    /**
     * 
     * @type {GithubApp}
     * @memberof CreateGithubCredentialsParams
     */
    'app'?: GithubApp;
    /**
     * 
     * @type {string}
     * @memberof CreateGithubCredentialsParams
     */
    'auth_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGithubCredentialsParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGithubCredentialsParams
     */
    'endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGithubCredentialsParams
     */
    'name'?: string;
    /**
     * 
     * @type {GithubPAT}
     * @memberof CreateGithubCredentialsParams
     */
    'pat'?: GithubPAT;
}
/**
 * 
 * @export
 * @interface CreateGithubEndpointParams
 */
export interface CreateGithubEndpointParams {
    /**
     * 
     * @type {string}
     * @memberof CreateGithubEndpointParams
     */
    'api_base_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGithubEndpointParams
     */
    'base_url'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateGithubEndpointParams
     */
    'ca_cert_bundle'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof CreateGithubEndpointParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGithubEndpointParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGithubEndpointParams
     */
    'upload_base_url'?: string;
}
/**
 * 
 * @export
 * @interface CreateOrgParams
 */
export interface CreateOrgParams {
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrgParams
     */
    'agent_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateOrgParams
     */
    'credentials_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrgParams
     */
    'forge_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrgParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrgParams
     */
    'pool_balancer_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrgParams
     */
    'webhook_secret'?: string;
}
/**
 * 
 * @export
 * @interface CreatePoolParams
 */
export interface CreatePoolParams {
    /**
     * 
     * @type {boolean}
     * @memberof CreatePoolParams
     */
    'enable_shell'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePoolParams
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof CreatePoolParams
     */
    'extra_specs'?: object;
    /**
     * 
     * @type {string}
     * @memberof CreatePoolParams
     */
    'flavor'?: string;
    /**
     * GithubRunnerGroup is the github runner group in which the runners of this pool will be added to. The runner group must be created by someone with access to the enterprise.
     * @type {string}
     * @memberof CreatePoolParams
     */
    'github-runner-group'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePoolParams
     */
    'image'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreatePoolParams
     */
    'max_runners'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatePoolParams
     */
    'min_idle_runners'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreatePoolParams
     */
    'os_arch'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePoolParams
     */
    'os_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreatePoolParams
     */
    'priority'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreatePoolParams
     */
    'provider_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreatePoolParams
     */
    'runner_bootstrap_timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreatePoolParams
     */
    'runner_prefix'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePoolParams
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CreatePoolParams
     */
    'template_id'?: number;
}
/**
 * 
 * @export
 * @interface CreateRepoParams
 */
export interface CreateRepoParams {
    /**
     * 
     * @type {boolean}
     * @memberof CreateRepoParams
     */
    'agent_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRepoParams
     */
    'credentials_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRepoParams
     */
    'forge_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRepoParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRepoParams
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRepoParams
     */
    'pool_balancer_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRepoParams
     */
    'webhook_secret'?: string;
}
/**
 * 
 * @export
 * @interface CreateScaleSetParams
 */
export interface CreateScaleSetParams {
    /**
     * 
     * @type {boolean}
     * @memberof CreateScaleSetParams
     */
    'disable_update'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateScaleSetParams
     */
    'enable_shell'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateScaleSetParams
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof CreateScaleSetParams
     */
    'extra_specs'?: object;
    /**
     * 
     * @type {string}
     * @memberof CreateScaleSetParams
     */
    'flavor'?: string;
    /**
     * GithubRunnerGroup is the github runner group in which the runners of this pool will be added to. The runner group must be created by someone with access to the enterprise.
     * @type {string}
     * @memberof CreateScaleSetParams
     */
    'github-runner-group'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateScaleSetParams
     */
    'image'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateScaleSetParams
     */
    'max_runners'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateScaleSetParams
     */
    'min_idle_runners'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateScaleSetParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateScaleSetParams
     */
    'os_arch'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateScaleSetParams
     */
    'os_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateScaleSetParams
     */
    'provider_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateScaleSetParams
     */
    'runner_bootstrap_timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateScaleSetParams
     */
    'runner_prefix'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateScaleSetParams
     */
    'scale_set_id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateScaleSetParams
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CreateScaleSetParams
     */
    'template_id'?: number;
}
/**
 * 
 * @export
 * @interface CreateTemplateParams
 */
export interface CreateTemplateParams {
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateTemplateParams
     */
    'data'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplateParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplateParams
     */
    'forge_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplateParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplateParams
     */
    'os_type'?: string;
}
/**
 * 
 * @export
 * @interface Enterprise
 */
export interface Enterprise {
    /**
     * 
     * @type {boolean}
     * @memberof Enterprise
     */
    'agent_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Enterprise
     */
    'created_at'?: string;
    /**
     * 
     * @type {ForgeCredentials}
     * @memberof Enterprise
     */
    'credentials'?: ForgeCredentials;
    /**
     * 
     * @type {number}
     * @memberof Enterprise
     */
    'credentials_id'?: number;
    /**
     * CredentialName is the name of the credentials associated with the enterprise. This field is now deprecated. Use CredentialsID instead. This field will be removed in v0.2.0.
     * @type {string}
     * @memberof Enterprise
     */
    'credentials_name'?: string;
    /**
     * 
     * @type {ForgeEndpoint}
     * @memberof Enterprise
     */
    'endpoint'?: ForgeEndpoint;
    /**
     * 
     * @type {Array<EntityEvent>}
     * @memberof Enterprise
     */
    'events'?: Array<EntityEvent>;
    /**
     * 
     * @type {string}
     * @memberof Enterprise
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Enterprise
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Pool>}
     * @memberof Enterprise
     */
    'pool'?: Array<Pool>;
    /**
     * 
     * @type {string}
     * @memberof Enterprise
     */
    'pool_balancing_type'?: string;
    /**
     * 
     * @type {PoolManagerStatus}
     * @memberof Enterprise
     */
    'pool_manager_status'?: PoolManagerStatus;
    /**
     * 
     * @type {string}
     * @memberof Enterprise
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface EntityEvent
 */
export interface EntityEvent {
    /**
     * 
     * @type {string}
     * @memberof EntityEvent
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityEvent
     */
    'event_level'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityEvent
     */
    'event_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntityEvent
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityEvent
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface FileObject
 */
export interface FileObject {
    /**
     * 
     * @type {string}
     * @memberof FileObject
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileObject
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileObject
     */
    'file_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileObject
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FileObject
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileObject
     */
    'sha256'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileObject
     */
    'size'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof FileObject
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FileObject
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface FileObjectPaginatedResponse
 */
export interface FileObjectPaginatedResponse {
    /**
     * 
     * @type {number}
     * @memberof FileObjectPaginatedResponse
     */
    'current_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileObjectPaginatedResponse
     */
    'next_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileObjectPaginatedResponse
     */
    'pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof FileObjectPaginatedResponse
     */
    'previous_page'?: number;
    /**
     * 
     * @type {Array<FileObjectPaginatedResponseResultsInner>}
     * @memberof FileObjectPaginatedResponse
     */
    'results'?: Array<FileObjectPaginatedResponseResultsInner>;
    /**
     * 
     * @type {number}
     * @memberof FileObjectPaginatedResponse
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface FileObjectPaginatedResponseResultsInner
 */
export interface FileObjectPaginatedResponseResultsInner {
    /**
     * 
     * @type {string}
     * @memberof FileObjectPaginatedResponseResultsInner
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileObjectPaginatedResponseResultsInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileObjectPaginatedResponseResultsInner
     */
    'file_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileObjectPaginatedResponseResultsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FileObjectPaginatedResponseResultsInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileObjectPaginatedResponseResultsInner
     */
    'sha256'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileObjectPaginatedResponseResultsInner
     */
    'size'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof FileObjectPaginatedResponseResultsInner
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FileObjectPaginatedResponseResultsInner
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ForgeCredentials
 */
export interface ForgeCredentials {
    /**
     * 
     * @type {string}
     * @memberof ForgeCredentials
     */
    'api_base_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeCredentials
     */
    'auth-type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeCredentials
     */
    'base_url'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ForgeCredentials
     */
    'ca_bundle'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ForgeCredentials
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeCredentials
     */
    'description'?: string;
    /**
     * 
     * @type {ForgeEndpoint}
     * @memberof ForgeCredentials
     */
    'endpoint'?: ForgeEndpoint;
    /**
     * 
     * @type {Array<Enterprise>}
     * @memberof ForgeCredentials
     */
    'enterprises'?: Array<Enterprise>;
    /**
     * 
     * @type {string}
     * @memberof ForgeCredentials
     */
    'forge_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof ForgeCredentials
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ForgeCredentials
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Organization>}
     * @memberof ForgeCredentials
     */
    'organizations'?: Array<Organization>;
    /**
     * 
     * @type {GithubRateLimit}
     * @memberof ForgeCredentials
     */
    'rate_limit'?: GithubRateLimit;
    /**
     * 
     * @type {Array<Repository>}
     * @memberof ForgeCredentials
     */
    'repositories'?: Array<Repository>;
    /**
     * 
     * @type {string}
     * @memberof ForgeCredentials
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeCredentials
     */
    'upload_base_url'?: string;
}
/**
 * 
 * @export
 * @interface ForgeEndpoint
 */
export interface ForgeEndpoint {
    /**
     * 
     * @type {string}
     * @memberof ForgeEndpoint
     */
    'api_base_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEndpoint
     */
    'base_url'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ForgeEndpoint
     */
    'ca_cert_bundle'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ForgeEndpoint
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEndpoint
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEndpoint
     */
    'endpoint_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEndpoint
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEndpoint
     */
    'tools_metadata_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEndpoint
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEndpoint
     */
    'upload_base_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ForgeEndpoint
     */
    'use_internal_tools_metadata'?: boolean;
}
/**
 * 
 * @export
 * @interface ForgeEntity
 */
export interface ForgeEntity {
    /**
     * 
     * @type {boolean}
     * @memberof ForgeEntity
     */
    'agent_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ForgeEntity
     */
    'created_at'?: string;
    /**
     * 
     * @type {ForgeCredentials}
     * @memberof ForgeEntity
     */
    'credentials'?: ForgeCredentials;
    /**
     * 
     * @type {string}
     * @memberof ForgeEntity
     */
    'entity_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEntity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEntity
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEntity
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEntity
     */
    'pool_balancing_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForgeEntity
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface GARMAgentTool
 */
export interface GARMAgentTool {
    /**
     * 
     * @type {string}
     * @memberof GARMAgentTool
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentTool
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentTool
     */
    'download_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentTool
     */
    'file_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof GARMAgentTool
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentTool
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentTool
     */
    'os_arch'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentTool
     */
    'os_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentTool
     */
    'sha256sum'?: string;
    /**
     * 
     * @type {number}
     * @memberof GARMAgentTool
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentTool
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentTool
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface GARMAgentToolsPaginatedResponse
 */
export interface GARMAgentToolsPaginatedResponse {
    /**
     * 
     * @type {number}
     * @memberof GARMAgentToolsPaginatedResponse
     */
    'current_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GARMAgentToolsPaginatedResponse
     */
    'next_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GARMAgentToolsPaginatedResponse
     */
    'pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof GARMAgentToolsPaginatedResponse
     */
    'previous_page'?: number;
    /**
     * 
     * @type {Array<GARMAgentToolsPaginatedResponseResultsInner>}
     * @memberof GARMAgentToolsPaginatedResponse
     */
    'results'?: Array<GARMAgentToolsPaginatedResponseResultsInner>;
    /**
     * 
     * @type {number}
     * @memberof GARMAgentToolsPaginatedResponse
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface GARMAgentToolsPaginatedResponseResultsInner
 */
export interface GARMAgentToolsPaginatedResponseResultsInner {
    /**
     * 
     * @type {string}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'download_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'file_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'os_arch'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'os_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'sha256sum'?: string;
    /**
     * 
     * @type {number}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GARMAgentToolsPaginatedResponseResultsInner
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface GithubApp
 */
export interface GithubApp {
    /**
     * 
     * @type {number}
     * @memberof GithubApp
     */
    'app_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubApp
     */
    'installation_id'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof GithubApp
     */
    'private_key_bytes'?: Array<number>;
}
/**
 * 
 * @export
 * @interface GithubPAT
 */
export interface GithubPAT {
    /**
     * 
     * @type {string}
     * @memberof GithubPAT
     */
    'oauth2_token'?: string;
}
/**
 * 
 * @export
 * @interface GithubRateLimit
 */
export interface GithubRateLimit {
    /**
     * 
     * @type {number}
     * @memberof GithubRateLimit
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubRateLimit
     */
    'remaining'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubRateLimit
     */
    'reset'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubRateLimit
     */
    'used'?: number;
}
/**
 * 
 * @export
 * @interface HookInfo
 */
export interface HookInfo {
    /**
     * 
     * @type {boolean}
     * @memberof HookInfo
     */
    'active'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof HookInfo
     */
    'events'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof HookInfo
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HookInfo
     */
    'insecure_ssl'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HookInfo
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface InstallWebhookParams
 */
export interface InstallWebhookParams {
    /**
     * 
     * @type {boolean}
     * @memberof InstallWebhookParams
     */
    'insecure_ssl'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InstallWebhookParams
     */
    'webhook_endpoint_type'?: string;
}
/**
 * 
 * @export
 * @interface Instance
 */
export interface Instance {
    /**
     * Addresses is a list of IP addresses the provider reports for this instance.
     * @type {Array<Address>}
     * @memberof Instance
     */
    'addresses'?: Array<Address>;
    /**
     * AgentID is the github runner agent ID.
     * @type {number}
     * @memberof Instance
     */
    'agent_id'?: number;
    /**
     * 
     * @type {AgentCapabilities}
     * @memberof Instance
     */
    'capabilities'?: AgentCapabilities;
    /**
     * CreatedAt is the timestamp of the creation of this runner.
     * @type {string}
     * @memberof Instance
     */
    'created_at'?: string;
    /**
     * GithubRunnerGroup is the github runner group to which the runner belongs. The runner group must be created by someone with access to the enterprise.
     * @type {string}
     * @memberof Instance
     */
    'github-runner-group'?: string;
    /**
     * Heartbeat is the last recorded heartbeat from the runner
     * @type {string}
     * @memberof Instance
     */
    'heartbeat'?: string;
    /**
     * ID is the database ID of this instance.
     * @type {string}
     * @memberof Instance
     */
    'id'?: string;
    /**
     * 
     * @type {Job}
     * @memberof Instance
     */
    'job'?: Job;
    /**
     * Name is the name associated with an instance. Depending on the provider, this may or may not be useful in the context of the provider, but we can use it internally to identify the instance.
     * @type {string}
     * @memberof Instance
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'os_arch'?: string;
    /**
     * OSName is the name of the OS. Eg: ubuntu, centos, etc.
     * @type {string}
     * @memberof Instance
     */
    'os_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'os_type'?: string;
    /**
     * OSVersion is the version of the operating system.
     * @type {string}
     * @memberof Instance
     */
    'os_version'?: string;
    /**
     * PoolID is the ID of the garm pool to which a runner belongs.
     * @type {string}
     * @memberof Instance
     */
    'pool_id'?: string;
    /**
     * ProviderFault holds any error messages captured from the IaaS provider that is responsible for managing the lifecycle of the runner.
     * @type {Array<number>}
     * @memberof Instance
     */
    'provider_fault'?: Array<number>;
    /**
     * PeoviderID is the unique ID the provider associated with the compute instance. We use this to identify the instance in the provider.
     * @type {string}
     * @memberof Instance
     */
    'provider_id'?: string;
    /**
     * ProviderName is the name of the IaaS where the instance was created.
     * @type {string}
     * @memberof Instance
     */
    'provider_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'runner_status'?: string;
    /**
     * ScaleSetID is the ID of the scale set to which a runner belongs.
     * @type {number}
     * @memberof Instance
     */
    'scale_set_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'status'?: string;
    /**
     * StatusMessages is a list of status messages sent back by the runner as it sets itself up.
     * @type {Array<StatusMessage>}
     * @memberof Instance
     */
    'status_messages'?: Array<StatusMessage>;
    /**
     * UpdatedAt is the timestamp of the last update to this runner.
     * @type {string}
     * @memberof Instance
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface InstanceMetadata
 */
export interface InstanceMetadata {
    /**
     * Agent mode indicates whether or not we need to install the GARM agent on the runner.
     * @type {boolean}
     * @memberof InstanceMetadata
     */
    'agent_mode'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceMetadata
     */
    'agent_shell_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InstanceMetadata
     */
    'agent_token'?: string;
    /**
     * 
     * @type {GARMAgentTool}
     * @memberof InstanceMetadata
     */
    'agent_tools'?: GARMAgentTool;
    /**
     * 
     * @type {{ [key: string]: Array<number>; }}
     * @memberof InstanceMetadata
     */
    'ca_bundles'?: { [key: string]: Array<number>; };
    /**
     * ExtraSpecs represents the extra specs set on the pool or scale set. No secrets should be set in extra specs. Also, the instance metadata should never be saved to disk, and the metadata URL is only accessible during setup of the runner. The API returns unauthorized once the runner transitions to failed/idle.
     * @type {{ [key: string]: object; }}
     * @memberof InstanceMetadata
     */
    'extra_specs'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof InstanceMetadata
     */
    'forge_type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceMetadata
     */
    'jit_enabled'?: boolean;
    /**
     * 
     * @type {MetadataServiceAccessDetails}
     * @memberof InstanceMetadata
     */
    'metadata_access'?: MetadataServiceAccessDetails;
    /**
     * 
     * @type {Array<string>}
     * @memberof InstanceMetadata
     */
    'runner_labels'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InstanceMetadata
     */
    'runner_name'?: string;
    /**
     * RunnerRegistrationURL is the URL the runner needs to configure itself against. This can be a repository, organization, enterprise (github) or system (gitea)
     * @type {string}
     * @memberof InstanceMetadata
     */
    'runner_registration_url'?: string;
    /**
     * 
     * @type {RunnerApplicationDownload}
     * @memberof InstanceMetadata
     */
    'runner_tools'?: RunnerApplicationDownload;
}
/**
 * JWTResponse holds the JWT token returned as a result of a successful auth
 * @export
 * @interface JWTResponse
 */
export interface JWTResponse {
    /**
     * 
     * @type {string}
     * @memberof JWTResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * Action is the specific activity that triggered the event.
     * @type {string}
     * @memberof Job
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'completed_at'?: string;
    /**
     * Conclusion is the outcome of the job. Possible values: \"success\", \"failure\", \"neutral\", \"cancelled\", \"skipped\", \"timed_out\", \"action_required\"
     * @type {string}
     * @memberof Job
     */
    'conclusion'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'enterprise_id'?: string;
    /**
     * ID is the ID of the job.
     * @type {number}
     * @memberof Job
     */
    'id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Job
     */
    'labels'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'locked_by'?: string;
    /**
     * Name is the name if the job that was triggered.
     * @type {string}
     * @memberof Job
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'org_id'?: string;
    /**
     * The entity that received the hook.  Webhooks may be configured on the repo, the org and/or the enterprise. If we only configure a repo to use garm, we\'ll only ever receive a webhook from the repo. But if we configure the parent org of the repo and the parent enterprise of the org to use garm, a webhook will be sent for each entity type, in response to one workflow event. Thus, we will get 3 webhooks with the same run_id and job id. Record all involved entities in the same job if we have them configured in garm.
     * @type {string}
     * @memberof Job
     */
    'repo_id'?: string;
    /**
     * repository in which the job was triggered.
     * @type {string}
     * @memberof Job
     */
    'repository_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'repository_owner'?: string;
    /**
     * RunID is the ID of the workflow run. A run may have multiple jobs.
     * @type {number}
     * @memberof Job
     */
    'run_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'runner_group_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'runner_group_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'runner_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'runner_name'?: string;
    /**
     * ScaleSetJobID is the job ID when generated for a scale set.
     * @type {string}
     * @memberof Job
     */
    'scaleset_job_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'started_at'?: string;
    /**
     * Status is the phase of the lifecycle that the job is currently in. \"queued\", \"in_progress\" and \"completed\".
     * @type {string}
     * @memberof Job
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'workflow_job_id'?: number;
}
/**
 * 
 * @export
 * @interface MetadataServiceAccessDetails
 */
export interface MetadataServiceAccessDetails {
    /**
     * 
     * @type {string}
     * @memberof MetadataServiceAccessDetails
     */
    'agent_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataServiceAccessDetails
     */
    'callback_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataServiceAccessDetails
     */
    'metadata_url'?: string;
}
/**
 * NewUserParams holds the needed information to create a new user
 * @export
 * @interface NewUserParams
 */
export interface NewUserParams {
    /**
     * 
     * @type {string}
     * @memberof NewUserParams
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewUserParams
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewUserParams
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewUserParams
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {boolean}
     * @memberof Organization
     */
    'agent_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'created_at'?: string;
    /**
     * 
     * @type {ForgeCredentials}
     * @memberof Organization
     */
    'credentials'?: ForgeCredentials;
    /**
     * 
     * @type {number}
     * @memberof Organization
     */
    'credentials_id'?: number;
    /**
     * CredentialName is the name of the credentials associated with the enterprise. This field is now deprecated. Use CredentialsID instead. This field will be removed in v0.2.0.
     * @type {string}
     * @memberof Organization
     */
    'credentials_name'?: string;
    /**
     * 
     * @type {ForgeEndpoint}
     * @memberof Organization
     */
    'endpoint'?: ForgeEndpoint;
    /**
     * 
     * @type {Array<EntityEvent>}
     * @memberof Organization
     */
    'events'?: Array<EntityEvent>;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Pool>}
     * @memberof Organization
     */
    'pool'?: Array<Pool>;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'pool_balancing_type'?: string;
    /**
     * 
     * @type {PoolManagerStatus}
     * @memberof Organization
     */
    'pool_manager_status'?: PoolManagerStatus;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PasswordLoginParams
 */
export interface PasswordLoginParams {
    /**
     * 
     * @type {string}
     * @memberof PasswordLoginParams
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordLoginParams
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface Pool
 */
export interface Pool {
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'created_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Pool
     */
    'enable_shell'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pool
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {ForgeEndpoint}
     * @memberof Pool
     */
    'endpoint'?: ForgeEndpoint;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'enterprise_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'enterprise_name'?: string;
    /**
     * ExtraSpecs is an opaque raw json that gets sent to the provider as part of the bootstrap params for instances. It can contain any kind of data needed by providers. The contents of this field means nothing to garm itself. We don\'t act on the information in this field at all. We only validate that it\'s a proper json.
     * @type {object}
     * @memberof Pool
     */
    'extra_specs'?: object;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'flavor'?: string;
    /**
     * GithubRunnerGroup is the github runner group in which the runners will be added. The runner group must be created by someone with access to the enterprise.
     * @type {string}
     * @memberof Pool
     */
    'github-runner-group'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'image'?: string;
    /**
     * 
     * @type {Array<Instance>}
     * @memberof Pool
     */
    'instances'?: Array<Instance>;
    /**
     * 
     * @type {number}
     * @memberof Pool
     */
    'max_runners'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pool
     */
    'min_idle_runners'?: number;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'org_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'org_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'os_arch'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'os_type'?: string;
    /**
     * Priority is the priority of the pool. The higher the number, the higher the priority. When fetching matching pools for a set of tags, the result will be sorted in descending order of priority.
     * @type {number}
     * @memberof Pool
     */
    'priority'?: number;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'provider_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'repo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'repo_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Pool
     */
    'runner_bootstrap_timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'runner_prefix'?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Pool
     */
    'tags'?: Array<Tag>;
    /**
     * 
     * @type {number}
     * @memberof Pool
     */
    'template_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'template_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PoolManagerStatus
 */
export interface PoolManagerStatus {
    /**
     * 
     * @type {string}
     * @memberof PoolManagerStatus
     */
    'failure_reason'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PoolManagerStatus
     */
    'running'?: boolean;
}
/**
 * 
 * @export
 * @interface Provider
 */
export interface Provider {
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Repository
 */
export interface Repository {
    /**
     * 
     * @type {boolean}
     * @memberof Repository
     */
    'agent_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'created_at'?: string;
    /**
     * 
     * @type {ForgeCredentials}
     * @memberof Repository
     */
    'credentials'?: ForgeCredentials;
    /**
     * 
     * @type {number}
     * @memberof Repository
     */
    'credentials_id'?: number;
    /**
     * CredentialName is the name of the credentials associated with the enterprise. This field is now deprecated. Use CredentialsID instead. This field will be removed in v0.2.0.
     * @type {string}
     * @memberof Repository
     */
    'credentials_name'?: string;
    /**
     * 
     * @type {ForgeEndpoint}
     * @memberof Repository
     */
    'endpoint'?: ForgeEndpoint;
    /**
     * 
     * @type {Array<EntityEvent>}
     * @memberof Repository
     */
    'events'?: Array<EntityEvent>;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'owner'?: string;
    /**
     * 
     * @type {Array<Pool>}
     * @memberof Repository
     */
    'pool'?: Array<Pool>;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'pool_balancing_type'?: string;
    /**
     * 
     * @type {PoolManagerStatus}
     * @memberof Repository
     */
    'pool_manager_status'?: PoolManagerStatus;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface RestoreTemplateRequest
 */
export interface RestoreTemplateRequest {
    /**
     * 
     * @type {string}
     * @memberof RestoreTemplateRequest
     */
    'forge'?: string;
    /**
     * 
     * @type {string}
     * @memberof RestoreTemplateRequest
     */
    'os_type'?: string;
    /**
     * RestoreAll indicates whether or not to restore all known system owned templates. If set, the Forge and OSType params are ignored.
     * @type {boolean}
     * @memberof RestoreTemplateRequest
     */
    'restore_all'?: boolean;
}
/**
 * This is copied from the go-github package. It does not make sense to create a dependency on go-github just for this struct.
 * @export
 * @interface RunnerApplicationDownload
 */
export interface RunnerApplicationDownload {
    /**
     * 
     * @type {string}
     * @memberof RunnerApplicationDownload
     */
    'architecture'?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerApplicationDownload
     */
    'download_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerApplicationDownload
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerApplicationDownload
     */
    'os'?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerApplicationDownload
     */
    'sha256_checksum'?: string;
    /**
     * 
     * @type {string}
     * @memberof RunnerApplicationDownload
     */
    'temp_download_token'?: string;
}
/**
 * 
 * @export
 * @interface RunnerPrefix
 */
export interface RunnerPrefix {
    /**
     * 
     * @type {string}
     * @memberof RunnerPrefix
     */
    'runner_prefix'?: string;
}
/**
 * 
 * @export
 * @interface ScaleSet
 */
export interface ScaleSet {
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScaleSet
     */
    'desired_runner_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScaleSet
     */
    'disable_update'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScaleSet
     */
    'enable_shell'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScaleSet
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {ForgeEndpoint}
     * @memberof ScaleSet
     */
    'endpoint'?: ForgeEndpoint;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'enterprise_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'enterprise_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'extended_state'?: string;
    /**
     * ExtraSpecs is an opaque raw json that gets sent to the provider as part of the bootstrap params for instances. It can contain any kind of data needed by providers. The contents of this field means nothing to garm itself. We don\'t act on the information in this field at all. We only validate that it\'s a proper json.
     * @type {object}
     * @memberof ScaleSet
     */
    'extra_specs'?: object;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'flavor'?: string;
    /**
     * GithubRunnerGroup is the github runner group in which the runners will be added. The runner group must be created by someone with access to the enterprise.
     * @type {string}
     * @memberof ScaleSet
     */
    'github-runner-group'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScaleSet
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'image'?: string;
    /**
     * 
     * @type {Array<Instance>}
     * @memberof ScaleSet
     */
    'instances'?: Array<Instance>;
    /**
     * 
     * @type {number}
     * @memberof ScaleSet
     */
    'max_runners'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScaleSet
     */
    'min_idle_runners'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'org_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'org_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'os_arch'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'os_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'provider_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'repo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'repo_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScaleSet
     */
    'runner_bootstrap_timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'runner_prefix'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScaleSet
     */
    'scale_set_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'state'?: string;
    /**
     * 
     * @type {Array<StatusMessage>}
     * @memberof ScaleSet
     */
    'status_messages'?: Array<StatusMessage>;
    /**
     * 
     * @type {number}
     * @memberof ScaleSet
     */
    'template_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'template_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScaleSet
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface StatusMessage
 */
export interface StatusMessage {
    /**
     * 
     * @type {string}
     * @memberof StatusMessage
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusMessage
     */
    'event_level'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusMessage
     */
    'event_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusMessage
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'created_at'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Template
     */
    'data'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'forge_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Template
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'os_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'owner_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface UpdateControllerParams
 */
export interface UpdateControllerParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateControllerParams
     */
    'agent_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateControllerParams
     */
    'callback_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateControllerParams
     */
    'enable_agent_tools_sync'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateControllerParams
     */
    'garm_agent_releases_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateControllerParams
     */
    'metadata_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateControllerParams
     */
    'minimum_job_age_backoff'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateControllerParams
     */
    'webhook_url'?: string;
}
/**
 * 
 * @export
 * @interface UpdateEntityParams
 */
export interface UpdateEntityParams {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEntityParams
     */
    'agent_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityParams
     */
    'credentials_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityParams
     */
    'pool_balancer_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityParams
     */
    'webhook_secret'?: string;
}
/**
 * 
 * @export
 * @interface UpdateFileObjectParams
 */
export interface UpdateFileObjectParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateFileObjectParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFileObjectParams
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateFileObjectParams
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateGiteaCredentialsParams
 */
export interface UpdateGiteaCredentialsParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateGiteaCredentialsParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGiteaCredentialsParams
     */
    'name'?: string;
    /**
     * 
     * @type {GithubPAT}
     * @memberof UpdateGiteaCredentialsParams
     */
    'pat'?: GithubPAT;
}
/**
 * 
 * @export
 * @interface UpdateGiteaEndpointParams
 */
export interface UpdateGiteaEndpointParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateGiteaEndpointParams
     */
    'api_base_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGiteaEndpointParams
     */
    'base_url'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateGiteaEndpointParams
     */
    'ca_cert_bundle'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof UpdateGiteaEndpointParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGiteaEndpointParams
     */
    'tools_metadata_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGiteaEndpointParams
     */
    'use_internal_tools_metadata'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateGithubCredentialsParams
 */
export interface UpdateGithubCredentialsParams {
    /**
     * 
     * @type {GithubApp}
     * @memberof UpdateGithubCredentialsParams
     */
    'app'?: GithubApp;
    /**
     * 
     * @type {string}
     * @memberof UpdateGithubCredentialsParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGithubCredentialsParams
     */
    'name'?: string;
    /**
     * 
     * @type {GithubPAT}
     * @memberof UpdateGithubCredentialsParams
     */
    'pat'?: GithubPAT;
}
/**
 * 
 * @export
 * @interface UpdateGithubEndpointParams
 */
export interface UpdateGithubEndpointParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateGithubEndpointParams
     */
    'api_base_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGithubEndpointParams
     */
    'base_url'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateGithubEndpointParams
     */
    'ca_cert_bundle'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof UpdateGithubEndpointParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGithubEndpointParams
     */
    'upload_base_url'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePoolParams
 */
export interface UpdatePoolParams {
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePoolParams
     */
    'enable_shell'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePoolParams
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof UpdatePoolParams
     */
    'extra_specs'?: object;
    /**
     * 
     * @type {string}
     * @memberof UpdatePoolParams
     */
    'flavor'?: string;
    /**
     * GithubRunnerGroup is the github runner group in which the runners of this pool will be added to. The runner group must be created by someone with access to the enterprise.
     * @type {string}
     * @memberof UpdatePoolParams
     */
    'github-runner-group'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePoolParams
     */
    'image'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdatePoolParams
     */
    'max_runners'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePoolParams
     */
    'min_idle_runners'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePoolParams
     */
    'os_arch'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePoolParams
     */
    'os_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdatePoolParams
     */
    'priority'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatePoolParams
     */
    'runner_bootstrap_timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePoolParams
     */
    'runner_prefix'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePoolParams
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UpdatePoolParams
     */
    'template_id'?: number;
}
/**
 * 
 * @export
 * @interface UpdateScaleSetParams
 */
export interface UpdateScaleSetParams {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateScaleSetParams
     */
    'enable_shell'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateScaleSetParams
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateScaleSetParams
     */
    'extended_state'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateScaleSetParams
     */
    'extra_specs'?: object;
    /**
     * 
     * @type {string}
     * @memberof UpdateScaleSetParams
     */
    'flavor'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScaleSetParams
     */
    'image'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateScaleSetParams
     */
    'max_runners'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateScaleSetParams
     */
    'min_idle_runners'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateScaleSetParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScaleSetParams
     */
    'os_arch'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScaleSetParams
     */
    'os_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateScaleSetParams
     */
    'runner_bootstrap_timeout'?: number;
    /**
     * GithubRunnerGroup is the github runner group in which the runners of this pool will be added to. The runner group must be created by someone with access to the enterprise.
     * @type {string}
     * @memberof UpdateScaleSetParams
     */
    'runner_group'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScaleSetParams
     */
    'runner_prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScaleSetParams
     */
    'state'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateScaleSetParams
     */
    'template_id'?: number;
}
/**
 * 
 * @export
 * @interface UpdateTemplateParams
 */
export interface UpdateTemplateParams {
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateTemplateParams
     */
    'data'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof UpdateTemplateParams
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTemplateParams
     */
    'name'?: string;
}
/**
 * Users holds information about a particular user
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_admin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
}

/**
 * ControllerApi - axios parameter creator
 * @export
 */
export const ControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update controller.
         * @param {UpdateControllerParams} body Parameters used when updating the controller.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateController: async (body: UpdateControllerParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateController', 'body', body)
            const localVarPath = `/controller`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ControllerApi - functional programming interface
 * @export
 */
export const ControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update controller.
         * @param {UpdateControllerParams} body Parameters used when updating the controller.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateController(body: UpdateControllerParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateController(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControllerApi.updateController']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ControllerApi - factory interface
 * @export
 */
export const ControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Update controller.
         * @param {UpdateControllerParams} body Parameters used when updating the controller.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateController(body: UpdateControllerParams, options?: RawAxiosRequestConfig): AxiosPromise<ControllerInfo> {
            return localVarFp.updateController(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ControllerApi - object-oriented interface
 * @export
 * @class ControllerApi
 * @extends {BaseAPI}
 */
export class ControllerApi extends BaseAPI {
    /**
     * 
     * @summary Update controller.
     * @param {UpdateControllerParams} body Parameters used when updating the controller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControllerApi
     */
    public updateController(body: UpdateControllerParams, options?: RawAxiosRequestConfig) {
        return ControllerApiFp(this.configuration).updateController(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ControllerInfoApi - axios parameter creator
 * @export
 */
export const ControllerInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get controller info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controllerInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/controller-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ControllerInfoApi - functional programming interface
 * @export
 */
export const ControllerInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ControllerInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get controller info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async controllerInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllerInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.controllerInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControllerInfoApi.controllerInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ControllerInfoApi - factory interface
 * @export
 */
export const ControllerInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ControllerInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get controller info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controllerInfo(options?: RawAxiosRequestConfig): AxiosPromise<ControllerInfo> {
            return localVarFp.controllerInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ControllerInfoApi - object-oriented interface
 * @export
 * @class ControllerInfoApi
 * @extends {BaseAPI}
 */
export class ControllerInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get controller info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControllerInfoApi
     */
    public controllerInfo(options?: RawAxiosRequestConfig) {
        return ControllerInfoApiFp(this.configuration).controllerInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a GitHub credential.
         * @param {CreateGithubCredentialsParams} body Parameters used when creating a GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredentials: async (body: CreateGithubCredentialsParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createCredentials', 'body', body)
            const localVarPath = `/github/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Gitea credential.
         * @param {CreateGiteaCredentialsParams} body Parameters used when creating a Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGiteaCredentials: async (body: CreateGiteaCredentialsParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createGiteaCredentials', 'body', body)
            const localVarPath = `/gitea/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a GitHub credential.
         * @param {number} id ID of the GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredentials: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCredentials', 'id', id)
            const localVarPath = `/github/credentials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Gitea credential.
         * @param {number} id ID of the Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGiteaCredentials: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGiteaCredentials', 'id', id)
            const localVarPath = `/gitea/credentials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a GitHub credential.
         * @param {number} id ID of the GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredentials: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCredentials', 'id', id)
            const localVarPath = `/github/credentials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Gitea credential.
         * @param {number} id ID of the Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiteaCredentials: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGiteaCredentials', 'id', id)
            const localVarPath = `/gitea/credentials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/github/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGiteaCredentials: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gitea/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a GitHub credential.
         * @param {number} id ID of the GitHub credential.
         * @param {UpdateGithubCredentialsParams} body Parameters used when updating a GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredentials: async (id: number, body: UpdateGithubCredentialsParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCredentials', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateCredentials', 'body', body)
            const localVarPath = `/github/credentials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Gitea credential.
         * @param {number} id ID of the Gitea credential.
         * @param {UpdateGiteaCredentialsParams} body Parameters used when updating a Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGiteaCredentials: async (id: number, body: UpdateGiteaCredentialsParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGiteaCredentials', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateGiteaCredentials', 'body', body)
            const localVarPath = `/gitea/credentials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a GitHub credential.
         * @param {CreateGithubCredentialsParams} body Parameters used when creating a GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredentials(body: CreateGithubCredentialsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredentials(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.createCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a Gitea credential.
         * @param {CreateGiteaCredentialsParams} body Parameters used when creating a Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGiteaCredentials(body: CreateGiteaCredentialsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGiteaCredentials(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.createGiteaCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a GitHub credential.
         * @param {number} id ID of the GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredentials(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredentials(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.deleteCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Gitea credential.
         * @param {number} id ID of the Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGiteaCredentials(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGiteaCredentials(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.deleteGiteaCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a GitHub credential.
         * @param {number} id ID of the GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredentials(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredentials(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.getCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a Gitea credential.
         * @param {number} id ID of the Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGiteaCredentials(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGiteaCredentials(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.getGiteaCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredentials(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ForgeCredentials>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredentials(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.listCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGiteaCredentials(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ForgeCredentials>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGiteaCredentials(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.listGiteaCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a GitHub credential.
         * @param {number} id ID of the GitHub credential.
         * @param {UpdateGithubCredentialsParams} body Parameters used when updating a GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredentials(id: number, body: UpdateGithubCredentialsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredentials(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.updateCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Gitea credential.
         * @param {number} id ID of the Gitea credential.
         * @param {UpdateGiteaCredentialsParams} body Parameters used when updating a Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGiteaCredentials(id: number, body: UpdateGiteaCredentialsParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGiteaCredentials(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CredentialsApi.updateGiteaCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a GitHub credential.
         * @param {CreateGithubCredentialsParams} body Parameters used when creating a GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredentials(body: CreateGithubCredentialsParams, options?: RawAxiosRequestConfig): AxiosPromise<ForgeCredentials> {
            return localVarFp.createCredentials(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Gitea credential.
         * @param {CreateGiteaCredentialsParams} body Parameters used when creating a Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGiteaCredentials(body: CreateGiteaCredentialsParams, options?: RawAxiosRequestConfig): AxiosPromise<ForgeCredentials> {
            return localVarFp.createGiteaCredentials(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a GitHub credential.
         * @param {number} id ID of the GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredentials(id: number, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteCredentials(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Gitea credential.
         * @param {number} id ID of the Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGiteaCredentials(id: number, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteGiteaCredentials(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a GitHub credential.
         * @param {number} id ID of the GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredentials(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ForgeCredentials> {
            return localVarFp.getCredentials(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Gitea credential.
         * @param {number} id ID of the Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiteaCredentials(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ForgeCredentials> {
            return localVarFp.getGiteaCredentials(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(options?: RawAxiosRequestConfig): AxiosPromise<Array<ForgeCredentials>> {
            return localVarFp.listCredentials(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGiteaCredentials(options?: RawAxiosRequestConfig): AxiosPromise<Array<ForgeCredentials>> {
            return localVarFp.listGiteaCredentials(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a GitHub credential.
         * @param {number} id ID of the GitHub credential.
         * @param {UpdateGithubCredentialsParams} body Parameters used when updating a GitHub credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredentials(id: number, body: UpdateGithubCredentialsParams, options?: RawAxiosRequestConfig): AxiosPromise<ForgeCredentials> {
            return localVarFp.updateCredentials(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Gitea credential.
         * @param {number} id ID of the Gitea credential.
         * @param {UpdateGiteaCredentialsParams} body Parameters used when updating a Gitea credential.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGiteaCredentials(id: number, body: UpdateGiteaCredentialsParams, options?: RawAxiosRequestConfig): AxiosPromise<ForgeCredentials> {
            return localVarFp.updateGiteaCredentials(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI {
    /**
     * 
     * @summary Create a GitHub credential.
     * @param {CreateGithubCredentialsParams} body Parameters used when creating a GitHub credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public createCredentials(body: CreateGithubCredentialsParams, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).createCredentials(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Gitea credential.
     * @param {CreateGiteaCredentialsParams} body Parameters used when creating a Gitea credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public createGiteaCredentials(body: CreateGiteaCredentialsParams, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).createGiteaCredentials(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a GitHub credential.
     * @param {number} id ID of the GitHub credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public deleteCredentials(id: number, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).deleteCredentials(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Gitea credential.
     * @param {number} id ID of the Gitea credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public deleteGiteaCredentials(id: number, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).deleteGiteaCredentials(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a GitHub credential.
     * @param {number} id ID of the GitHub credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public getCredentials(id: number, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).getCredentials(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Gitea credential.
     * @param {number} id ID of the Gitea credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public getGiteaCredentials(id: number, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).getGiteaCredentials(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public listCredentials(options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).listCredentials(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public listGiteaCredentials(options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).listGiteaCredentials(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a GitHub credential.
     * @param {number} id ID of the GitHub credential.
     * @param {UpdateGithubCredentialsParams} body Parameters used when updating a GitHub credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public updateCredentials(id: number, body: UpdateGithubCredentialsParams, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).updateCredentials(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Gitea credential.
     * @param {number} id ID of the Gitea credential.
     * @param {UpdateGiteaCredentialsParams} body Parameters used when updating a Gitea credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public updateGiteaCredentials(id: number, body: UpdateGiteaCredentialsParams, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).updateGiteaCredentials(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EndpointsApi - axios parameter creator
 * @export
 */
export const EndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Gitea Endpoint.
         * @param {CreateGiteaEndpointParams} body Parameters used when creating a Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGiteaEndpoint: async (body: CreateGiteaEndpointParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createGiteaEndpoint', 'body', body)
            const localVarPath = `/gitea/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a GitHub Endpoint.
         * @param {CreateGithubEndpointParams} body Parameters used when creating a GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGithubEndpoint: async (body: CreateGithubEndpointParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createGithubEndpoint', 'body', body)
            const localVarPath = `/github/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Gitea Endpoint.
         * @param {string} name The name of the Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGiteaEndpoint: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteGiteaEndpoint', 'name', name)
            const localVarPath = `/gitea/endpoints/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a GitHub Endpoint.
         * @param {string} name The name of the GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGithubEndpoint: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteGithubEndpoint', 'name', name)
            const localVarPath = `/github/endpoints/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Gitea Endpoint.
         * @param {string} name The name of the Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiteaEndpoint: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getGiteaEndpoint', 'name', name)
            const localVarPath = `/gitea/endpoints/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a GitHub Endpoint.
         * @param {string} name The name of the GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGithubEndpoint: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getGithubEndpoint', 'name', name)
            const localVarPath = `/github/endpoints/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Gitea Endpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGiteaEndpoints: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gitea/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all GitHub Endpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGithubEndpoints: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/github/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Gitea Endpoint.
         * @param {string} name The name of the Gitea endpoint.
         * @param {UpdateGiteaEndpointParams} body Parameters used when updating a Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGiteaEndpoint: async (name: string, body: UpdateGiteaEndpointParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateGiteaEndpoint', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateGiteaEndpoint', 'body', body)
            const localVarPath = `/gitea/endpoints/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a GitHub Endpoint.
         * @param {string} name The name of the GitHub endpoint.
         * @param {UpdateGithubEndpointParams} body Parameters used when updating a GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGithubEndpoint: async (name: string, body: UpdateGithubEndpointParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateGithubEndpoint', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateGithubEndpoint', 'body', body)
            const localVarPath = `/github/endpoints/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndpointsApi - functional programming interface
 * @export
 */
export const EndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Gitea Endpoint.
         * @param {CreateGiteaEndpointParams} body Parameters used when creating a Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGiteaEndpoint(body: CreateGiteaEndpointParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGiteaEndpoint(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndpointsApi.createGiteaEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a GitHub Endpoint.
         * @param {CreateGithubEndpointParams} body Parameters used when creating a GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGithubEndpoint(body: CreateGithubEndpointParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGithubEndpoint(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndpointsApi.createGithubEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Gitea Endpoint.
         * @param {string} name The name of the Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGiteaEndpoint(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGiteaEndpoint(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndpointsApi.deleteGiteaEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a GitHub Endpoint.
         * @param {string} name The name of the GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGithubEndpoint(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGithubEndpoint(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndpointsApi.deleteGithubEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a Gitea Endpoint.
         * @param {string} name The name of the Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGiteaEndpoint(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGiteaEndpoint(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndpointsApi.getGiteaEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a GitHub Endpoint.
         * @param {string} name The name of the GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGithubEndpoint(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGithubEndpoint(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndpointsApi.getGithubEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Gitea Endpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGiteaEndpoints(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ForgeEndpoint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGiteaEndpoints(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndpointsApi.listGiteaEndpoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all GitHub Endpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGithubEndpoints(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ForgeEndpoint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGithubEndpoints(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndpointsApi.listGithubEndpoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Gitea Endpoint.
         * @param {string} name The name of the Gitea endpoint.
         * @param {UpdateGiteaEndpointParams} body Parameters used when updating a Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGiteaEndpoint(name: string, body: UpdateGiteaEndpointParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGiteaEndpoint(name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndpointsApi.updateGiteaEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a GitHub Endpoint.
         * @param {string} name The name of the GitHub endpoint.
         * @param {UpdateGithubEndpointParams} body Parameters used when updating a GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGithubEndpoint(name: string, body: UpdateGithubEndpointParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgeEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGithubEndpoint(name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndpointsApi.updateGithubEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EndpointsApi - factory interface
 * @export
 */
export const EndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EndpointsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Gitea Endpoint.
         * @param {CreateGiteaEndpointParams} body Parameters used when creating a Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGiteaEndpoint(body: CreateGiteaEndpointParams, options?: RawAxiosRequestConfig): AxiosPromise<ForgeEndpoint> {
            return localVarFp.createGiteaEndpoint(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a GitHub Endpoint.
         * @param {CreateGithubEndpointParams} body Parameters used when creating a GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGithubEndpoint(body: CreateGithubEndpointParams, options?: RawAxiosRequestConfig): AxiosPromise<ForgeEndpoint> {
            return localVarFp.createGithubEndpoint(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Gitea Endpoint.
         * @param {string} name The name of the Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGiteaEndpoint(name: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteGiteaEndpoint(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a GitHub Endpoint.
         * @param {string} name The name of the GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGithubEndpoint(name: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteGithubEndpoint(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Gitea Endpoint.
         * @param {string} name The name of the Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiteaEndpoint(name: string, options?: RawAxiosRequestConfig): AxiosPromise<ForgeEndpoint> {
            return localVarFp.getGiteaEndpoint(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a GitHub Endpoint.
         * @param {string} name The name of the GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGithubEndpoint(name: string, options?: RawAxiosRequestConfig): AxiosPromise<ForgeEndpoint> {
            return localVarFp.getGithubEndpoint(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Gitea Endpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGiteaEndpoints(options?: RawAxiosRequestConfig): AxiosPromise<Array<ForgeEndpoint>> {
            return localVarFp.listGiteaEndpoints(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all GitHub Endpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGithubEndpoints(options?: RawAxiosRequestConfig): AxiosPromise<Array<ForgeEndpoint>> {
            return localVarFp.listGithubEndpoints(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Gitea Endpoint.
         * @param {string} name The name of the Gitea endpoint.
         * @param {UpdateGiteaEndpointParams} body Parameters used when updating a Gitea endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGiteaEndpoint(name: string, body: UpdateGiteaEndpointParams, options?: RawAxiosRequestConfig): AxiosPromise<ForgeEndpoint> {
            return localVarFp.updateGiteaEndpoint(name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a GitHub Endpoint.
         * @param {string} name The name of the GitHub endpoint.
         * @param {UpdateGithubEndpointParams} body Parameters used when updating a GitHub endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGithubEndpoint(name: string, body: UpdateGithubEndpointParams, options?: RawAxiosRequestConfig): AxiosPromise<ForgeEndpoint> {
            return localVarFp.updateGithubEndpoint(name, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EndpointsApi - object-oriented interface
 * @export
 * @class EndpointsApi
 * @extends {BaseAPI}
 */
export class EndpointsApi extends BaseAPI {
    /**
     * 
     * @summary Create a Gitea Endpoint.
     * @param {CreateGiteaEndpointParams} body Parameters used when creating a Gitea endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public createGiteaEndpoint(body: CreateGiteaEndpointParams, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).createGiteaEndpoint(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a GitHub Endpoint.
     * @param {CreateGithubEndpointParams} body Parameters used when creating a GitHub endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public createGithubEndpoint(body: CreateGithubEndpointParams, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).createGithubEndpoint(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Gitea Endpoint.
     * @param {string} name The name of the Gitea endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public deleteGiteaEndpoint(name: string, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).deleteGiteaEndpoint(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a GitHub Endpoint.
     * @param {string} name The name of the GitHub endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public deleteGithubEndpoint(name: string, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).deleteGithubEndpoint(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Gitea Endpoint.
     * @param {string} name The name of the Gitea endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public getGiteaEndpoint(name: string, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).getGiteaEndpoint(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a GitHub Endpoint.
     * @param {string} name The name of the GitHub endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public getGithubEndpoint(name: string, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).getGithubEndpoint(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Gitea Endpoints.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public listGiteaEndpoints(options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).listGiteaEndpoints(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all GitHub Endpoints.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public listGithubEndpoints(options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).listGithubEndpoints(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Gitea Endpoint.
     * @param {string} name The name of the Gitea endpoint.
     * @param {UpdateGiteaEndpointParams} body Parameters used when updating a Gitea endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public updateGiteaEndpoint(name: string, body: UpdateGiteaEndpointParams, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).updateGiteaEndpoint(name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a GitHub Endpoint.
     * @param {string} name The name of the GitHub endpoint.
     * @param {UpdateGithubEndpointParams} body Parameters used when updating a GitHub endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public updateGithubEndpoint(name: string, body: UpdateGithubEndpointParams, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).updateGithubEndpoint(name, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnterprisesApi - axios parameter creator
 * @export
 */
export const EnterprisesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create enterprise with the given parameters.
         * @param {CreateEnterpriseParams} body Parameters used to create the enterprise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterprise: async (body: CreateEnterpriseParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createEnterprise', 'body', body)
            const localVarPath = `/enterprises`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreatePoolParams} body Parameters used when creating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterprisePool: async (enterpriseID: string, body: CreatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('createEnterprisePool', 'enterpriseID', enterpriseID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createEnterprisePool', 'body', body)
            const localVarPath = `/enterprises/{enterpriseID}/pools`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the enterprise scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterpriseScaleSet: async (enterpriseID: string, body: CreateScaleSetParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('createEnterpriseScaleSet', 'enterpriseID', enterpriseID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createEnterpriseScaleSet', 'body', body)
            const localVarPath = `/enterprises/{enterpriseID}/scalesets`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete enterprise by ID.
         * @param {string} enterpriseID ID of the enterprise to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnterprise: async (enterpriseID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('deleteEnterprise', 'enterpriseID', enterpriseID)
            const localVarPath = `/enterprises/{enterpriseID}`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnterprisePool: async (enterpriseID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('deleteEnterprisePool', 'enterpriseID', enterpriseID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('deleteEnterprisePool', 'poolID', poolID)
            const localVarPath = `/enterprises/{enterpriseID}/pools/{poolID}`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get enterprise by ID.
         * @param {string} enterpriseID The ID of the enterprise to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnterprise: async (enterpriseID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('getEnterprise', 'enterpriseID', enterpriseID)
            const localVarPath = `/enterprises/{enterpriseID}`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnterprisePool: async (enterpriseID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('getEnterprisePool', 'enterpriseID', enterpriseID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('getEnterprisePool', 'poolID', poolID)
            const localVarPath = `/enterprises/{enterpriseID}/pools/{poolID}`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List enterprise instances.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterpriseInstances: async (enterpriseID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('listEnterpriseInstances', 'enterpriseID', enterpriseID)
            const localVarPath = `/enterprises/{enterpriseID}/instances`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List enterprise pools.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterprisePools: async (enterpriseID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('listEnterprisePools', 'enterpriseID', enterpriseID)
            const localVarPath = `/enterprises/{enterpriseID}/pools`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List enterprise scale sets.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterpriseScaleSets: async (enterpriseID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('listEnterpriseScaleSets', 'enterpriseID', enterpriseID)
            const localVarPath = `/enterprises/{enterpriseID}/scalesets`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all enterprises.
         * @param {string} [name] Exact enterprise name to filter by
         * @param {string} [endpoint] Exact endpoint name to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterprises: async (name?: string, endpoint?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/enterprises`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (endpoint !== undefined) {
                localVarQueryParameter['endpoint'] = endpoint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update enterprise with the given parameters.
         * @param {string} enterpriseID The ID of the enterprise to update.
         * @param {UpdateEntityParams} body Parameters used when updating the enterprise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnterprise: async (enterpriseID: string, body: UpdateEntityParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('updateEnterprise', 'enterpriseID', enterpriseID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateEnterprise', 'body', body)
            const localVarPath = `/enterprises/{enterpriseID}`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnterprisePool: async (enterpriseID: string, poolID: string, body: UpdatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('updateEnterprisePool', 'enterpriseID', enterpriseID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('updateEnterprisePool', 'poolID', poolID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateEnterprisePool', 'body', body)
            const localVarPath = `/enterprises/{enterpriseID}/pools/{poolID}`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnterprisesApi - functional programming interface
 * @export
 */
export const EnterprisesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnterprisesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create enterprise with the given parameters.
         * @param {CreateEnterpriseParams} body Parameters used to create the enterprise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnterprise(body: CreateEnterpriseParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Enterprise>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnterprise(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.createEnterprise']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreatePoolParams} body Parameters used when creating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnterprisePool(enterpriseID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnterprisePool(enterpriseID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.createEnterprisePool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the enterprise scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnterpriseScaleSet(enterpriseID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScaleSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnterpriseScaleSet(enterpriseID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.createEnterpriseScaleSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete enterprise by ID.
         * @param {string} enterpriseID ID of the enterprise to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnterprise(enterpriseID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnterprise(enterpriseID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.deleteEnterprise']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnterprisePool(enterpriseID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.deleteEnterprisePool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get enterprise by ID.
         * @param {string} enterpriseID The ID of the enterprise to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnterprise(enterpriseID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Enterprise>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnterprise(enterpriseID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.getEnterprise']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnterprisePool(enterpriseID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.getEnterprisePool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List enterprise instances.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnterpriseInstances(enterpriseID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Instance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnterpriseInstances(enterpriseID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.listEnterpriseInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List enterprise pools.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnterprisePools(enterpriseID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnterprisePools(enterpriseID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.listEnterprisePools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List enterprise scale sets.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnterpriseScaleSets(enterpriseID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScaleSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnterpriseScaleSets(enterpriseID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.listEnterpriseScaleSets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all enterprises.
         * @param {string} [name] Exact enterprise name to filter by
         * @param {string} [endpoint] Exact endpoint name to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnterprises(name?: string, endpoint?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Enterprise>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnterprises(name, endpoint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.listEnterprises']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update enterprise with the given parameters.
         * @param {string} enterpriseID The ID of the enterprise to update.
         * @param {UpdateEntityParams} body Parameters used when updating the enterprise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnterprise(enterpriseID: string, body: UpdateEntityParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Enterprise>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnterprise(enterpriseID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.updateEnterprise']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnterprisePool(enterpriseID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnterprisePool(enterpriseID, poolID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterprisesApi.updateEnterprisePool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnterprisesApi - factory interface
 * @export
 */
export const EnterprisesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnterprisesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create enterprise with the given parameters.
         * @param {CreateEnterpriseParams} body Parameters used to create the enterprise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterprise(body: CreateEnterpriseParams, options?: RawAxiosRequestConfig): AxiosPromise<Enterprise> {
            return localVarFp.createEnterprise(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreatePoolParams} body Parameters used when creating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterprisePool(enterpriseID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.createEnterprisePool(enterpriseID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the enterprise scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterpriseScaleSet(enterpriseID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): AxiosPromise<ScaleSet> {
            return localVarFp.createEnterpriseScaleSet(enterpriseID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete enterprise by ID.
         * @param {string} enterpriseID ID of the enterprise to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnterprise(enterpriseID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteEnterprise(enterpriseID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteEnterprisePool(enterpriseID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get enterprise by ID.
         * @param {string} enterpriseID The ID of the enterprise to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnterprise(enterpriseID: string, options?: RawAxiosRequestConfig): AxiosPromise<Enterprise> {
            return localVarFp.getEnterprise(enterpriseID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.getEnterprisePool(enterpriseID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List enterprise instances.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterpriseInstances(enterpriseID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Instance>> {
            return localVarFp.listEnterpriseInstances(enterpriseID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List enterprise pools.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterprisePools(enterpriseID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Pool>> {
            return localVarFp.listEnterprisePools(enterpriseID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List enterprise scale sets.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterpriseScaleSets(enterpriseID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScaleSet>> {
            return localVarFp.listEnterpriseScaleSets(enterpriseID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all enterprises.
         * @param {string} [name] Exact enterprise name to filter by
         * @param {string} [endpoint] Exact endpoint name to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterprises(name?: string, endpoint?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Enterprise>> {
            return localVarFp.listEnterprises(name, endpoint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update enterprise with the given parameters.
         * @param {string} enterpriseID The ID of the enterprise to update.
         * @param {UpdateEntityParams} body Parameters used when updating the enterprise.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnterprise(enterpriseID: string, body: UpdateEntityParams, options?: RawAxiosRequestConfig): AxiosPromise<Enterprise> {
            return localVarFp.updateEnterprise(enterpriseID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnterprisePool(enterpriseID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.updateEnterprisePool(enterpriseID, poolID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnterprisesApi - object-oriented interface
 * @export
 * @class EnterprisesApi
 * @extends {BaseAPI}
 */
export class EnterprisesApi extends BaseAPI {
    /**
     * 
     * @summary Create enterprise with the given parameters.
     * @param {CreateEnterpriseParams} body Parameters used to create the enterprise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public createEnterprise(body: CreateEnterpriseParams, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).createEnterprise(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create enterprise pool with the parameters given.
     * @param {string} enterpriseID Enterprise ID.
     * @param {CreatePoolParams} body Parameters used when creating the enterprise pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public createEnterprisePool(enterpriseID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).createEnterprisePool(enterpriseID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create enterprise pool with the parameters given.
     * @param {string} enterpriseID Enterprise ID.
     * @param {CreateScaleSetParams} body Parameters used when creating the enterprise scale set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public createEnterpriseScaleSet(enterpriseID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).createEnterpriseScaleSet(enterpriseID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete enterprise by ID.
     * @param {string} enterpriseID ID of the enterprise to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public deleteEnterprise(enterpriseID: string, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).deleteEnterprise(enterpriseID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete enterprise pool by ID.
     * @param {string} enterpriseID Enterprise ID.
     * @param {string} poolID ID of the enterprise pool to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public deleteEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).deleteEnterprisePool(enterpriseID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get enterprise by ID.
     * @param {string} enterpriseID The ID of the enterprise to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public getEnterprise(enterpriseID: string, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).getEnterprise(enterpriseID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get enterprise pool by ID.
     * @param {string} enterpriseID Enterprise ID.
     * @param {string} poolID Pool ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public getEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).getEnterprisePool(enterpriseID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List enterprise instances.
     * @param {string} enterpriseID Enterprise ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public listEnterpriseInstances(enterpriseID: string, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).listEnterpriseInstances(enterpriseID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List enterprise pools.
     * @param {string} enterpriseID Enterprise ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public listEnterprisePools(enterpriseID: string, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).listEnterprisePools(enterpriseID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List enterprise scale sets.
     * @param {string} enterpriseID Enterprise ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public listEnterpriseScaleSets(enterpriseID: string, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).listEnterpriseScaleSets(enterpriseID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all enterprises.
     * @param {string} [name] Exact enterprise name to filter by
     * @param {string} [endpoint] Exact endpoint name to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public listEnterprises(name?: string, endpoint?: string, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).listEnterprises(name, endpoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update enterprise with the given parameters.
     * @param {string} enterpriseID The ID of the enterprise to update.
     * @param {UpdateEntityParams} body Parameters used when updating the enterprise.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public updateEnterprise(enterpriseID: string, body: UpdateEntityParams, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).updateEnterprise(enterpriseID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update enterprise pool with the parameters given.
     * @param {string} enterpriseID Enterprise ID.
     * @param {string} poolID ID of the enterprise pool to update.
     * @param {UpdatePoolParams} body Parameters used when updating the enterprise pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterprisesApi
     */
    public updateEnterprisePool(enterpriseID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig) {
        return EnterprisesApiFp(this.configuration).updateEnterprisePool(enterpriseID, poolID, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FirstRunApi - axios parameter creator
 * @export
 */
export const FirstRunApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Initialize the first run of the controller.
         * @param {NewUserParams} body Create a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firstRun: async (body: NewUserParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('firstRun', 'body', body)
            const localVarPath = `/first-run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FirstRunApi - functional programming interface
 * @export
 */
export const FirstRunApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FirstRunApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Initialize the first run of the controller.
         * @param {NewUserParams} body Create a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async firstRun(body: NewUserParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.firstRun(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirstRunApi.firstRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FirstRunApi - factory interface
 * @export
 */
export const FirstRunApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FirstRunApiFp(configuration)
    return {
        /**
         * 
         * @summary Initialize the first run of the controller.
         * @param {NewUserParams} body Create a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firstRun(body: NewUserParams, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.firstRun(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FirstRunApi - object-oriented interface
 * @export
 * @class FirstRunApi
 * @extends {BaseAPI}
 */
export class FirstRunApi extends BaseAPI {
    /**
     * 
     * @summary Initialize the first run of the controller.
     * @param {NewUserParams} body Create a new user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirstRunApi
     */
    public firstRun(body: NewUserParams, options?: RawAxiosRequestConfig) {
        return FirstRunApiFp(this.configuration).firstRun(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HooksApi - axios parameter creator
 * @export
 */
export const HooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get information about the GARM installed webhook on an organization.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgWebhookInfo: async (orgID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('getOrgWebhookInfo', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}/webhook`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about the GARM installed webhook on a repository.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepoWebhookInfo: async (repoID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('getRepoWebhookInfo', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}/webhook`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} orgID Organization ID.
         * @param {InstallWebhookParams} body Parameters used when creating the organization webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installOrgWebhook: async (orgID: string, body: InstallWebhookParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('installOrgWebhook', 'orgID', orgID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('installOrgWebhook', 'body', body)
            const localVarPath = `/organizations/{orgID}/webhook`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} repoID Repository ID.
         * @param {InstallWebhookParams} body Parameters used when creating the repository webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installRepoWebhook: async (repoID: string, body: InstallWebhookParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('installRepoWebhook', 'repoID', repoID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('installRepoWebhook', 'body', body)
            const localVarPath = `/repositories/{repoID}/webhook`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallOrgWebhook: async (orgID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('uninstallOrgWebhook', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}/webhook`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallRepoWebhook: async (repoID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('uninstallRepoWebhook', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}/webhook`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HooksApi - functional programming interface
 * @export
 */
export const HooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get information about the GARM installed webhook on an organization.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgWebhookInfo(orgID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgWebhookInfo(orgID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.getOrgWebhookInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about the GARM installed webhook on a repository.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepoWebhookInfo(repoID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepoWebhookInfo(repoID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.getRepoWebhookInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} orgID Organization ID.
         * @param {InstallWebhookParams} body Parameters used when creating the organization webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installOrgWebhook(orgID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installOrgWebhook(orgID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.installOrgWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} repoID Repository ID.
         * @param {InstallWebhookParams} body Parameters used when creating the repository webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installRepoWebhook(repoID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installRepoWebhook(repoID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.installRepoWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallOrgWebhook(orgID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallOrgWebhook(orgID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.uninstallOrgWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallRepoWebhook(repoID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallRepoWebhook(repoID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.uninstallRepoWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HooksApi - factory interface
 * @export
 */
export const HooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Get information about the GARM installed webhook on an organization.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgWebhookInfo(orgID: string, options?: RawAxiosRequestConfig): AxiosPromise<HookInfo> {
            return localVarFp.getOrgWebhookInfo(orgID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about the GARM installed webhook on a repository.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepoWebhookInfo(repoID: string, options?: RawAxiosRequestConfig): AxiosPromise<HookInfo> {
            return localVarFp.getRepoWebhookInfo(repoID, options).then((request) => request(axios, basePath));
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} orgID Organization ID.
         * @param {InstallWebhookParams} body Parameters used when creating the organization webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installOrgWebhook(orgID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig): AxiosPromise<HookInfo> {
            return localVarFp.installOrgWebhook(orgID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} repoID Repository ID.
         * @param {InstallWebhookParams} body Parameters used when creating the repository webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installRepoWebhook(repoID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig): AxiosPromise<HookInfo> {
            return localVarFp.installRepoWebhook(repoID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallOrgWebhook(orgID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.uninstallOrgWebhook(orgID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallRepoWebhook(repoID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.uninstallRepoWebhook(repoID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HooksApi - object-oriented interface
 * @export
 * @class HooksApi
 * @extends {BaseAPI}
 */
export class HooksApi extends BaseAPI {
    /**
     * 
     * @summary Get information about the GARM installed webhook on an organization.
     * @param {string} orgID Organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public getOrgWebhookInfo(orgID: string, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).getOrgWebhookInfo(orgID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about the GARM installed webhook on a repository.
     * @param {string} repoID Repository ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public getRepoWebhookInfo(repoID: string, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).getRepoWebhookInfo(repoID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
     * @param {string} orgID Organization ID.
     * @param {InstallWebhookParams} body Parameters used when creating the organization webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public installOrgWebhook(orgID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).installOrgWebhook(orgID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
     * @param {string} repoID Repository ID.
     * @param {InstallWebhookParams} body Parameters used when creating the repository webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public installRepoWebhook(repoID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).installRepoWebhook(repoID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uninstall organization webhook.
     * @param {string} orgID Organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public uninstallOrgWebhook(orgID: string, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).uninstallOrgWebhook(orgID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uninstall organization webhook.
     * @param {string} repoID Repository ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public uninstallRepoWebhook(repoID: string, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).uninstallRepoWebhook(repoID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InstancesApi - axios parameter creator
 * @export
 */
export const InstancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete runner instance by name.
         * @param {string} instanceName Runner instance name.
         * @param {boolean} [forceRemove] If true GARM will ignore any provider error when removing the runner and will continue to remove the runner from github and the GARM database.
         * @param {boolean} [bypassGHUnauthorized] If true GARM will ignore unauthorized errors returned by GitHub when removing a runner. This is useful if you want to clean up runners and your credentials have expired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstance: async (instanceName: string, forceRemove?: boolean, bypassGHUnauthorized?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceName' is not null or undefined
            assertParamExists('deleteInstance', 'instanceName', instanceName)
            const localVarPath = `/instances/{instanceName}`
                .replace(`{${"instanceName"}}`, encodeURIComponent(String(instanceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (forceRemove !== undefined) {
                localVarQueryParameter['forceRemove'] = forceRemove;
            }

            if (bypassGHUnauthorized !== undefined) {
                localVarQueryParameter['bypassGHUnauthorized'] = bypassGHUnauthorized;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get runner instance by name.
         * @param {string} instanceName Runner instance name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance: async (instanceName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceName' is not null or undefined
            assertParamExists('getInstance', 'instanceName', instanceName)
            const localVarPath = `/instances/{instanceName}`
                .replace(`{${"instanceName"}}`, encodeURIComponent(String(instanceName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List enterprise instances.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterpriseInstances: async (enterpriseID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('listEnterpriseInstances', 'enterpriseID', enterpriseID)
            const localVarPath = `/enterprises/{enterpriseID}/instances`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all runners\' instances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstances: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization instances.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgInstances: async (orgID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('listOrgInstances', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}/instances`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runner instances in a pool.
         * @param {string} poolID Runner pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPoolInstances: async (poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('listPoolInstances', 'poolID', poolID)
            const localVarPath = `/pools/{poolID}/instances`
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List repository instances.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoInstances: async (repoID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('listRepoInstances', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}/instances`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runner instances in a scale set.
         * @param {string} scalesetID Runner scale set ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScaleSetInstances: async (scalesetID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scalesetID' is not null or undefined
            assertParamExists('listScaleSetInstances', 'scalesetID', scalesetID)
            const localVarPath = `/scalesets/{scalesetID}/instances`
                .replace(`{${"scalesetID"}}`, encodeURIComponent(String(scalesetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstancesApi - functional programming interface
 * @export
 */
export const InstancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InstancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete runner instance by name.
         * @param {string} instanceName Runner instance name.
         * @param {boolean} [forceRemove] If true GARM will ignore any provider error when removing the runner and will continue to remove the runner from github and the GARM database.
         * @param {boolean} [bypassGHUnauthorized] If true GARM will ignore unauthorized errors returned by GitHub when removing a runner. This is useful if you want to clean up runners and your credentials have expired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInstance(instanceName: string, forceRemove?: boolean, bypassGHUnauthorized?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInstance(instanceName, forceRemove, bypassGHUnauthorized, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.deleteInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get runner instance by name.
         * @param {string} instanceName Runner instance name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstance(instanceName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstance(instanceName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.getInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List enterprise instances.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnterpriseInstances(enterpriseID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Instance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnterpriseInstances(enterpriseID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.listEnterpriseInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all runners\' instances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInstances(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Instance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInstances(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.listInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization instances.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgInstances(orgID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Instance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgInstances(orgID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.listOrgInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List runner instances in a pool.
         * @param {string} poolID Runner pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPoolInstances(poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Instance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPoolInstances(poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.listPoolInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List repository instances.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepoInstances(repoID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Instance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepoInstances(repoID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.listRepoInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List runner instances in a scale set.
         * @param {string} scalesetID Runner scale set ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScaleSetInstances(scalesetID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Instance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScaleSetInstances(scalesetID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.listScaleSetInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InstancesApi - factory interface
 * @export
 */
export const InstancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InstancesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete runner instance by name.
         * @param {string} instanceName Runner instance name.
         * @param {boolean} [forceRemove] If true GARM will ignore any provider error when removing the runner and will continue to remove the runner from github and the GARM database.
         * @param {boolean} [bypassGHUnauthorized] If true GARM will ignore unauthorized errors returned by GitHub when removing a runner. This is useful if you want to clean up runners and your credentials have expired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstance(instanceName: string, forceRemove?: boolean, bypassGHUnauthorized?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteInstance(instanceName, forceRemove, bypassGHUnauthorized, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get runner instance by name.
         * @param {string} instanceName Runner instance name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance(instanceName: string, options?: RawAxiosRequestConfig): AxiosPromise<Instance> {
            return localVarFp.getInstance(instanceName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List enterprise instances.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterpriseInstances(enterpriseID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Instance>> {
            return localVarFp.listEnterpriseInstances(enterpriseID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all runners\' instances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstances(options?: RawAxiosRequestConfig): AxiosPromise<Array<Instance>> {
            return localVarFp.listInstances(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization instances.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgInstances(orgID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Instance>> {
            return localVarFp.listOrgInstances(orgID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List runner instances in a pool.
         * @param {string} poolID Runner pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPoolInstances(poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Instance>> {
            return localVarFp.listPoolInstances(poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List repository instances.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoInstances(repoID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Instance>> {
            return localVarFp.listRepoInstances(repoID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List runner instances in a scale set.
         * @param {string} scalesetID Runner scale set ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScaleSetInstances(scalesetID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Instance>> {
            return localVarFp.listScaleSetInstances(scalesetID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InstancesApi - object-oriented interface
 * @export
 * @class InstancesApi
 * @extends {BaseAPI}
 */
export class InstancesApi extends BaseAPI {
    /**
     * 
     * @summary Delete runner instance by name.
     * @param {string} instanceName Runner instance name.
     * @param {boolean} [forceRemove] If true GARM will ignore any provider error when removing the runner and will continue to remove the runner from github and the GARM database.
     * @param {boolean} [bypassGHUnauthorized] If true GARM will ignore unauthorized errors returned by GitHub when removing a runner. This is useful if you want to clean up runners and your credentials have expired.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public deleteInstance(instanceName: string, forceRemove?: boolean, bypassGHUnauthorized?: boolean, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).deleteInstance(instanceName, forceRemove, bypassGHUnauthorized, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get runner instance by name.
     * @param {string} instanceName Runner instance name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public getInstance(instanceName: string, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).getInstance(instanceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List enterprise instances.
     * @param {string} enterpriseID Enterprise ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public listEnterpriseInstances(enterpriseID: string, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).listEnterpriseInstances(enterpriseID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all runners\' instances.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public listInstances(options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).listInstances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization instances.
     * @param {string} orgID Organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public listOrgInstances(orgID: string, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).listOrgInstances(orgID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List runner instances in a pool.
     * @param {string} poolID Runner pool ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public listPoolInstances(poolID: string, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).listPoolInstances(poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List repository instances.
     * @param {string} repoID Repository ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public listRepoInstances(repoID: string, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).listRepoInstances(repoID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List runner instances in a scale set.
     * @param {string} scalesetID Runner scale set ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public listScaleSetInstances(scalesetID: string, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).listScaleSetInstances(scalesetID, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all jobs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all jobs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Job>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.listJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * 
         * @summary List all jobs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(options?: RawAxiosRequestConfig): AxiosPromise<Array<Job>> {
            return localVarFp.listJobs(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * 
     * @summary List all jobs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public listJobs(options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).listJobs(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Logs in a user and returns a JWT token.
         * @param {PasswordLoginParams} body Login information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (body: PasswordLoginParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('login', 'body', body)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Logs in a user and returns a JWT token.
         * @param {PasswordLoginParams} body Login information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(body: PasswordLoginParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JWTResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoginApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginApiFp(configuration)
    return {
        /**
         * 
         * @summary Logs in a user and returns a JWT token.
         * @param {PasswordLoginParams} body Login information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: PasswordLoginParams, options?: RawAxiosRequestConfig): AxiosPromise<JWTResponse> {
            return localVarFp.login(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     * 
     * @summary Logs in a user and returns a JWT token.
     * @param {PasswordLoginParams} body Login information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public login(body: PasswordLoginParams, options?: RawAxiosRequestConfig) {
        return LoginApiFp(this.configuration).login(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsTokenApi - axios parameter creator
 * @export
 */
export const MetricsTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a JWT token that can be used to access the metrics endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsTokenApi - functional programming interface
 * @export
 */
export const MetricsTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsTokenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a JWT token that can be used to access the metrics endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JWTResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsTokenApi.getMetricsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricsTokenApi - factory interface
 * @export
 */
export const MetricsTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsTokenApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a JWT token that can be used to access the metrics endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsToken(options?: RawAxiosRequestConfig): AxiosPromise<JWTResponse> {
            return localVarFp.getMetricsToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsTokenApi - object-oriented interface
 * @export
 * @class MetricsTokenApi
 * @extends {BaseAPI}
 */
export class MetricsTokenApi extends BaseAPI {
    /**
     * 
     * @summary Returns a JWT token that can be used to access the metrics endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsTokenApi
     */
    public getMetricsToken(options?: RawAxiosRequestConfig) {
        return MetricsTokenApiFp(this.configuration).getMetricsToken(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ObjectsApi - axios parameter creator
 * @export
 */
export const ObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a file object.
         * @param {string} objectID The ID of the file object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileObject: async (objectID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectID' is not null or undefined
            assertParamExists('deleteFileObject', 'objectID', objectID)
            const localVarPath = `/objects/{objectID}`
                .replace(`{${"objectID"}}`, encodeURIComponent(String(objectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file object.
         * @param {string} objectID The ID of the file object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileObject: async (objectID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectID' is not null or undefined
            assertParamExists('getFileObject', 'objectID', objectID)
            const localVarPath = `/objects/{objectID}`
                .replace(`{${"objectID"}}`, encodeURIComponent(String(objectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List file objects.
         * @param {string} [tags] List of tags to filter by.
         * @param {number} [page] The page at which to list.
         * @param {number} [pageSize] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFileObjects: async (tags?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a file object.
         * @param {string} objectID The ID of the file object.
         * @param {UpdateFileObjectParams} body Parameters used when updating a file object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFileObject: async (objectID: string, body: UpdateFileObjectParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectID' is not null or undefined
            assertParamExists('updateFileObject', 'objectID', objectID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateFileObject', 'body', body)
            const localVarPath = `/objects/{objectID}`
                .replace(`{${"objectID"}}`, encodeURIComponent(String(objectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectsApi - functional programming interface
 * @export
 */
export const ObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a file object.
         * @param {string} objectID The ID of the file object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileObject(objectID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileObject(objectID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectsApi.deleteFileObject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a file object.
         * @param {string} objectID The ID of the file object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileObject(objectID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileObject(objectID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectsApi.getFileObject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List file objects.
         * @param {string} [tags] List of tags to filter by.
         * @param {number} [page] The page at which to list.
         * @param {number} [pageSize] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFileObjects(tags?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObjectPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFileObjects(tags, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectsApi.listFileObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a file object.
         * @param {string} objectID The ID of the file object.
         * @param {UpdateFileObjectParams} body Parameters used when updating a file object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFileObject(objectID: string, body: UpdateFileObjectParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFileObject(objectID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectsApi.updateFileObject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ObjectsApi - factory interface
 * @export
 */
export const ObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a file object.
         * @param {string} objectID The ID of the file object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileObject(objectID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteFileObject(objectID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file object.
         * @param {string} objectID The ID of the file object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileObject(objectID: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.getFileObject(objectID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List file objects.
         * @param {string} [tags] List of tags to filter by.
         * @param {number} [page] The page at which to list.
         * @param {number} [pageSize] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFileObjects(tags?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<FileObjectPaginatedResponse> {
            return localVarFp.listFileObjects(tags, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a file object.
         * @param {string} objectID The ID of the file object.
         * @param {UpdateFileObjectParams} body Parameters used when updating a file object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFileObject(objectID: string, body: UpdateFileObjectParams, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.updateFileObject(objectID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectsApi - object-oriented interface
 * @export
 * @class ObjectsApi
 * @extends {BaseAPI}
 */
export class ObjectsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a file object.
     * @param {string} objectID The ID of the file object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectsApi
     */
    public deleteFileObject(objectID: string, options?: RawAxiosRequestConfig) {
        return ObjectsApiFp(this.configuration).deleteFileObject(objectID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a file object.
     * @param {string} objectID The ID of the file object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectsApi
     */
    public getFileObject(objectID: string, options?: RawAxiosRequestConfig) {
        return ObjectsApiFp(this.configuration).getFileObject(objectID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List file objects.
     * @param {string} [tags] List of tags to filter by.
     * @param {number} [page] The page at which to list.
     * @param {number} [pageSize] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectsApi
     */
    public listFileObjects(tags?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ObjectsApiFp(this.configuration).listFileObjects(tags, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a file object.
     * @param {string} objectID The ID of the file object.
     * @param {UpdateFileObjectParams} body Parameters used when updating a file object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectsApi
     */
    public updateFileObject(objectID: string, body: UpdateFileObjectParams, options?: RawAxiosRequestConfig) {
        return ObjectsApiFp(this.configuration).updateFileObject(objectID, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create organization with the parameters given.
         * @param {CreateOrgParams} body Parameters used when creating the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrg: async (body: CreateOrgParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrg', 'body', body)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreatePoolParams} body Parameters used when creating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgPool: async (orgID: string, body: CreatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('createOrgPool', 'orgID', orgID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrgPool', 'body', body)
            const localVarPath = `/organizations/{orgID}/pools`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create organization scale set with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the organization scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgScaleSet: async (orgID: string, body: CreateScaleSetParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('createOrgScaleSet', 'orgID', orgID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrgScaleSet', 'body', body)
            const localVarPath = `/organizations/{orgID}/scalesets`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization by ID.
         * @param {string} orgID ID of the organization to delete.
         * @param {boolean} [keepWebhook] If true and a webhook is installed for this organization, it will not be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrg: async (orgID: string, keepWebhook?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('deleteOrg', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (keepWebhook !== undefined) {
                localVarQueryParameter['keepWebhook'] = keepWebhook;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgPool: async (orgID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('deleteOrgPool', 'orgID', orgID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('deleteOrgPool', 'poolID', poolID)
            const localVarPath = `/organizations/{orgID}/pools/{poolID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization by ID.
         * @param {string} orgID ID of the organization to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrg: async (orgID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('getOrg', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgPool: async (orgID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('getOrgPool', 'orgID', orgID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('getOrgPool', 'poolID', poolID)
            const localVarPath = `/organizations/{orgID}/pools/{poolID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about the GARM installed webhook on an organization.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgWebhookInfo: async (orgID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('getOrgWebhookInfo', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}/webhook`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} orgID Organization ID.
         * @param {InstallWebhookParams} body Parameters used when creating the organization webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installOrgWebhook: async (orgID: string, body: InstallWebhookParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('installOrgWebhook', 'orgID', orgID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('installOrgWebhook', 'body', body)
            const localVarPath = `/organizations/{orgID}/webhook`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization instances.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgInstances: async (orgID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('listOrgInstances', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}/instances`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization pools.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgPools: async (orgID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('listOrgPools', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}/pools`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization scale sets.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgScaleSets: async (orgID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('listOrgScaleSets', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}/scalesets`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organizations.
         * @param {string} [name] Exact organization name to filter by
         * @param {string} [endpoint] Exact endpoint name to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgs: async (name?: string, endpoint?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (endpoint !== undefined) {
                localVarQueryParameter['endpoint'] = endpoint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallOrgWebhook: async (orgID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('uninstallOrgWebhook', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}/webhook`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization with the parameters given.
         * @param {string} orgID ID of the organization to update.
         * @param {UpdateEntityParams} body Parameters used when updating the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrg: async (orgID: string, body: UpdateEntityParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('updateOrg', 'orgID', orgID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateOrg', 'body', body)
            const localVarPath = `/organizations/{orgID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgPool: async (orgID: string, poolID: string, body: UpdatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('updateOrgPool', 'orgID', orgID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('updateOrgPool', 'poolID', poolID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateOrgPool', 'body', body)
            const localVarPath = `/organizations/{orgID}/pools/{poolID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create organization with the parameters given.
         * @param {CreateOrgParams} body Parameters used when creating the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrg(body: CreateOrgParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrg(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.createOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreatePoolParams} body Parameters used when creating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrgPool(orgID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrgPool(orgID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.createOrgPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create organization scale set with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the organization scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrgScaleSet(orgID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScaleSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrgScaleSet(orgID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.createOrgScaleSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete organization by ID.
         * @param {string} orgID ID of the organization to delete.
         * @param {boolean} [keepWebhook] If true and a webhook is installed for this organization, it will not be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrg(orgID: string, keepWebhook?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrg(orgID, keepWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.deleteOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrgPool(orgID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.deleteOrgPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get organization by ID.
         * @param {string} orgID ID of the organization to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrg(orgID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrg(orgID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.getOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgPool(orgID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.getOrgPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about the GARM installed webhook on an organization.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgWebhookInfo(orgID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgWebhookInfo(orgID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.getOrgWebhookInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} orgID Organization ID.
         * @param {InstallWebhookParams} body Parameters used when creating the organization webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installOrgWebhook(orgID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installOrgWebhook(orgID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.installOrgWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization instances.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgInstances(orgID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Instance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgInstances(orgID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrgInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization pools.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgPools(orgID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgPools(orgID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrgPools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization scale sets.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgScaleSets(orgID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScaleSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgScaleSets(orgID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrgScaleSets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organizations.
         * @param {string} [name] Exact organization name to filter by
         * @param {string} [endpoint] Exact endpoint name to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgs(name?: string, endpoint?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgs(name, endpoint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrgs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallOrgWebhook(orgID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallOrgWebhook(orgID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.uninstallOrgWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update organization with the parameters given.
         * @param {string} orgID ID of the organization to update.
         * @param {UpdateEntityParams} body Parameters used when updating the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrg(orgID: string, body: UpdateEntityParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrg(orgID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.updateOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrgPool(orgID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrgPool(orgID, poolID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.updateOrgPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create organization with the parameters given.
         * @param {CreateOrgParams} body Parameters used when creating the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrg(body: CreateOrgParams, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.createOrg(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreatePoolParams} body Parameters used when creating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgPool(orgID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.createOrgPool(orgID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create organization scale set with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the organization scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgScaleSet(orgID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): AxiosPromise<ScaleSet> {
            return localVarFp.createOrgScaleSet(orgID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organization by ID.
         * @param {string} orgID ID of the organization to delete.
         * @param {boolean} [keepWebhook] If true and a webhook is installed for this organization, it will not be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrg(orgID: string, keepWebhook?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteOrg(orgID, keepWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteOrgPool(orgID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization by ID.
         * @param {string} orgID ID of the organization to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrg(orgID: string, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.getOrg(orgID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.getOrgPool(orgID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about the GARM installed webhook on an organization.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgWebhookInfo(orgID: string, options?: RawAxiosRequestConfig): AxiosPromise<HookInfo> {
            return localVarFp.getOrgWebhookInfo(orgID, options).then((request) => request(axios, basePath));
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} orgID Organization ID.
         * @param {InstallWebhookParams} body Parameters used when creating the organization webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installOrgWebhook(orgID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig): AxiosPromise<HookInfo> {
            return localVarFp.installOrgWebhook(orgID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization instances.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgInstances(orgID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Instance>> {
            return localVarFp.listOrgInstances(orgID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization pools.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgPools(orgID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Pool>> {
            return localVarFp.listOrgPools(orgID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization scale sets.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgScaleSets(orgID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScaleSet>> {
            return localVarFp.listOrgScaleSets(orgID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organizations.
         * @param {string} [name] Exact organization name to filter by
         * @param {string} [endpoint] Exact endpoint name to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgs(name?: string, endpoint?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Organization>> {
            return localVarFp.listOrgs(name, endpoint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallOrgWebhook(orgID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.uninstallOrgWebhook(orgID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization with the parameters given.
         * @param {string} orgID ID of the organization to update.
         * @param {UpdateEntityParams} body Parameters used when updating the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrg(orgID: string, body: UpdateEntityParams, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.updateOrg(orgID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgPool(orgID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.updateOrgPool(orgID, poolID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @summary Create organization with the parameters given.
     * @param {CreateOrgParams} body Parameters used when creating the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createOrg(body: CreateOrgParams, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).createOrg(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create organization pool with the parameters given.
     * @param {string} orgID Organization ID.
     * @param {CreatePoolParams} body Parameters used when creating the organization pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createOrgPool(orgID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).createOrgPool(orgID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create organization scale set with the parameters given.
     * @param {string} orgID Organization ID.
     * @param {CreateScaleSetParams} body Parameters used when creating the organization scale set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createOrgScaleSet(orgID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).createOrgScaleSet(orgID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organization by ID.
     * @param {string} orgID ID of the organization to delete.
     * @param {boolean} [keepWebhook] If true and a webhook is installed for this organization, it will not be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrg(orgID: string, keepWebhook?: boolean, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).deleteOrg(orgID, keepWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organization pool by ID.
     * @param {string} orgID Organization ID.
     * @param {string} poolID ID of the organization pool to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).deleteOrgPool(orgID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization by ID.
     * @param {string} orgID ID of the organization to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrg(orgID: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).getOrg(orgID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization pool by ID.
     * @param {string} orgID Organization ID.
     * @param {string} poolID Pool ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).getOrgPool(orgID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about the GARM installed webhook on an organization.
     * @param {string} orgID Organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrgWebhookInfo(orgID: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).getOrgWebhookInfo(orgID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
     * @param {string} orgID Organization ID.
     * @param {InstallWebhookParams} body Parameters used when creating the organization webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public installOrgWebhook(orgID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).installOrgWebhook(orgID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization instances.
     * @param {string} orgID Organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrgInstances(orgID: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrgInstances(orgID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization pools.
     * @param {string} orgID Organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrgPools(orgID: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrgPools(orgID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization scale sets.
     * @param {string} orgID Organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrgScaleSets(orgID: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrgScaleSets(orgID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organizations.
     * @param {string} [name] Exact organization name to filter by
     * @param {string} [endpoint] Exact endpoint name to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrgs(name?: string, endpoint?: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrgs(name, endpoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uninstall organization webhook.
     * @param {string} orgID Organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public uninstallOrgWebhook(orgID: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).uninstallOrgWebhook(orgID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization with the parameters given.
     * @param {string} orgID ID of the organization to update.
     * @param {UpdateEntityParams} body Parameters used when updating the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrg(orgID: string, body: UpdateEntityParams, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).updateOrg(orgID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization pool with the parameters given.
     * @param {string} orgID Organization ID.
     * @param {string} poolID ID of the organization pool to update.
     * @param {UpdatePoolParams} body Parameters used when updating the organization pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrgPool(orgID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).updateOrgPool(orgID, poolID, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PoolsApi - axios parameter creator
 * @export
 */
export const PoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreatePoolParams} body Parameters used when creating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterprisePool: async (enterpriseID: string, body: CreatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('createEnterprisePool', 'enterpriseID', enterpriseID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createEnterprisePool', 'body', body)
            const localVarPath = `/enterprises/{enterpriseID}/pools`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreatePoolParams} body Parameters used when creating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgPool: async (orgID: string, body: CreatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('createOrgPool', 'orgID', orgID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrgPool', 'body', body)
            const localVarPath = `/organizations/{orgID}/pools`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreatePoolParams} body Parameters used when creating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepoPool: async (repoID: string, body: CreatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('createRepoPool', 'repoID', repoID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createRepoPool', 'body', body)
            const localVarPath = `/repositories/{repoID}/pools`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnterprisePool: async (enterpriseID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('deleteEnterprisePool', 'enterpriseID', enterpriseID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('deleteEnterprisePool', 'poolID', poolID)
            const localVarPath = `/enterprises/{enterpriseID}/pools/{poolID}`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgPool: async (orgID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('deleteOrgPool', 'orgID', orgID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('deleteOrgPool', 'poolID', poolID)
            const localVarPath = `/organizations/{orgID}/pools/{poolID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete pool by ID.
         * @param {string} poolID ID of the pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePool: async (poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('deletePool', 'poolID', poolID)
            const localVarPath = `/pools/{poolID}`
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepoPool: async (repoID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('deleteRepoPool', 'repoID', repoID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('deleteRepoPool', 'poolID', poolID)
            const localVarPath = `/repositories/{repoID}/pools/{poolID}`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnterprisePool: async (enterpriseID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('getEnterprisePool', 'enterpriseID', enterpriseID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('getEnterprisePool', 'poolID', poolID)
            const localVarPath = `/enterprises/{enterpriseID}/pools/{poolID}`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgPool: async (orgID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('getOrgPool', 'orgID', orgID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('getOrgPool', 'poolID', poolID)
            const localVarPath = `/organizations/{orgID}/pools/{poolID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pool by ID.
         * @param {string} poolID ID of the pool to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool: async (poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('getPool', 'poolID', poolID)
            const localVarPath = `/pools/{poolID}`
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepoPool: async (repoID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('getRepoPool', 'repoID', repoID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('getRepoPool', 'poolID', poolID)
            const localVarPath = `/repositories/{repoID}/pools/{poolID}`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List enterprise pools.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterprisePools: async (enterpriseID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('listEnterprisePools', 'enterpriseID', enterpriseID)
            const localVarPath = `/enterprises/{enterpriseID}/pools`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization pools.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgPools: async (orgID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('listOrgPools', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}/pools`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all pools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPools: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List repository pools.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoPools: async (repoID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('listRepoPools', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}/pools`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnterprisePool: async (enterpriseID: string, poolID: string, body: UpdatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('updateEnterprisePool', 'enterpriseID', enterpriseID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('updateEnterprisePool', 'poolID', poolID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateEnterprisePool', 'body', body)
            const localVarPath = `/enterprises/{enterpriseID}/pools/{poolID}`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgPool: async (orgID: string, poolID: string, body: UpdatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('updateOrgPool', 'orgID', orgID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('updateOrgPool', 'poolID', poolID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateOrgPool', 'body', body)
            const localVarPath = `/organizations/{orgID}/pools/{poolID}`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update pool by ID.
         * @param {string} poolID ID of the pool to update.
         * @param {UpdatePoolParams} body Parameters to update the pool with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePool: async (poolID: string, body: UpdatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('updatePool', 'poolID', poolID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePool', 'body', body)
            const localVarPath = `/pools/{poolID}`
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepoPool: async (repoID: string, poolID: string, body: UpdatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('updateRepoPool', 'repoID', repoID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('updateRepoPool', 'poolID', poolID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRepoPool', 'body', body)
            const localVarPath = `/repositories/{repoID}/pools/{poolID}`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoolsApi - functional programming interface
 * @export
 */
export const PoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreatePoolParams} body Parameters used when creating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnterprisePool(enterpriseID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnterprisePool(enterpriseID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.createEnterprisePool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreatePoolParams} body Parameters used when creating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrgPool(orgID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrgPool(orgID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.createOrgPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreatePoolParams} body Parameters used when creating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepoPool(repoID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepoPool(repoID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.createRepoPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnterprisePool(enterpriseID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.deleteEnterprisePool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrgPool(orgID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.deleteOrgPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete pool by ID.
         * @param {string} poolID ID of the pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePool(poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePool(poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.deletePool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepoPool(repoID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.deleteRepoPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnterprisePool(enterpriseID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.getEnterprisePool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgPool(orgID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.getOrgPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get pool by ID.
         * @param {string} poolID ID of the pool to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPool(poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPool(poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.getPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepoPool(repoID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.getRepoPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List enterprise pools.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnterprisePools(enterpriseID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnterprisePools(enterpriseID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.listEnterprisePools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization pools.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgPools(orgID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgPools(orgID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.listOrgPools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all pools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPools(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPools(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.listPools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List repository pools.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepoPools(repoID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepoPools(repoID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.listRepoPools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnterprisePool(enterpriseID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnterprisePool(enterpriseID, poolID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.updateEnterprisePool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrgPool(orgID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrgPool(orgID, poolID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.updateOrgPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update pool by ID.
         * @param {string} poolID ID of the pool to update.
         * @param {UpdatePoolParams} body Parameters to update the pool with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePool(poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePool(poolID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.updatePool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepoPool(repoID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepoPool(repoID, poolID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolsApi.updateRepoPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PoolsApi - factory interface
 * @export
 */
export const PoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoolsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreatePoolParams} body Parameters used when creating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterprisePool(enterpriseID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.createEnterprisePool(enterpriseID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreatePoolParams} body Parameters used when creating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgPool(orgID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.createOrgPool(orgID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreatePoolParams} body Parameters used when creating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepoPool(repoID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.createRepoPool(repoID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteEnterprisePool(enterpriseID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteOrgPool(orgID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete pool by ID.
         * @param {string} poolID ID of the pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePool(poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deletePool(poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteRepoPool(repoID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get enterprise pool by ID.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.getEnterprisePool(enterpriseID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization pool by ID.
         * @param {string} orgID Organization ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.getOrgPool(orgID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pool by ID.
         * @param {string} poolID ID of the pool to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.getPool(poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.getRepoPool(repoID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List enterprise pools.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterprisePools(enterpriseID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Pool>> {
            return localVarFp.listEnterprisePools(enterpriseID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization pools.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgPools(orgID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Pool>> {
            return localVarFp.listOrgPools(orgID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all pools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPools(options?: RawAxiosRequestConfig): AxiosPromise<Array<Pool>> {
            return localVarFp.listPools(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List repository pools.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoPools(repoID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Pool>> {
            return localVarFp.listRepoPools(repoID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {string} poolID ID of the enterprise pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the enterprise pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnterprisePool(enterpriseID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.updateEnterprisePool(enterpriseID, poolID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization pool with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {string} poolID ID of the organization pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the organization pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgPool(orgID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.updateOrgPool(orgID, poolID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update pool by ID.
         * @param {string} poolID ID of the pool to update.
         * @param {UpdatePoolParams} body Parameters to update the pool with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePool(poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.updatePool(poolID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepoPool(repoID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.updateRepoPool(repoID, poolID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoolsApi - object-oriented interface
 * @export
 * @class PoolsApi
 * @extends {BaseAPI}
 */
export class PoolsApi extends BaseAPI {
    /**
     * 
     * @summary Create enterprise pool with the parameters given.
     * @param {string} enterpriseID Enterprise ID.
     * @param {CreatePoolParams} body Parameters used when creating the enterprise pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public createEnterprisePool(enterpriseID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).createEnterprisePool(enterpriseID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create organization pool with the parameters given.
     * @param {string} orgID Organization ID.
     * @param {CreatePoolParams} body Parameters used when creating the organization pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public createOrgPool(orgID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).createOrgPool(orgID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create repository pool with the parameters given.
     * @param {string} repoID Repository ID.
     * @param {CreatePoolParams} body Parameters used when creating the repository pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public createRepoPool(repoID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).createRepoPool(repoID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete enterprise pool by ID.
     * @param {string} enterpriseID Enterprise ID.
     * @param {string} poolID ID of the enterprise pool to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public deleteEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).deleteEnterprisePool(enterpriseID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organization pool by ID.
     * @param {string} orgID Organization ID.
     * @param {string} poolID ID of the organization pool to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public deleteOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).deleteOrgPool(orgID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete pool by ID.
     * @param {string} poolID ID of the pool to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public deletePool(poolID: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).deletePool(poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete repository pool by ID.
     * @param {string} repoID Repository ID.
     * @param {string} poolID ID of the repository pool to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public deleteRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).deleteRepoPool(repoID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get enterprise pool by ID.
     * @param {string} enterpriseID Enterprise ID.
     * @param {string} poolID Pool ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getEnterprisePool(enterpriseID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).getEnterprisePool(enterpriseID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization pool by ID.
     * @param {string} orgID Organization ID.
     * @param {string} poolID Pool ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getOrgPool(orgID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).getOrgPool(orgID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pool by ID.
     * @param {string} poolID ID of the pool to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getPool(poolID: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).getPool(poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get repository pool by ID.
     * @param {string} repoID Repository ID.
     * @param {string} poolID Pool ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).getRepoPool(repoID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List enterprise pools.
     * @param {string} enterpriseID Enterprise ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public listEnterprisePools(enterpriseID: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).listEnterprisePools(enterpriseID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization pools.
     * @param {string} orgID Organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public listOrgPools(orgID: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).listOrgPools(orgID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all pools.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public listPools(options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).listPools(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List repository pools.
     * @param {string} repoID Repository ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public listRepoPools(repoID: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).listRepoPools(repoID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update enterprise pool with the parameters given.
     * @param {string} enterpriseID Enterprise ID.
     * @param {string} poolID ID of the enterprise pool to update.
     * @param {UpdatePoolParams} body Parameters used when updating the enterprise pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public updateEnterprisePool(enterpriseID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).updateEnterprisePool(enterpriseID, poolID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization pool with the parameters given.
     * @param {string} orgID Organization ID.
     * @param {string} poolID ID of the organization pool to update.
     * @param {UpdatePoolParams} body Parameters used when updating the organization pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public updateOrgPool(orgID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).updateOrgPool(orgID, poolID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update pool by ID.
     * @param {string} poolID ID of the pool to update.
     * @param {UpdatePoolParams} body Parameters to update the pool with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public updatePool(poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).updatePool(poolID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update repository pool with the parameters given.
     * @param {string} repoID Repository ID.
     * @param {string} poolID ID of the repository pool to update.
     * @param {UpdatePoolParams} body Parameters used when updating the repository pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public updateRepoPool(repoID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).updateRepoPool(repoID, poolID, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvidersApi - axios parameter creator
 * @export
 */
export const ProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvidersApi - functional programming interface
 * @export
 */
export const ProvidersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvidersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Provider>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProviders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvidersApi.listProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvidersApi - factory interface
 * @export
 */
export const ProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvidersApiFp(configuration)
    return {
        /**
         * 
         * @summary List all providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviders(options?: RawAxiosRequestConfig): AxiosPromise<Array<Provider>> {
            return localVarFp.listProviders(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvidersApi - object-oriented interface
 * @export
 * @class ProvidersApi
 * @extends {BaseAPI}
 */
export class ProvidersApi extends BaseAPI {
    /**
     * 
     * @summary List all providers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public listProviders(options?: RawAxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).listProviders(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoriesApi - axios parameter creator
 * @export
 */
export const RepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create repository with the parameters given.
         * @param {CreateRepoParams} body Parameters used when creating the repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepo: async (body: CreateRepoParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createRepo', 'body', body)
            const localVarPath = `/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreatePoolParams} body Parameters used when creating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepoPool: async (repoID: string, body: CreatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('createRepoPool', 'repoID', repoID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createRepoPool', 'body', body)
            const localVarPath = `/repositories/{repoID}/pools`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create repository scale set with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the repository scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepoScaleSet: async (repoID: string, body: CreateScaleSetParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('createRepoScaleSet', 'repoID', repoID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createRepoScaleSet', 'body', body)
            const localVarPath = `/repositories/{repoID}/scalesets`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete repository by ID.
         * @param {string} repoID ID of the repository to delete.
         * @param {boolean} [keepWebhook] If true and a webhook is installed for this repo, it will not be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepo: async (repoID: string, keepWebhook?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('deleteRepo', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (keepWebhook !== undefined) {
                localVarQueryParameter['keepWebhook'] = keepWebhook;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepoPool: async (repoID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('deleteRepoPool', 'repoID', repoID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('deleteRepoPool', 'poolID', poolID)
            const localVarPath = `/repositories/{repoID}/pools/{poolID}`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get repository by ID.
         * @param {string} repoID ID of the repository to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepo: async (repoID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('getRepo', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepoPool: async (repoID: string, poolID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('getRepoPool', 'repoID', repoID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('getRepoPool', 'poolID', poolID)
            const localVarPath = `/repositories/{repoID}/pools/{poolID}`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about the GARM installed webhook on a repository.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepoWebhookInfo: async (repoID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('getRepoWebhookInfo', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}/webhook`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} repoID Repository ID.
         * @param {InstallWebhookParams} body Parameters used when creating the repository webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installRepoWebhook: async (repoID: string, body: InstallWebhookParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('installRepoWebhook', 'repoID', repoID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('installRepoWebhook', 'body', body)
            const localVarPath = `/repositories/{repoID}/webhook`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List repository instances.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoInstances: async (repoID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('listRepoInstances', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}/instances`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List repository pools.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoPools: async (repoID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('listRepoPools', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}/pools`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List repository scale sets.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoScaleSets: async (repoID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('listRepoScaleSets', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}/scalesets`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List repositories.
         * @param {string} [owner] Exact owner name to filter by
         * @param {string} [name] Exact repository name to filter by
         * @param {string} [endpoint] Exact endpoint name to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepos: async (owner?: string, name?: string, endpoint?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (endpoint !== undefined) {
                localVarQueryParameter['endpoint'] = endpoint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallRepoWebhook: async (repoID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('uninstallRepoWebhook', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}/webhook`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update repository with the parameters given.
         * @param {string} repoID ID of the repository to update.
         * @param {UpdateEntityParams} body Parameters used when updating the repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepo: async (repoID: string, body: UpdateEntityParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('updateRepo', 'repoID', repoID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRepo', 'body', body)
            const localVarPath = `/repositories/{repoID}`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepoPool: async (repoID: string, poolID: string, body: UpdatePoolParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('updateRepoPool', 'repoID', repoID)
            // verify required parameter 'poolID' is not null or undefined
            assertParamExists('updateRepoPool', 'poolID', poolID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRepoPool', 'body', body)
            const localVarPath = `/repositories/{repoID}/pools/{poolID}`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)))
                .replace(`{${"poolID"}}`, encodeURIComponent(String(poolID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesApi - functional programming interface
 * @export
 */
export const RepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create repository with the parameters given.
         * @param {CreateRepoParams} body Parameters used when creating the repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepo(body: CreateRepoParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepo(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.createRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreatePoolParams} body Parameters used when creating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepoPool(repoID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepoPool(repoID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.createRepoPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create repository scale set with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the repository scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepoScaleSet(repoID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScaleSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepoScaleSet(repoID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.createRepoScaleSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete repository by ID.
         * @param {string} repoID ID of the repository to delete.
         * @param {boolean} [keepWebhook] If true and a webhook is installed for this repo, it will not be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepo(repoID: string, keepWebhook?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepo(repoID, keepWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.deleteRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepoPool(repoID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.deleteRepoPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get repository by ID.
         * @param {string} repoID ID of the repository to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepo(repoID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepo(repoID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.getRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepoPool(repoID, poolID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.getRepoPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about the GARM installed webhook on a repository.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepoWebhookInfo(repoID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepoWebhookInfo(repoID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.getRepoWebhookInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} repoID Repository ID.
         * @param {InstallWebhookParams} body Parameters used when creating the repository webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installRepoWebhook(repoID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installRepoWebhook(repoID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.installRepoWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List repository instances.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepoInstances(repoID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Instance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepoInstances(repoID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.listRepoInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List repository pools.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepoPools(repoID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepoPools(repoID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.listRepoPools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List repository scale sets.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepoScaleSets(repoID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScaleSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepoScaleSets(repoID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.listRepoScaleSets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List repositories.
         * @param {string} [owner] Exact owner name to filter by
         * @param {string} [name] Exact repository name to filter by
         * @param {string} [endpoint] Exact endpoint name to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepos(owner?: string, name?: string, endpoint?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepos(owner, name, endpoint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.listRepos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallRepoWebhook(repoID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallRepoWebhook(repoID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.uninstallRepoWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update repository with the parameters given.
         * @param {string} repoID ID of the repository to update.
         * @param {UpdateEntityParams} body Parameters used when updating the repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepo(repoID: string, body: UpdateEntityParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepo(repoID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.updateRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepoPool(repoID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepoPool(repoID, poolID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.updateRepoPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RepositoriesApi - factory interface
 * @export
 */
export const RepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create repository with the parameters given.
         * @param {CreateRepoParams} body Parameters used when creating the repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepo(body: CreateRepoParams, options?: RawAxiosRequestConfig): AxiosPromise<Repository> {
            return localVarFp.createRepo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreatePoolParams} body Parameters used when creating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepoPool(repoID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.createRepoPool(repoID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create repository scale set with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the repository scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepoScaleSet(repoID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): AxiosPromise<ScaleSet> {
            return localVarFp.createRepoScaleSet(repoID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete repository by ID.
         * @param {string} repoID ID of the repository to delete.
         * @param {boolean} [keepWebhook] If true and a webhook is installed for this repo, it will not be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepo(repoID: string, keepWebhook?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteRepo(repoID, keepWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteRepoPool(repoID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get repository by ID.
         * @param {string} repoID ID of the repository to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepo(repoID: string, options?: RawAxiosRequestConfig): AxiosPromise<Repository> {
            return localVarFp.getRepo(repoID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get repository pool by ID.
         * @param {string} repoID Repository ID.
         * @param {string} poolID Pool ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.getRepoPool(repoID, poolID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about the GARM installed webhook on a repository.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepoWebhookInfo(repoID: string, options?: RawAxiosRequestConfig): AxiosPromise<HookInfo> {
            return localVarFp.getRepoWebhookInfo(repoID, options).then((request) => request(axios, basePath));
        },
        /**
         * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
         * @param {string} repoID Repository ID.
         * @param {InstallWebhookParams} body Parameters used when creating the repository webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installRepoWebhook(repoID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig): AxiosPromise<HookInfo> {
            return localVarFp.installRepoWebhook(repoID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List repository instances.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoInstances(repoID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Instance>> {
            return localVarFp.listRepoInstances(repoID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List repository pools.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoPools(repoID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Pool>> {
            return localVarFp.listRepoPools(repoID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List repository scale sets.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoScaleSets(repoID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScaleSet>> {
            return localVarFp.listRepoScaleSets(repoID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List repositories.
         * @param {string} [owner] Exact owner name to filter by
         * @param {string} [name] Exact repository name to filter by
         * @param {string} [endpoint] Exact endpoint name to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepos(owner?: string, name?: string, endpoint?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Repository>> {
            return localVarFp.listRepos(owner, name, endpoint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uninstall organization webhook.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallRepoWebhook(repoID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.uninstallRepoWebhook(repoID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update repository with the parameters given.
         * @param {string} repoID ID of the repository to update.
         * @param {UpdateEntityParams} body Parameters used when updating the repository.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepo(repoID: string, body: UpdateEntityParams, options?: RawAxiosRequestConfig): AxiosPromise<Repository> {
            return localVarFp.updateRepo(repoID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update repository pool with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {string} poolID ID of the repository pool to update.
         * @param {UpdatePoolParams} body Parameters used when updating the repository pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepoPool(repoID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig): AxiosPromise<Pool> {
            return localVarFp.updateRepoPool(repoID, poolID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesApi - object-oriented interface
 * @export
 * @class RepositoriesApi
 * @extends {BaseAPI}
 */
export class RepositoriesApi extends BaseAPI {
    /**
     * 
     * @summary Create repository with the parameters given.
     * @param {CreateRepoParams} body Parameters used when creating the repository.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public createRepo(body: CreateRepoParams, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).createRepo(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create repository pool with the parameters given.
     * @param {string} repoID Repository ID.
     * @param {CreatePoolParams} body Parameters used when creating the repository pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public createRepoPool(repoID: string, body: CreatePoolParams, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).createRepoPool(repoID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create repository scale set with the parameters given.
     * @param {string} repoID Repository ID.
     * @param {CreateScaleSetParams} body Parameters used when creating the repository scale set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public createRepoScaleSet(repoID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).createRepoScaleSet(repoID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete repository by ID.
     * @param {string} repoID ID of the repository to delete.
     * @param {boolean} [keepWebhook] If true and a webhook is installed for this repo, it will not be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public deleteRepo(repoID: string, keepWebhook?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).deleteRepo(repoID, keepWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete repository pool by ID.
     * @param {string} repoID Repository ID.
     * @param {string} poolID ID of the repository pool to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public deleteRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).deleteRepoPool(repoID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get repository by ID.
     * @param {string} repoID ID of the repository to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public getRepo(repoID: string, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).getRepo(repoID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get repository pool by ID.
     * @param {string} repoID Repository ID.
     * @param {string} poolID Pool ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public getRepoPool(repoID: string, poolID: string, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).getRepoPool(repoID, poolID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about the GARM installed webhook on a repository.
     * @param {string} repoID Repository ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public getRepoWebhookInfo(repoID: string, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).getRepoWebhookInfo(repoID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Install the GARM webhook for an organization. The secret configured on the organization will be used to validate the requests.
     * @param {string} repoID Repository ID.
     * @param {InstallWebhookParams} body Parameters used when creating the repository webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public installRepoWebhook(repoID: string, body: InstallWebhookParams, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).installRepoWebhook(repoID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List repository instances.
     * @param {string} repoID Repository ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public listRepoInstances(repoID: string, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).listRepoInstances(repoID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List repository pools.
     * @param {string} repoID Repository ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public listRepoPools(repoID: string, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).listRepoPools(repoID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List repository scale sets.
     * @param {string} repoID Repository ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public listRepoScaleSets(repoID: string, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).listRepoScaleSets(repoID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List repositories.
     * @param {string} [owner] Exact owner name to filter by
     * @param {string} [name] Exact repository name to filter by
     * @param {string} [endpoint] Exact endpoint name to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public listRepos(owner?: string, name?: string, endpoint?: string, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).listRepos(owner, name, endpoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uninstall organization webhook.
     * @param {string} repoID Repository ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public uninstallRepoWebhook(repoID: string, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).uninstallRepoWebhook(repoID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update repository with the parameters given.
     * @param {string} repoID ID of the repository to update.
     * @param {UpdateEntityParams} body Parameters used when updating the repository.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public updateRepo(repoID: string, body: UpdateEntityParams, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).updateRepo(repoID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update repository pool with the parameters given.
     * @param {string} repoID Repository ID.
     * @param {string} poolID ID of the repository pool to update.
     * @param {UpdatePoolParams} body Parameters used when updating the repository pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public updateRepoPool(repoID: string, poolID: string, body: UpdatePoolParams, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).updateRepoPool(repoID, poolID, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScalesetsApi - axios parameter creator
 * @export
 */
export const ScalesetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the enterprise scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterpriseScaleSet: async (enterpriseID: string, body: CreateScaleSetParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('createEnterpriseScaleSet', 'enterpriseID', enterpriseID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createEnterpriseScaleSet', 'body', body)
            const localVarPath = `/enterprises/{enterpriseID}/scalesets`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create organization scale set with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the organization scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgScaleSet: async (orgID: string, body: CreateScaleSetParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('createOrgScaleSet', 'orgID', orgID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrgScaleSet', 'body', body)
            const localVarPath = `/organizations/{orgID}/scalesets`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create repository scale set with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the repository scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepoScaleSet: async (repoID: string, body: CreateScaleSetParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('createRepoScaleSet', 'repoID', repoID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createRepoScaleSet', 'body', body)
            const localVarPath = `/repositories/{repoID}/scalesets`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete scale set by ID.
         * @param {string} scalesetID ID of the scale set to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScaleSet: async (scalesetID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scalesetID' is not null or undefined
            assertParamExists('deleteScaleSet', 'scalesetID', scalesetID)
            const localVarPath = `/scalesets/{scalesetID}`
                .replace(`{${"scalesetID"}}`, encodeURIComponent(String(scalesetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get scale set by ID.
         * @param {string} scalesetID ID of the scale set to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScaleSet: async (scalesetID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scalesetID' is not null or undefined
            assertParamExists('getScaleSet', 'scalesetID', scalesetID)
            const localVarPath = `/scalesets/{scalesetID}`
                .replace(`{${"scalesetID"}}`, encodeURIComponent(String(scalesetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List enterprise scale sets.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterpriseScaleSets: async (enterpriseID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enterpriseID' is not null or undefined
            assertParamExists('listEnterpriseScaleSets', 'enterpriseID', enterpriseID)
            const localVarPath = `/enterprises/{enterpriseID}/scalesets`
                .replace(`{${"enterpriseID"}}`, encodeURIComponent(String(enterpriseID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization scale sets.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgScaleSets: async (orgID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgID' is not null or undefined
            assertParamExists('listOrgScaleSets', 'orgID', orgID)
            const localVarPath = `/organizations/{orgID}/scalesets`
                .replace(`{${"orgID"}}`, encodeURIComponent(String(orgID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List repository scale sets.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoScaleSets: async (repoID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoID' is not null or undefined
            assertParamExists('listRepoScaleSets', 'repoID', repoID)
            const localVarPath = `/repositories/{repoID}/scalesets`
                .replace(`{${"repoID"}}`, encodeURIComponent(String(repoID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all scalesets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalesets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scalesets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update scale set by ID.
         * @param {string} scalesetID ID of the scale set to update.
         * @param {UpdateScaleSetParams} body Parameters to update the scale set with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScaleSet: async (scalesetID: string, body: UpdateScaleSetParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scalesetID' is not null or undefined
            assertParamExists('updateScaleSet', 'scalesetID', scalesetID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateScaleSet', 'body', body)
            const localVarPath = `/scalesets/{scalesetID}`
                .replace(`{${"scalesetID"}}`, encodeURIComponent(String(scalesetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScalesetsApi - functional programming interface
 * @export
 */
export const ScalesetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScalesetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the enterprise scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnterpriseScaleSet(enterpriseID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScaleSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnterpriseScaleSet(enterpriseID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalesetsApi.createEnterpriseScaleSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create organization scale set with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the organization scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrgScaleSet(orgID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScaleSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrgScaleSet(orgID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalesetsApi.createOrgScaleSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create repository scale set with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the repository scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepoScaleSet(repoID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScaleSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepoScaleSet(repoID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalesetsApi.createRepoScaleSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete scale set by ID.
         * @param {string} scalesetID ID of the scale set to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScaleSet(scalesetID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScaleSet(scalesetID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalesetsApi.deleteScaleSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get scale set by ID.
         * @param {string} scalesetID ID of the scale set to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScaleSet(scalesetID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScaleSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScaleSet(scalesetID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalesetsApi.getScaleSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List enterprise scale sets.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnterpriseScaleSets(enterpriseID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScaleSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnterpriseScaleSets(enterpriseID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalesetsApi.listEnterpriseScaleSets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization scale sets.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgScaleSets(orgID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScaleSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgScaleSets(orgID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalesetsApi.listOrgScaleSets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List repository scale sets.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepoScaleSets(repoID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScaleSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepoScaleSets(repoID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalesetsApi.listRepoScaleSets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all scalesets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalesets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScaleSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalesets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalesetsApi.listScalesets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update scale set by ID.
         * @param {string} scalesetID ID of the scale set to update.
         * @param {UpdateScaleSetParams} body Parameters to update the scale set with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScaleSet(scalesetID: string, body: UpdateScaleSetParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScaleSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScaleSet(scalesetID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScalesetsApi.updateScaleSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScalesetsApi - factory interface
 * @export
 */
export const ScalesetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScalesetsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create enterprise pool with the parameters given.
         * @param {string} enterpriseID Enterprise ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the enterprise scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterpriseScaleSet(enterpriseID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): AxiosPromise<ScaleSet> {
            return localVarFp.createEnterpriseScaleSet(enterpriseID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create organization scale set with the parameters given.
         * @param {string} orgID Organization ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the organization scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrgScaleSet(orgID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): AxiosPromise<ScaleSet> {
            return localVarFp.createOrgScaleSet(orgID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create repository scale set with the parameters given.
         * @param {string} repoID Repository ID.
         * @param {CreateScaleSetParams} body Parameters used when creating the repository scale set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepoScaleSet(repoID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig): AxiosPromise<ScaleSet> {
            return localVarFp.createRepoScaleSet(repoID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete scale set by ID.
         * @param {string} scalesetID ID of the scale set to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScaleSet(scalesetID: string, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteScaleSet(scalesetID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get scale set by ID.
         * @param {string} scalesetID ID of the scale set to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScaleSet(scalesetID: string, options?: RawAxiosRequestConfig): AxiosPromise<ScaleSet> {
            return localVarFp.getScaleSet(scalesetID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List enterprise scale sets.
         * @param {string} enterpriseID Enterprise ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterpriseScaleSets(enterpriseID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScaleSet>> {
            return localVarFp.listEnterpriseScaleSets(enterpriseID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization scale sets.
         * @param {string} orgID Organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgScaleSets(orgID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScaleSet>> {
            return localVarFp.listOrgScaleSets(orgID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List repository scale sets.
         * @param {string} repoID Repository ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepoScaleSets(repoID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScaleSet>> {
            return localVarFp.listRepoScaleSets(repoID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all scalesets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalesets(options?: RawAxiosRequestConfig): AxiosPromise<Array<ScaleSet>> {
            return localVarFp.listScalesets(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update scale set by ID.
         * @param {string} scalesetID ID of the scale set to update.
         * @param {UpdateScaleSetParams} body Parameters to update the scale set with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScaleSet(scalesetID: string, body: UpdateScaleSetParams, options?: RawAxiosRequestConfig): AxiosPromise<ScaleSet> {
            return localVarFp.updateScaleSet(scalesetID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScalesetsApi - object-oriented interface
 * @export
 * @class ScalesetsApi
 * @extends {BaseAPI}
 */
export class ScalesetsApi extends BaseAPI {
    /**
     * 
     * @summary Create enterprise pool with the parameters given.
     * @param {string} enterpriseID Enterprise ID.
     * @param {CreateScaleSetParams} body Parameters used when creating the enterprise scale set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalesetsApi
     */
    public createEnterpriseScaleSet(enterpriseID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig) {
        return ScalesetsApiFp(this.configuration).createEnterpriseScaleSet(enterpriseID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create organization scale set with the parameters given.
     * @param {string} orgID Organization ID.
     * @param {CreateScaleSetParams} body Parameters used when creating the organization scale set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalesetsApi
     */
    public createOrgScaleSet(orgID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig) {
        return ScalesetsApiFp(this.configuration).createOrgScaleSet(orgID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create repository scale set with the parameters given.
     * @param {string} repoID Repository ID.
     * @param {CreateScaleSetParams} body Parameters used when creating the repository scale set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalesetsApi
     */
    public createRepoScaleSet(repoID: string, body: CreateScaleSetParams, options?: RawAxiosRequestConfig) {
        return ScalesetsApiFp(this.configuration).createRepoScaleSet(repoID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete scale set by ID.
     * @param {string} scalesetID ID of the scale set to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalesetsApi
     */
    public deleteScaleSet(scalesetID: string, options?: RawAxiosRequestConfig) {
        return ScalesetsApiFp(this.configuration).deleteScaleSet(scalesetID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get scale set by ID.
     * @param {string} scalesetID ID of the scale set to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalesetsApi
     */
    public getScaleSet(scalesetID: string, options?: RawAxiosRequestConfig) {
        return ScalesetsApiFp(this.configuration).getScaleSet(scalesetID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List enterprise scale sets.
     * @param {string} enterpriseID Enterprise ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalesetsApi
     */
    public listEnterpriseScaleSets(enterpriseID: string, options?: RawAxiosRequestConfig) {
        return ScalesetsApiFp(this.configuration).listEnterpriseScaleSets(enterpriseID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization scale sets.
     * @param {string} orgID Organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalesetsApi
     */
    public listOrgScaleSets(orgID: string, options?: RawAxiosRequestConfig) {
        return ScalesetsApiFp(this.configuration).listOrgScaleSets(orgID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List repository scale sets.
     * @param {string} repoID Repository ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalesetsApi
     */
    public listRepoScaleSets(repoID: string, options?: RawAxiosRequestConfig) {
        return ScalesetsApiFp(this.configuration).listRepoScaleSets(repoID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all scalesets.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalesetsApi
     */
    public listScalesets(options?: RawAxiosRequestConfig) {
        return ScalesetsApiFp(this.configuration).listScalesets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update scale set by ID.
     * @param {string} scalesetID ID of the scale set to update.
     * @param {UpdateScaleSetParams} body Parameters to update the scale set with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScalesetsApi
     */
    public updateScaleSet(scalesetID: string, body: UpdateScaleSetParams, options?: RawAxiosRequestConfig) {
        return ScalesetsApiFp(this.configuration).updateScaleSet(scalesetID, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create template with the parameters given.
         * @param {CreateTemplateParams} body Parameters used when creating the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: async (body: CreateTemplateParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createTemplate', 'body', body)
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get template by ID.
         * @param {number} templateID ID of the template to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: async (templateID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateID' is not null or undefined
            assertParamExists('deleteTemplate', 'templateID', templateID)
            const localVarPath = `/templates/{templateID}`
                .replace(`{${"templateID"}}`, encodeURIComponent(String(templateID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get template by ID.
         * @param {number} templateID ID of the template to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: async (templateID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateID' is not null or undefined
            assertParamExists('getTemplate', 'templateID', templateID)
            const localVarPath = `/templates/{templateID}`
                .replace(`{${"templateID"}}`, encodeURIComponent(String(templateID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List templates.
         * @param {string} [osType] OS type of the templates.
         * @param {string} [partialName] Partial or full name of the template.
         * @param {string} [forgeType] Forge type of the templates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates: async (osType?: string, partialName?: string, forgeType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (osType !== undefined) {
                localVarQueryParameter['osType'] = osType;
            }

            if (partialName !== undefined) {
                localVarQueryParameter['partialName'] = partialName;
            }

            if (forgeType !== undefined) {
                localVarQueryParameter['forgeType'] = forgeType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create template with the parameters given.
         * @param {RestoreTemplateRequest} body Parameters used when restoring the templates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreTemplates: async (body: RestoreTemplateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('restoreTemplates', 'body', body)
            const localVarPath = `/templates/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update template with the parameters given.
         * @param {string} templateID ID of the template to update.
         * @param {UpdateTemplateParams} body Parameters used when updating the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate: async (templateID: string, body: UpdateTemplateParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateID' is not null or undefined
            assertParamExists('updateTemplate', 'templateID', templateID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateTemplate', 'body', body)
            const localVarPath = `/templates/{templateID}`
                .replace(`{${"templateID"}}`, encodeURIComponent(String(templateID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create template with the parameters given.
         * @param {CreateTemplateParams} body Parameters used when creating the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTemplate(body: CreateTemplateParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTemplate(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.createTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get template by ID.
         * @param {number} templateID ID of the template to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTemplate(templateID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTemplate(templateID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.deleteTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get template by ID.
         * @param {number} templateID ID of the template to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplate(templateID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplate(templateID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.getTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List templates.
         * @param {string} [osType] OS type of the templates.
         * @param {string} [partialName] Partial or full name of the template.
         * @param {string} [forgeType] Forge type of the templates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTemplates(osType?: string, partialName?: string, forgeType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Template>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTemplates(osType, partialName, forgeType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.listTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create template with the parameters given.
         * @param {RestoreTemplateRequest} body Parameters used when restoring the templates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreTemplates(body: RestoreTemplateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIErrorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreTemplates(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.restoreTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update template with the parameters given.
         * @param {string} templateID ID of the template to update.
         * @param {UpdateTemplateParams} body Parameters used when updating the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTemplate(templateID: string, body: UpdateTemplateParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTemplate(templateID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.updateTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create template with the parameters given.
         * @param {CreateTemplateParams} body Parameters used when creating the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(body: CreateTemplateParams, options?: RawAxiosRequestConfig): AxiosPromise<Template> {
            return localVarFp.createTemplate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get template by ID.
         * @param {number} templateID ID of the template to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(templateID: number, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.deleteTemplate(templateID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get template by ID.
         * @param {number} templateID ID of the template to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(templateID: number, options?: RawAxiosRequestConfig): AxiosPromise<Template> {
            return localVarFp.getTemplate(templateID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List templates.
         * @param {string} [osType] OS type of the templates.
         * @param {string} [partialName] Partial or full name of the template.
         * @param {string} [forgeType] Forge type of the templates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(osType?: string, partialName?: string, forgeType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Template>> {
            return localVarFp.listTemplates(osType, partialName, forgeType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create template with the parameters given.
         * @param {RestoreTemplateRequest} body Parameters used when restoring the templates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreTemplates(body: RestoreTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<APIErrorResponse> {
            return localVarFp.restoreTemplates(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update template with the parameters given.
         * @param {string} templateID ID of the template to update.
         * @param {UpdateTemplateParams} body Parameters used when updating the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(templateID: string, body: UpdateTemplateParams, options?: RawAxiosRequestConfig): AxiosPromise<Template> {
            return localVarFp.updateTemplate(templateID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Create template with the parameters given.
     * @param {CreateTemplateParams} body Parameters used when creating the template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public createTemplate(body: CreateTemplateParams, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).createTemplate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get template by ID.
     * @param {number} templateID ID of the template to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public deleteTemplate(templateID: number, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).deleteTemplate(templateID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get template by ID.
     * @param {number} templateID ID of the template to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getTemplate(templateID: number, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getTemplate(templateID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List templates.
     * @param {string} [osType] OS type of the templates.
     * @param {string} [partialName] Partial or full name of the template.
     * @param {string} [forgeType] Forge type of the templates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public listTemplates(osType?: string, partialName?: string, forgeType?: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).listTemplates(osType, partialName, forgeType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create template with the parameters given.
     * @param {RestoreTemplateRequest} body Parameters used when restoring the templates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public restoreTemplates(body: RestoreTemplateRequest, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).restoreTemplates(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update template with the parameters given.
     * @param {string} templateID ID of the template to update.
     * @param {UpdateTemplateParams} body Parameters used when updating the template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public updateTemplate(templateID: string, body: UpdateTemplateParams, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).updateTemplate(templateID, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ToolsApi - axios parameter creator
 * @export
 */
export const ToolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List GARM agent tools.
         * @param {number} [page] The page at which to list.
         * @param {number} [pageSize] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        garmAgentList: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tools/garm-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ToolsApi - functional programming interface
 * @export
 */
export const ToolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ToolsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List GARM agent tools.
         * @param {number} [page] The page at which to list.
         * @param {number} [pageSize] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async garmAgentList(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GARMAgentToolsPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.garmAgentList(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolsApi.garmAgentList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ToolsApi - factory interface
 * @export
 */
export const ToolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ToolsApiFp(configuration)
    return {
        /**
         * 
         * @summary List GARM agent tools.
         * @param {number} [page] The page at which to list.
         * @param {number} [pageSize] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        garmAgentList(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<GARMAgentToolsPaginatedResponse> {
            return localVarFp.garmAgentList(page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ToolsApi - object-oriented interface
 * @export
 * @class ToolsApi
 * @extends {BaseAPI}
 */
export class ToolsApi extends BaseAPI {
    /**
     * 
     * @summary List GARM agent tools.
     * @param {number} [page] The page at which to list.
     * @param {number} [pageSize] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolsApi
     */
    public garmAgentList(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ToolsApiFp(this.configuration).garmAgentList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



