// Code generated by go-swagger; DO NOT EDIT.

package repositories

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new repositories API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new repositories API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new repositories API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for repositories API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateRepo(params *CreateRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoOK, error)

	CreateRepoByNamePool(params *CreateRepoByNamePoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoByNamePoolOK, error)

	CreateRepoByNameScaleSet(params *CreateRepoByNameScaleSetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoByNameScaleSetOK, error)

	CreateRepoPool(params *CreateRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoPoolOK, error)

	CreateRepoScaleSet(params *CreateRepoScaleSetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoScaleSetOK, error)

	DeleteRepo(params *DeleteRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	DeleteRepoByName(params *DeleteRepoByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	DeleteRepoByNamePool(params *DeleteRepoByNamePoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	DeleteRepoPool(params *DeleteRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	GetRepo(params *GetRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoOK, error)

	GetRepoByName(params *GetRepoByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoByNameOK, error)

	GetRepoByNamePool(params *GetRepoByNamePoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoByNamePoolOK, error)

	GetRepoByNameWebhookInfo(params *GetRepoByNameWebhookInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoByNameWebhookInfoOK, error)

	GetRepoPool(params *GetRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoPoolOK, error)

	GetRepoWebhookInfo(params *GetRepoWebhookInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoWebhookInfoOK, error)

	InstallRepoByNameWebhook(params *InstallRepoByNameWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InstallRepoByNameWebhookOK, error)

	InstallRepoWebhook(params *InstallRepoWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InstallRepoWebhookOK, error)

	ListRepoByNameInstances(params *ListRepoByNameInstancesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoByNameInstancesOK, error)

	ListRepoByNamePools(params *ListRepoByNamePoolsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoByNamePoolsOK, error)

	ListRepoByNameScaleSets(params *ListRepoByNameScaleSetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoByNameScaleSetsOK, error)

	ListRepoInstances(params *ListRepoInstancesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoInstancesOK, error)

	ListRepoPools(params *ListRepoPoolsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoPoolsOK, error)

	ListRepoScaleSets(params *ListRepoScaleSetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoScaleSetsOK, error)

	ListRepos(params *ListReposParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListReposOK, error)

	UninstallRepoByNameWebhook(params *UninstallRepoByNameWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	UninstallRepoWebhook(params *UninstallRepoWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	UpdateRepo(params *UpdateRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoOK, error)

	UpdateRepoByName(params *UpdateRepoByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoByNameOK, error)

	UpdateRepoByNamePool(params *UpdateRepoByNamePoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoByNamePoolOK, error)

	UpdateRepoPool(params *UpdateRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoPoolOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
CreateRepo creates repository with the parameters given
*/
func (a *Client) CreateRepo(params *CreateRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRepoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRepo",
		Method:             "POST",
		PathPattern:        "/repositories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRepoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRepoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRepoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRepoByNamePool creates repository pool with the parameters given
*/
func (a *Client) CreateRepoByNamePool(params *CreateRepoByNamePoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoByNamePoolOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRepoByNamePoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRepoByNamePool",
		Method:             "POST",
		PathPattern:        "/repositories/{owner}/{repo}/pools",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRepoByNamePoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRepoByNamePoolOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRepoByNamePoolDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRepoByNameScaleSet creates repository scale set with the parameters given
*/
func (a *Client) CreateRepoByNameScaleSet(params *CreateRepoByNameScaleSetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoByNameScaleSetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRepoByNameScaleSetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRepoByNameScaleSet",
		Method:             "POST",
		PathPattern:        "/repositories/{owner}/{repo}/scalesets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRepoByNameScaleSetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRepoByNameScaleSetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRepoByNameScaleSetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRepoPool creates repository pool with the parameters given
*/
func (a *Client) CreateRepoPool(params *CreateRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoPoolOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRepoPoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRepoPool",
		Method:             "POST",
		PathPattern:        "/repositories/{repoID}/pools",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRepoPoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRepoPoolOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRepoPoolDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRepoScaleSet creates repository scale set with the parameters given
*/
func (a *Client) CreateRepoScaleSet(params *CreateRepoScaleSetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoScaleSetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRepoScaleSetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRepoScaleSet",
		Method:             "POST",
		PathPattern:        "/repositories/{repoID}/scalesets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRepoScaleSetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRepoScaleSetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRepoScaleSetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteRepo deletes repository by ID
*/
func (a *Client) DeleteRepo(params *DeleteRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRepo",
		Method:             "DELETE",
		PathPattern:        "/repositories/{repoID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteRepoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteRepoByName deletes repository by ID
*/
func (a *Client) DeleteRepoByName(params *DeleteRepoByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepoByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRepoByName",
		Method:             "DELETE",
		PathPattern:        "/repositories/{owner}/{repo}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteRepoByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteRepoByNamePool deletes repository pool by ID
*/
func (a *Client) DeleteRepoByNamePool(params *DeleteRepoByNamePoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepoByNamePoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRepoByNamePool",
		Method:             "DELETE",
		PathPattern:        "/repositories/{owner}/{repo}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteRepoByNamePoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteRepoPool deletes repository pool by ID
*/
func (a *Client) DeleteRepoPool(params *DeleteRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepoPoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRepoPool",
		Method:             "DELETE",
		PathPattern:        "/repositories/{repoID}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteRepoPoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
GetRepo gets repository by ID
*/
func (a *Client) GetRepo(params *GetRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepo",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRepoByName gets repository by name
*/
func (a *Client) GetRepoByName(params *GetRepoByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepoByName",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoByNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoByNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRepoByNamePool gets repository pool by ID
*/
func (a *Client) GetRepoByNamePool(params *GetRepoByNamePoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoByNamePoolOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoByNamePoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepoByNamePool",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoByNamePoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoByNamePoolOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoByNamePoolDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRepoByNameWebhookInfo gets information about the g a r m installed webhook on a repository
*/
func (a *Client) GetRepoByNameWebhookInfo(params *GetRepoByNameWebhookInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoByNameWebhookInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoByNameWebhookInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepoByNameWebhookInfo",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoByNameWebhookInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoByNameWebhookInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoByNameWebhookInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRepoPool gets repository pool by ID
*/
func (a *Client) GetRepoPool(params *GetRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoPoolOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoPoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepoPool",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoPoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoPoolOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoPoolDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRepoWebhookInfo gets information about the g a r m installed webhook on a repository
*/
func (a *Client) GetRepoWebhookInfo(params *GetRepoWebhookInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoWebhookInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoWebhookInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepoWebhookInfo",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoWebhookInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoWebhookInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoWebhookInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	InstallRepoByNameWebhook Install the GARM webhook for an organization. The secret configured on the organization will

be used to validate the requests.
*/
func (a *Client) InstallRepoByNameWebhook(params *InstallRepoByNameWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InstallRepoByNameWebhookOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInstallRepoByNameWebhookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "InstallRepoByNameWebhook",
		Method:             "POST",
		PathPattern:        "/repositories/{owner}/{repo}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &InstallRepoByNameWebhookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*InstallRepoByNameWebhookOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*InstallRepoByNameWebhookDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	InstallRepoWebhook Install the GARM webhook for an organization. The secret configured on the organization will

be used to validate the requests.
*/
func (a *Client) InstallRepoWebhook(params *InstallRepoWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InstallRepoWebhookOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInstallRepoWebhookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "InstallRepoWebhook",
		Method:             "POST",
		PathPattern:        "/repositories/{repoID}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &InstallRepoWebhookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*InstallRepoWebhookOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*InstallRepoWebhookDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoByNameInstances lists repository instances
*/
func (a *Client) ListRepoByNameInstances(params *ListRepoByNameInstancesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoByNameInstancesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoByNameInstancesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoByNameInstances",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}/instances",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoByNameInstancesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoByNameInstancesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoByNameInstancesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoByNamePools lists repository pools
*/
func (a *Client) ListRepoByNamePools(params *ListRepoByNamePoolsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoByNamePoolsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoByNamePoolsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoByNamePools",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}/pools",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoByNamePoolsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoByNamePoolsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoByNamePoolsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoByNameScaleSets lists repository scale sets
*/
func (a *Client) ListRepoByNameScaleSets(params *ListRepoByNameScaleSetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoByNameScaleSetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoByNameScaleSetsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoByNameScaleSets",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}/scalesets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoByNameScaleSetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoByNameScaleSetsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoByNameScaleSetsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoInstances lists repository instances
*/
func (a *Client) ListRepoInstances(params *ListRepoInstancesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoInstancesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoInstancesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoInstances",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}/instances",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoInstancesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoInstancesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoInstancesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoPools lists repository pools
*/
func (a *Client) ListRepoPools(params *ListRepoPoolsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoPoolsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoPoolsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoPools",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}/pools",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoPoolsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoPoolsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoPoolsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoScaleSets lists repository scale sets
*/
func (a *Client) ListRepoScaleSets(params *ListRepoScaleSetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoScaleSetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoScaleSetsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoScaleSets",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}/scalesets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoScaleSetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoScaleSetsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoScaleSetsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepos lists repositories
*/
func (a *Client) ListRepos(params *ListReposParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListReposOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListReposParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepos",
		Method:             "GET",
		PathPattern:        "/repositories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListReposReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListReposOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListReposDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UninstallRepoByNameWebhook uninstalls organization webhook
*/
func (a *Client) UninstallRepoByNameWebhook(params *UninstallRepoByNameWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUninstallRepoByNameWebhookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UninstallRepoByNameWebhook",
		Method:             "DELETE",
		PathPattern:        "/repositories/{owner}/{repo}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UninstallRepoByNameWebhookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
UninstallRepoWebhook uninstalls organization webhook
*/
func (a *Client) UninstallRepoWebhook(params *UninstallRepoWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUninstallRepoWebhookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UninstallRepoWebhook",
		Method:             "DELETE",
		PathPattern:        "/repositories/{repoID}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UninstallRepoWebhookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
UpdateRepo updates repository with the parameters given
*/
func (a *Client) UpdateRepo(params *UpdateRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRepoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRepo",
		Method:             "PUT",
		PathPattern:        "/repositories/{repoID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateRepoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRepoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRepoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRepoByName updates repository with the parameters given
*/
func (a *Client) UpdateRepoByName(params *UpdateRepoByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRepoByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRepoByName",
		Method:             "PUT",
		PathPattern:        "/repositories/{owner}/{repo}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateRepoByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRepoByNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRepoByNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRepoByNamePool updates repository pool with the parameters given
*/
func (a *Client) UpdateRepoByNamePool(params *UpdateRepoByNamePoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoByNamePoolOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRepoByNamePoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRepoByNamePool",
		Method:             "PUT",
		PathPattern:        "/repositories/{owner}{repo}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateRepoByNamePoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRepoByNamePoolOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRepoByNamePoolDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRepoPool updates repository pool with the parameters given
*/
func (a *Client) UpdateRepoPool(params *UpdateRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoPoolOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRepoPoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRepoPool",
		Method:             "PUT",
		PathPattern:        "/repositories/{repoID}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateRepoPoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRepoPoolOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRepoPoolDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
