// Code generated by go-swagger; DO NOT EDIT.

package repositories

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new repositories API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new repositories API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new repositories API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for repositories API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateRepo(params *CreateRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoOK, error)

	CreateRepoPool(params *CreateRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoPoolOK, error)

	CreateRepoPoolByFriendlyName(params *CreateRepoPoolByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoPoolByFriendlyNameOK, error)

	CreateRepoScaleSet(params *CreateRepoScaleSetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoScaleSetOK, error)

	CreateRepoScaleSetByFriendlyName(params *CreateRepoScaleSetByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoScaleSetByFriendlyNameOK, error)

	DeleteRepo(params *DeleteRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	DeleteRepoByFriendlyName(params *DeleteRepoByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	DeleteRepoPool(params *DeleteRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	DeleteRepoPoolByFriendlyName(params *DeleteRepoPoolByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	GetRepo(params *GetRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoOK, error)

	GetRepoByFriendlyName(params *GetRepoByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoByFriendlyNameOK, error)

	GetRepoPool(params *GetRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoPoolOK, error)

	GetRepoPoolByFriendlyName(params *GetRepoPoolByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoPoolByFriendlyNameOK, error)

	GetRepoWebhookInfo(params *GetRepoWebhookInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoWebhookInfoOK, error)

	GetRepoWebhookInfoByFriendlyName(params *GetRepoWebhookInfoByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoWebhookInfoByFriendlyNameOK, error)

	InstallRepoWebhook(params *InstallRepoWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InstallRepoWebhookOK, error)

	InstallRepoWebhookByFriendlyName(params *InstallRepoWebhookByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InstallRepoWebhookByFriendlyNameOK, error)

	ListRepoInstances(params *ListRepoInstancesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoInstancesOK, error)

	ListRepoInstancesByFriendlyName(params *ListRepoInstancesByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoInstancesByFriendlyNameOK, error)

	ListRepoPools(params *ListRepoPoolsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoPoolsOK, error)

	ListRepoPoolsByFriendlyName(params *ListRepoPoolsByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoPoolsByFriendlyNameOK, error)

	ListRepoScaleSets(params *ListRepoScaleSetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoScaleSetsOK, error)

	ListRepoScaleSetsByFriendlyName(params *ListRepoScaleSetsByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoScaleSetsByFriendlyNameOK, error)

	ListRepos(params *ListReposParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListReposOK, error)

	UninstallRepoWebhook(params *UninstallRepoWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	UninstallRepoWebhookByFriendlyName(params *UninstallRepoWebhookByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	UpdateRepo(params *UpdateRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoOK, error)

	UpdateRepoByFriendlyName(params *UpdateRepoByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoByFriendlyNameOK, error)

	UpdateRepoPool(params *UpdateRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoPoolOK, error)

	UpdateRepoPoolByFriendlyName(params *UpdateRepoPoolByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoPoolByFriendlyNameOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
CreateRepo creates repository with the parameters given
*/
func (a *Client) CreateRepo(params *CreateRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRepoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRepo",
		Method:             "POST",
		PathPattern:        "/repositories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRepoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRepoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRepoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRepoPool creates repository pool with the parameters given
*/
func (a *Client) CreateRepoPool(params *CreateRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoPoolOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRepoPoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRepoPool",
		Method:             "POST",
		PathPattern:        "/repositories/{repoID}/pools",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRepoPoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRepoPoolOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRepoPoolDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRepoPoolByFriendlyName creates repository pool with the parameters given
*/
func (a *Client) CreateRepoPoolByFriendlyName(params *CreateRepoPoolByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoPoolByFriendlyNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRepoPoolByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRepoPoolByFriendlyName",
		Method:             "POST",
		PathPattern:        "/repositories/{owner}/{repo}/pools",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRepoPoolByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRepoPoolByFriendlyNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRepoPoolByFriendlyNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRepoScaleSet creates repository scale set with the parameters given
*/
func (a *Client) CreateRepoScaleSet(params *CreateRepoScaleSetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoScaleSetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRepoScaleSetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRepoScaleSet",
		Method:             "POST",
		PathPattern:        "/repositories/{repoID}/scalesets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRepoScaleSetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRepoScaleSetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRepoScaleSetDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRepoScaleSetByFriendlyName creates repository scale set with the parameters given
*/
func (a *Client) CreateRepoScaleSetByFriendlyName(params *CreateRepoScaleSetByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoScaleSetByFriendlyNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRepoScaleSetByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRepoScaleSetByFriendlyName",
		Method:             "POST",
		PathPattern:        "/repositories/{owner}/{repo}/scalesets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateRepoScaleSetByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRepoScaleSetByFriendlyNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRepoScaleSetByFriendlyNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteRepo deletes repository by ID
*/
func (a *Client) DeleteRepo(params *DeleteRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRepo",
		Method:             "DELETE",
		PathPattern:        "/repositories/{repoID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteRepoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteRepoByFriendlyName deletes repository by ID
*/
func (a *Client) DeleteRepoByFriendlyName(params *DeleteRepoByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepoByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRepoByFriendlyName",
		Method:             "DELETE",
		PathPattern:        "/repositories/{owner}/{repo}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteRepoByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteRepoPool deletes repository pool by ID
*/
func (a *Client) DeleteRepoPool(params *DeleteRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepoPoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRepoPool",
		Method:             "DELETE",
		PathPattern:        "/repositories/{repoID}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteRepoPoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteRepoPoolByFriendlyName deletes repository pool by ID
*/
func (a *Client) DeleteRepoPoolByFriendlyName(params *DeleteRepoPoolByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepoPoolByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRepoPoolByFriendlyName",
		Method:             "DELETE",
		PathPattern:        "/repositories/{owner}/{repo}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteRepoPoolByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
GetRepo gets repository by ID
*/
func (a *Client) GetRepo(params *GetRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepo",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRepoByFriendlyName gets repository by name
*/
func (a *Client) GetRepoByFriendlyName(params *GetRepoByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoByFriendlyNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepoByFriendlyName",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoByFriendlyNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoByFriendlyNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRepoPool gets repository pool by ID
*/
func (a *Client) GetRepoPool(params *GetRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoPoolOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoPoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepoPool",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoPoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoPoolOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoPoolDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRepoPoolByFriendlyName gets repository pool by ID
*/
func (a *Client) GetRepoPoolByFriendlyName(params *GetRepoPoolByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoPoolByFriendlyNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoPoolByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepoPoolByFriendlyName",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoPoolByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoPoolByFriendlyNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoPoolByFriendlyNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRepoWebhookInfo gets information about the g a r m installed webhook on a repository
*/
func (a *Client) GetRepoWebhookInfo(params *GetRepoWebhookInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoWebhookInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoWebhookInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepoWebhookInfo",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoWebhookInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoWebhookInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoWebhookInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRepoWebhookInfoByFriendlyName gets information about the g a r m installed webhook on a repository
*/
func (a *Client) GetRepoWebhookInfoByFriendlyName(params *GetRepoWebhookInfoByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoWebhookInfoByFriendlyNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoWebhookInfoByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRepoWebhookInfoByFriendlyName",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRepoWebhookInfoByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoWebhookInfoByFriendlyNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRepoWebhookInfoByFriendlyNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	InstallRepoWebhook Install the GARM webhook for an organization. The secret configured on the organization will

be used to validate the requests.
*/
func (a *Client) InstallRepoWebhook(params *InstallRepoWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InstallRepoWebhookOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInstallRepoWebhookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "InstallRepoWebhook",
		Method:             "POST",
		PathPattern:        "/repositories/{repoID}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &InstallRepoWebhookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*InstallRepoWebhookOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*InstallRepoWebhookDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	InstallRepoWebhookByFriendlyName Install the GARM webhook for an organization. The secret configured on the organization will

be used to validate the requests.
*/
func (a *Client) InstallRepoWebhookByFriendlyName(params *InstallRepoWebhookByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InstallRepoWebhookByFriendlyNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInstallRepoWebhookByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "InstallRepoWebhookByFriendlyName",
		Method:             "POST",
		PathPattern:        "/repositories/{owner}/{repo}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &InstallRepoWebhookByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*InstallRepoWebhookByFriendlyNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*InstallRepoWebhookByFriendlyNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoInstances lists repository instances
*/
func (a *Client) ListRepoInstances(params *ListRepoInstancesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoInstancesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoInstancesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoInstances",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}/instances",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoInstancesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoInstancesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoInstancesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoInstancesByFriendlyName lists repository instances
*/
func (a *Client) ListRepoInstancesByFriendlyName(params *ListRepoInstancesByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoInstancesByFriendlyNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoInstancesByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoInstancesByFriendlyName",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}/instances",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoInstancesByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoInstancesByFriendlyNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoInstancesByFriendlyNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoPools lists repository pools
*/
func (a *Client) ListRepoPools(params *ListRepoPoolsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoPoolsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoPoolsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoPools",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}/pools",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoPoolsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoPoolsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoPoolsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoPoolsByFriendlyName lists repository pools
*/
func (a *Client) ListRepoPoolsByFriendlyName(params *ListRepoPoolsByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoPoolsByFriendlyNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoPoolsByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoPoolsByFriendlyName",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}/pools",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoPoolsByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoPoolsByFriendlyNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoPoolsByFriendlyNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoScaleSets lists repository scale sets
*/
func (a *Client) ListRepoScaleSets(params *ListRepoScaleSetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoScaleSetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoScaleSetsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoScaleSets",
		Method:             "GET",
		PathPattern:        "/repositories/{repoID}/scalesets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoScaleSetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoScaleSetsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoScaleSetsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepoScaleSetsByFriendlyName lists repository scale sets
*/
func (a *Client) ListRepoScaleSetsByFriendlyName(params *ListRepoScaleSetsByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRepoScaleSetsByFriendlyNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRepoScaleSetsByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepoScaleSetsByFriendlyName",
		Method:             "GET",
		PathPattern:        "/repositories/{owner}/{repo}/scalesets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListRepoScaleSetsByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListRepoScaleSetsByFriendlyNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRepoScaleSetsByFriendlyNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRepos lists repositories
*/
func (a *Client) ListRepos(params *ListReposParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListReposOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListReposParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRepos",
		Method:             "GET",
		PathPattern:        "/repositories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ListReposReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListReposOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListReposDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UninstallRepoWebhook uninstalls organization webhook
*/
func (a *Client) UninstallRepoWebhook(params *UninstallRepoWebhookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUninstallRepoWebhookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UninstallRepoWebhook",
		Method:             "DELETE",
		PathPattern:        "/repositories/{repoID}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UninstallRepoWebhookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
UninstallRepoWebhookByFriendlyName uninstalls organization webhook
*/
func (a *Client) UninstallRepoWebhookByFriendlyName(params *UninstallRepoWebhookByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUninstallRepoWebhookByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UninstallRepoWebhookByFriendlyName",
		Method:             "DELETE",
		PathPattern:        "/repositories/{owner}/{repo}/webhook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UninstallRepoWebhookByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
UpdateRepo updates repository with the parameters given
*/
func (a *Client) UpdateRepo(params *UpdateRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRepoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRepo",
		Method:             "PUT",
		PathPattern:        "/repositories/{repoID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateRepoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRepoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRepoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRepoByFriendlyName updates repository with the parameters given
*/
func (a *Client) UpdateRepoByFriendlyName(params *UpdateRepoByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoByFriendlyNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRepoByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRepoByFriendlyName",
		Method:             "PUT",
		PathPattern:        "/repositories/{owner}/{repo}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateRepoByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRepoByFriendlyNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRepoByFriendlyNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRepoPool updates repository pool with the parameters given
*/
func (a *Client) UpdateRepoPool(params *UpdateRepoPoolParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoPoolOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRepoPoolParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRepoPool",
		Method:             "PUT",
		PathPattern:        "/repositories/{repoID}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateRepoPoolReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRepoPoolOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRepoPoolDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRepoPoolByFriendlyName updates repository pool with the parameters given
*/
func (a *Client) UpdateRepoPoolByFriendlyName(params *UpdateRepoPoolByFriendlyNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoPoolByFriendlyNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRepoPoolByFriendlyNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRepoPoolByFriendlyName",
		Method:             "PUT",
		PathPattern:        "/repositories/{owner}{repo}/pools/{poolID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpdateRepoPoolByFriendlyNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRepoPoolByFriendlyNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRepoPoolByFriendlyNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
